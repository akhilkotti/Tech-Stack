<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java Collections â€“ Top 50 Interview Why Questions</title>
    <style>
        body {
            font-family: "Segoe UI", Roboto, Arial, sans-serif;
            background: #f7f8fa;
            color: #1f2937;
            line-height: 1.65;
            margin: 0;
            padding: 32px;
        }

        .container {
            max-width: 1100px;
            margin: auto;
            background: #ffffff;
            padding: 40px 48px;
            border-radius: 16px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.08);
        }

        h1 {
            text-align: center;
            margin-bottom: 42px;
            color: #0f172a;
        }

        h2 {
            margin-top: 46px;
            color: #2563eb;
            border-left: 6px solid #2563eb;
            padding-left: 14px;
        }

        h3 {
            margin-top: 22px;
            color: #111827;
        }

        p {
            margin: 8px 0;
        }

        ul {
            margin: 10px 0 20px 28px;
        }

        li {
            margin-bottom: 6px;
        }

        pre {
            background: #0f172a;
            color: #e5e7eb;
            padding: 18px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 18px 0;
            font-size: 14px;
        }

        code {
            font-family: Consolas, monospace;
        }

        .note {
            background: #fef3c7;
            border-left: 6px solid #f59e0b;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .success {
            background: #dcfce7;
            border-left: 6px solid #22c55e;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .danger {
            background: #fee2e2;
            border-left: 6px solid #ef4444;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .divider {
            margin: 40px 0;
            border-top: 1px dashed #e5e7eb;
        }

        .footer {
            margin-top: 56px;
            padding-top: 28px;
            border-top: 1px solid #e5e7eb;
        }
		
		header {
			padding: 25px 20px;
		}

    /* =========================
       FEATURE CARDS
       ========================= */
    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 5px;
      justify-content: center;
      padding: 5px;
    }

    .feature-card {
      background: white;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border: 1px solid #eaeaea;
      transition: all 0.3s ease;
    }

    .feature-header {
      display: block;
      background: linear-gradient(to right, #3498db, #2c3e50);
      color: white;
      padding: 2px 2px;
      font-size: 0.8rem;
      font-weight: 600;
      text-decoration: none;
      border-radius: 10px;
      text-align: center;
    }

    .feature-header:hover {
      background: linear-gradient(to right, #2980b9, #1a252f);
    }
		
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #e74c3c;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            text-decoration: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .back-to-top:hover {
            transform: translateY(-5px);
            background: #c0392b;
        }	

		/* Back to Top button styling */
        .back-to-top-btn {
            display: inline-block;
            margin: 10px 0 20px;
            padding: 8px 15px;
            background: #f5f5f5;
            color: #2c3e50;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .back-to-top-btn:hover {
            background: #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }			
    </style>
</head>
<body>

<div class="container">

<h1>â˜• Java Collections â€” Top 50 â€œWHYâ€ Interview Questions</h1>

	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#1-section" class="feature-header">why LinkedList index access O(n) but iterator traversal O(1)?</a>
		</div>		
		<div class="feature-card">
			<a href="#5-section" class="feature-header">Why CopyOnWriteArrayList perform poorly on writes?</a>
		</div>	
		<div class="feature-card">
			<a href="#3-section" class="feature-header">Why ConcurrentHashMap not allow null keys or values?</a>
		</div>
		<div class="feature-card">
			<a href="#8-section" class="feature-header">Why override equals() and hashCode() together?</a>
		</div>		
		<div class="feature-card">
			<a href="#4-section" class="feature-header">synchronizedMap and ConcurrentHashMap</a>
		</div>
		<div class="feature-card">
			<a href="#2-section" class="feature-header">HashMap.get() O(1) but worst-case O(log n)?</a>
		</div>
		<div class="feature-card">
			<a href="#6-section" class="feature-header">Fail-Fast vs Fail-Safe</a>
		</div>
		<div class="feature-card">
			<a href="#7-section" class="feature-header">Why does removeIf() not throw CME?</a>
		</div>
		<div class="feature-card">
			<a href="#9-section" class="feature-header">Why is TreeMap slower than HashMap?</a>
		</div>
		<div class="feature-card">
			<a href="#10-section" class="feature-header">When to use EnumMap?</a>
		</div>
		<div class="feature-card">
			<a href="#11-section" class="feature-header">Iterator vs ListIterator?</a>
		</div>	
		<div class="feature-card">
			<a href="#12-section" class="feature-header">Why does enhanced for-loop throw CME?</a>
		</div>		
		<div class="feature-card">
			<a href="#13-section" class="feature-header">Why is ArrayDeque preferred over Stack?</a>
		</div>
		<div class="feature-card">
			<a href="#14-section" class="feature-header">poll() vs remove()?</a>
		</div>
		<div class="feature-card">
			<a href="#15-section" class="feature-header">Why is Vector discouraged?</a>
		</div>
		<div class="feature-card">
			<a href="#16-section" class="feature-header">Why HashSet internally uses HashMap?</a>
		</div>
		<div class="feature-card">
			<a href="#17-section" class="feature-header">Why HashMap order is not guaranteed?</a>
		</div>
		<div class="feature-card">
			<a href="#18-section" class="feature-header">LinkedHashMap vs HashMap?</a>
		</div>
		<div class="feature-card">
			<a href="#19-section" class="feature-header">What is weakly consistent iterator?</a>
		</div>
		<div class="feature-card">
			<a href="#21-section" class="feature-header">Why containsKey() + put() is unsafe?</a>
		</div>		
		<div class="feature-card">
			<a href="#20-section" class="feature-header">How does ConcurrentHashMap achieve thread safety?</a>
		</div>
		<div class="feature-card">
			<a href="#26-section" class="feature-header">Why LinkedList uses more memory than ArrayList?</a>
		</div>
		<div class="feature-card">
			<a href="#38-section" class="feature-header">How to safely remove elements while iterating?</a>
		</div>		
		<div class="feature-card">
			<a href="#24-section" class="feature-header">How does Collections.unmodifiableList() work?</a>
		</div>		
		<div class="feature-card">
			<a href="#22-section" class="feature-header">Comparable vs Comparator?</a>
		</div>
		<div class="feature-card">
			<a href="#23-section" class="feature-header">Why sorting a List of Objects may fail?</a>
		</div>
		<div class="feature-card">
			<a href="#25-section" class="feature-header">Why is size() O(1) in most collections?</a>
		</div>
		<div class="feature-card">
			<a href="#27-section" class="feature-header">When to use PriorityQueue?</a>
		</div>
		<div class="feature-card">
			<a href="#28-section" class="feature-header">Queue vs Deque?</a>
		</div>
		<div class="feature-card">
			<a href="#29-section" class="feature-header">Why HashMap resize is expensive?</a>
		</div>
		<div class="feature-card">
			<a href="#30-section" class="feature-header">What is load factor?</a>
		</div>
		<div class="feature-card">
			<a href="#31-section" class="feature-header">Why initial capacity matters?</a>
		</div>
		<div class="feature-card">
			<a href="#32-section" class="feature-header">Why Collections.sort() is stable?</a>
		</div>
		<div class="feature-card">
			<a href="#33-section" class="feature-header">Why Stream .collect() may be slower?</a>
		</div>
		<div class="feature-card">
			<a href="#34-section" class="feature-header">Why Map.keySet() is backed by map?</a>
		</div>		
		<div class="feature-card">
			<a href="#35-section" class="feature-header">entrySet() vs keySet()??</a>
		</div>
		<div class="feature-card">
			<a href="#36-section" class="feature-header">Why entrySet() is faster?</a>
		</div>
		<div class="feature-card">
			<a href="#37-section" class="feature-header">Why subList() can cause issues?</a>
		</div>
		<div class="feature-card">
			<a href="#39-section" class="feature-header">Why HashMap is not thread-safe?</a>
		</div>
		<div class="feature-card">
			<a href="#40-section" class="feature-header">Why Collections.emptyList() is immutable?</a>
		</div>
		<div class="feature-card">
			<a href="#41-section" class="feature-header">When to use WeakHashMap?</a>
		</div>
		<div class="feature-card">
			<a href="#42-section" class="feature-header">Why modifying key breaks HashMap?</a>
		</div>
		<div class="feature-card">
			<a href="#43-section" class="feature-header">peek() vs element()?</a>
		</div>
		<div class="feature-card">
			<a href="#45-section" class="feature-header">When to use Spliterator?</a>
		</div>		
		<div class="feature-card">
			<a href="#46-section" class="feature-header">Why streams donâ€™t modify source collection?</a>
		</div>
		<div class="feature-card">
			<a href="#47-section" class="feature-header">toList() vs collect()?</a>
		</div>
		<div class="feature-card">
			<a href="#48-section" class="feature-header">Why TreeSet rejects null?</a>
		</div>
		<div class="feature-card">
			<a href="#49-section" class="feature-header">When to use ConcurrentSkipListMap?</a>
		</div>
		<div class="feature-card">
			<a href="#44-section" class="feature-header">Conc.HashMap iterators donâ€™t throw CME?</a>
		</div>		
		<div class="feature-card">
			<a href="#50-section" class="feature-header">Biggest Collections Interview Rule</a>
		</div>			
	</div>	

<h2 id="1-section">1ï¸âƒ£ Why is LinkedList index access O(n) but iterator traversal O(1)?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h3>ğŸ”¹ Why LinkedList Index Access is O(n)</h3>

<h3>How LinkedList is Implemented</h3>
<ul>
    <li>LinkedList is a <b>doubly linked list</b></li>
    <li>Each element is stored as a <b>node</b></li>
    <li>Each node contains:
        <ul>
            <li><code>prev</code></li>
            <li><code>next</code></li>
            <li><code>value</code></li>
        </ul>
    </li>
</ul>

<div class="note">
There is <b>NO array</b> and <b>NO direct index access</b>.
</div>

<h3>What Happens in <code>list.get(i)</code></h3>

<pre><code>list.get(i);</code></pre>

<p><b>Internally:</b></p>
<ol>
    <li>Traversal starts from <b>head</b> (or tail if index &gt; size/2)</li>
    <li>Moves <b>node by node</b></li>
    <li>Stops when index <code>i</code> is reached</li>
</ol>

<div class="danger">
â± <b>Time complexity of one get(i): O(n)</b> (worst case)
</div>

<h3>ğŸ”¹ Why This Loop Becomes O(nÂ²)</h3>

<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);   // O(n)
}</code></pre>

<h3>Breakdown</h3>
<ul>
    <li>Loop runs <b>n</b> times</li>
    <li>Each <code>get(i)</code> costs <b>O(n)</b></li>
</ul>

<div class="danger">
ğŸ‘‰ <b>Total Complexity = O(n Ã— n) = O(nÂ²)</b><br>
ğŸ“Œ This is a <b>very common real-world performance bug</b>.
</div>

<h3>ğŸ”¹ Why Iterator Traversal is O(1) per Step</h3>

<pre><code>for (Integer i : list) {
}</code></pre>

<h3>What Really Happens</h3>
<ul>
    <li>Enhanced for-loop uses an <b>Iterator</b></li>
    <li>Iterator keeps a reference to the <b>current node</b></li>
    <li><code>next()</code> simply moves to <code>current.next</code></li>
</ul>

<pre><code>node = node.next;   // constant time</code></pre>

<div class="success">
â± Cost per step = <b>O(1)</b><br>
â± Total traversal = <b>O(n)</b>
</div>

<h3>ğŸ”¹ Visual Difference</h3>

<h3>Index Access</h3>
<pre><code>HEAD â†’ node1 â†’ node2 â†’ node3 â†’ ... â†’ node(i)
(restart traversal every time)</code></pre>

<h3>Iterator Traversal</h3>
<pre><code>HEAD â†’ node1 â†’ node2 â†’ node3 â†’ ...
(single continuous traversal)</code></pre>

<h3>ğŸ”¹ Final Complexity Comparison</h3>

<table>
    <tr>
        <th>Code</th>
        <th>Time Complexity</th>
    </tr>
    <tr>
        <td>Index-based loop on LinkedList</td>
        <td>âŒ O(nÂ²)</td>
    </tr>
    <tr>
        <td>Iterator / for-each on LinkedList</td>
        <td>âœ… O(n)</td>
    </tr>
    <tr>
        <td>Index-based loop on ArrayList</td>
        <td>âœ… O(n)</td>
    </tr>
</table>

<h3>ğŸ¯ Perfect Interview Answer</h3>

<div class="success">
â€œLinkedList does not support direct index access.  
Each call to <code>get(i)</code> requires traversal from the head or tail, which is O(n).  
When used inside a loop, this results in O(nÂ²).  
Iterator traversal maintains a pointer to the current node and moves sequentially, making each step O(1) and the overall traversal O(n).â€
</div>

<h3>ğŸ§  Golden Rule</h3>

<div class="note">
ğŸ”¥ <b>Never use index-based loops with LinkedList.  
Always use iterators or enhanced for-loops.</b>
</div>
<div class="divider"></div>
<h2 id="2-section">2ï¸âƒ£ Why is HashMap.get() O(1) but worst-case O(log n)?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	

<p>Average lookup uses hashing. In Java 8+, collision chains convert to Red-Black Trees.</p>

<h3>ğŸ”¹ Why HashMap.get() is O(1) on Average</h3>

<pre><code>map.get(key);</code></pre>

<h3>What happens internally (Average Case)</h3>
<ol>
    <li><code>key.hashCode()</code> is computed</li>
    <li>Hash is transformed into a bucket index</li>
    <li>Java jumps directly to that bucket</li>
    <li>Key is found immediately (no collision)</li>
</ol>

<div class="success">
ğŸ“Œ Direct bucket access â†’ <b>Constant Time</b><br>
â± <b>Average Complexity = O(1)</b>
</div>

<h3>Why Hashing Gives O(1)</h3>
<ul>
    <li>Buckets accessed by index</li>
    <li>No full map scan</li>
    <li>Works best with:
        <ul>
            <li>Good <code>hashCode()</code></li>
            <li>Low collisions</li>
            <li>Proper capacity & load factor</li>
        </ul>
    </li>
</ul>

<h3>ğŸ”¹ Why Collisions Happen</h3>

<p>
Different keys can map to the same bucket:
</p>

<pre><code>Bucket 5:
   keyA â†’ valueA
   keyB â†’ valueB</code></pre>

<p>
Now Java must compare keys using <code>equals()</code>.
</p>

<h3>ğŸ”¹ Preâ€“Java 8 (Worst Case = O(n))</h3>

<ul>
    <li>Buckets used <b>LinkedList</b></li>
    <li>Heavy collisions â†’ linear search</li>
</ul>

<pre><code>Bucket â†’ LinkedList â†’ scan all nodes</code></pre>

<div class="danger">
â± Worst-case complexity (Java 7 and earlier) = <b>O(n)</b>
</div>

<h3>ğŸ”¹ Java 8+ Optimization â€” Treeification â­</h3>

<h3>What Changed in Java 8</h3>
<ul>
    <li>If bucket size exceeds <b>8</b></li>
    <li>AND map size â‰¥ <b>64</b></li>
    <li>Bucket converts from LinkedList â†’ <b>Red-Black Tree</b></li>
</ul>

<pre><code>Bucket â†’ Red-Black Tree</code></pre>

<h3>ğŸ”¹ Why Red-Black Tree?</h3>

<table>
    <tr>
        <th>Structure</th>
        <th>Lookup Complexity</th>
    </tr>
    <tr>
        <td>LinkedList</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Red-Black Tree</td>
        <td><b>O(log n)</b></td>
    </tr>
</table>

<div class="success">
ğŸ“Œ Even under heavy collisions:<br>
â± <b>Worst-case complexity = O(log n)</b>
</div>

<h3>ğŸ”¹ When Does Treeification Happen?</h3>

<ul>
    <li>Bucket size â‰¥ 8</li>
    <li>Map size â‰¥ 64</li>
    <li>Keys are Comparable or tie-break ordering applies</li>
</ul>

<p>
Otherwise, HashMap resizes instead of treeifying.
</p>

<h3>ğŸ”¹ Complexity Summary</h3>

<table>
    <tr>
        <th>Scenario</th>
        <th>Complexity</th>
    </tr>
    <tr>
        <td>Average case</td>
        <td><b>O(1)</b></td>
    </tr>
    <tr>
        <td>Worst case (Java 7)</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Worst case (Java 8+)</td>
        <td><b>O(log n)</b></td>
    </tr>
</table>

<h3>ğŸ”¹ Real-World Justification</h3>

<ul>
    <li>Protects against hash collision attacks</li>
    <li>Prevents severe performance degradation</li>
    <li>Makes HashMap safer for:
        <ul>
            <li>Web applications</li>
            <li>Microservices</li>
            <li>Caching</li>
            <li>User-provided keys</li>
        </ul>
    </li>
</ul>

<h3>ğŸ”¹ Common Interview Traps</h3>

<div class="danger">
â“ Is HashMap.get() always O(1)?<br>
âŒ No â€” Average O(1), Worst O(log n)
</div>

<div class="note">
â“ Does treeification make HashMap sorted?<br>
âŒ No â€” trees exist only inside individual buckets
</div>

<h3>ğŸ¯ Perfect Interview Answer</h3>

<div class="success">
â€œHashMap.get() is O(1) on average because hashing enables direct bucket access.  
In Java 8 and later, if too many collisions occur, the bucket is converted into a Red-Black Tree, reducing the worst-case lookup time from O(n) to O(log n).â€
</div>

<h3>ğŸ§  Golden Rules</h3>

<div class="note">
ğŸ”¥ Good hashCode â†’ O(1)<br>
ğŸ”¥ Too many collisions â†’ Tree â†’ O(log n)<br>
ğŸ”¥ Never assume HashMap is always O(1)
</div>
<div class="divider"></div>

<h2 id="3-section">3ï¸âƒ£ Why does ConcurrentHashMap not allow null keys or values?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ The Problem</h2>

<pre><code>map.put(null, "x");      // âŒ NullPointerException
map.put("key", null);   // âŒ NullPointerException</code></pre>

<h2>ğŸ”¹ Short Answer (What Interviewers Expect)</h2>

<div class="note">
<b>Because <code>null</code> would make concurrent reads ambiguous.</b>
</div>

<h2>ğŸ”¹ The Real Reason (Deep Explanation)</h2>

<h3>In a Normal HashMap</h3>

<pre><code>map.get(key);</code></pre>

<p>If this returns <code>null</code>, it can mean:</p>
<ul>
    <li>The key is <b>not present</b></li>
    <li>The key exists but the value is <b>null</b></li>
</ul>

<div class="note">
In single-threaded code, this ambiguity is tolerable.
</div>

<h2>ğŸ”¹ Why This Breaks in Concurrent Systems</h2>

<h3>Imagine this in ConcurrentHashMap</h3>

<pre><code>User user = map.get(userId);</code></pre>

<p>The result is <code>null</code>. What does it mean?</p>

<ul>
    <li>â“ Another thread removed the key?</li>
    <li>â“ The key was never added?</li>
    <li>â“ The value is explicitly null?</li>
    <li>â“ A write is still in progress?</li>
</ul>

<div class="danger">
ğŸ‘‰ There is <b>no safe way</b> to distinguish these cases concurrently.
</div>

<h2>ğŸ”¹ Atomic Operations Would Break</h2>

<p>ConcurrentHashMap provides atomic methods like:</p>

<pre><code>map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> createUser());</code></pre>

<h3>If null were allowed:</h3>

<pre><code>map.put("A", null);
map.computeIfAbsent("A", k -> new User());</code></pre>

<ul>
    <li>â“ Should <code>computeIfAbsent</code> run?</li>
    <li>â“ Is <code>null</code> â€œabsentâ€ or â€œpresentâ€?</li>
</ul>

<div class="danger">
â¡ï¸ Undefined behavior â†’ âŒ NOT acceptable in concurrent code
</div>

<h2>ğŸ”¹ HashMap vs ConcurrentHashMap</h2>

<table>
    <tr>
        <th>Map Type</th>
        <th>Allows null</th>
        <th>Reason</th>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>âœ… Yes</td>
        <td>Single-threaded, ambiguity acceptable</td>
    </tr>
    <tr>
        <td>ConcurrentHashMap</td>
        <td>âŒ No</td>
        <td>Concurrency + atomic guarantees</td>
    </tr>
</table>

<h2>ğŸ”¹ Design Decision (Very Important)</h2>

<div class="success">
<b>ConcurrentHashMap chooses correctness and clarity over flexibility.</b>
</div>

<ul>
    <li>Eliminates ambiguity</li>
    <li>Simplifies concurrency guarantees</li>
    <li>Enables lock-free reads</li>
    <li>Makes atomic operations safe</li>
</ul>

<h2>ğŸ”¹ Correct Alternatives</h2>

<h3>âœ… Use Optional</h3>

<pre><code>ConcurrentHashMap&lt;String, Optional&lt;User&gt;&gt; map = new ConcurrentHashMap<>();

map.put("u1", Optional.empty());</code></pre>

<pre><code>Optional&lt;User&gt; user = map.get("u1");
user.ifPresent(u -> process(u));</code></pre>

<h3>âœ… Sentinel Object</h3>

<pre><code>static final User NULL_USER = new User("NA");

map.put("u1", NULL_USER);</code></pre>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œConcurrentHashMap does not allow null keys or values because null would make concurrent reads ambiguous.  
In a multi-threaded environment, a null return could mean absence, a concurrent removal, or an incomplete write.  
Disallowing null enables clear semantics and safe atomic operations like computeIfAbsent.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” HashMap â†’ convenience<br>
âœ” ConcurrentHashMap â†’ correctness<br>
âœ” No nulls â†’ predictable concurrency
</div>
<div class="divider"></div>

<h2 id="4-section">4ï¸âƒ£ Difference between synchronizedMap and ConcurrentHashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<ul>
    <li>synchronizedMap â†’ single global lock</li>
    <li>ConcurrentHashMap â†’ bucket-level locking</li>
</ul>
<h2>ğŸ”¹ Collections.synchronizedMap() â€” How It Works</h2>

<pre><code>Map&lt;String, String&gt; map =
    Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>

<h3>Basic</h3>
<ul>
    <li>Wraps a normal HashMap</li>
    <li>Adds <code>synchronized</code> to every method</li>
</ul>

<h3>Advanced â€“ Internal Behavior</h3>
<ul>
    <li>Uses <b>ONE global lock</b></li>
    <li>Only one thread can read/write/iterate at a time</li>
</ul>

<pre><code>Thread 1 â†’ LOCK â†’ read/write
Thread 2 â†’ WAIT
Thread 3 â†’ WAIT</code></pre>

<div class="danger">
â± <b>Performance Impact</b>
<ul>
    <li>High contention under load</li>
    <li>Poor scalability</li>
    <li>Threads block even for reads</li>
</ul>
</div>

<h3>âŒ Iteration Caveat (Very Important)</h3>

<pre><code>synchronized (map) {
    for (String key : map.keySet()) {
        // safe iteration
    }
}</code></pre>

<div class="danger">
âŒ Forgetting synchronization during iteration may cause  
<b>ConcurrentModificationException</b>
</div>

<h2>ğŸ”¹ ConcurrentHashMap â€” How It Works</h2>

<pre><code>ConcurrentHashMap&lt;String, String&gt; map =
    new ConcurrentHashMap&lt;&gt;();</code></pre>

<h3>Basic</h3>
<ul>
    <li>Built for <b>high concurrency</b></li>
    <li>Thread-safe without a global lock</li>
</ul>

<h3>Advanced â€“ Java 8+ Internals</h3>
<ul>
    <li><b>Lock-free reads</b></li>
    <li><b>Fine-grained locking</b> on buckets</li>
    <li>Uses CAS, volatile, and synchronized blocks only when required</li>
</ul>

<pre><code>Thread A â†’ Bucket 1
Thread B â†’ Bucket 5
Thread C â†’ READ (no lock)</code></pre>

<div class="success">
â± <b>Performance Impact</b>
<ul>
    <li>Multiple threads read/write simultaneously</li>
    <li>Scales with CPU cores</li>
    <li>Ideal for microservices</li>
</ul>
</div>

<h3>âœ… Iteration Behavior</h3>

<pre><code>for (Map.Entry&lt;String, String&gt; e : map.entrySet()) {
    // safe
}</code></pre>

<div class="success">
âœ” No ConcurrentModificationException<br>
âœ” Weakly consistent iterator
</div>

<h2>ğŸ”¹ Side-by-Side Comparison (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>synchronizedMap</th>
        <th>ConcurrentHashMap</th>
    </tr>
    <tr><td>Thread safety</td><td>âœ…</td><td>âœ…</td></tr>
    <tr><td>Locking</td><td>âŒ Global</td><td>âœ… Bucket-level</td></tr>
    <tr><td>Concurrent reads</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Concurrent writes</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Performance</td><td>âŒ Poor</td><td>âœ… High</td></tr>
    <tr><td>CME risk</td><td>Possible</td><td>âŒ Never</td></tr>
    <tr><td>Null keys/values</td><td>âœ…</td><td>âŒ</td></tr>
    <tr><td>Atomic operations</td><td>âŒ</td><td>âœ…</td></tr>
</table>

<h2>ğŸ”¹ Real-World Scenario Comparison</h2>

<h3>âŒ synchronizedMap (Bad Under Load)</h3>

<pre><code>Map&lt;String, User&gt; cache =
    Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>

<ul>
    <li>50 threads â†’ serialized access</li>
    <li>High latency</li>
    <li>Thread starvation</li>
</ul>

<h3>âœ… ConcurrentHashMap (Production-Grade)</h3>

<pre><code>ConcurrentHashMap&lt;String, User&gt; cache =
    new ConcurrentHashMap&lt;&gt;();</code></pre>

<ul>
    <li>Parallel reads & writes</li>
    <li>Low latency</li>
    <li>High throughput</li>
</ul>

<h2>ğŸ”¹ Atomic Operations (Huge Advantage)</h2>

<h3>âŒ synchronizedMap (NOT atomic)</h3>

<pre><code>if (!map.containsKey(key)) {
    map.put(key, value); // race condition
}</code></pre>

<h3>âœ… ConcurrentHashMap (Atomic)</h3>

<pre><code>map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> loadUser());</code></pre>

<div class="success">
âœ” Thread-safe<br>
âœ” No race conditions
</div>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts (Interview Critical)</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Prefer ConcurrentHashMap for concurrency</li>
    <li>Use atomic methods (<code>computeIfAbsent</code>)</li>
    <li>Use for caches, sessions, rate limiters</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t use synchronizedMap in high-traffic systems</li>
    <li>Donâ€™t assume HashMap + synchronized scales</li>
    <li>Donâ€™t allow nulls in ConcurrentHashMap</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œCollections.synchronizedMap uses a single global lock, allowing only one thread at a time, which limits scalability.  
ConcurrentHashMap uses fine-grained locking and lock-free reads, enabling high concurrency and better performance.  
Thatâ€™s why ConcurrentHashMap is preferred in multi-threaded and microservices environments.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Low concurrency â†’ synchronizedMap (rare)<br>
âœ” High concurrency â†’ ConcurrentHashMap (default choice)
</div>
<div class="divider"></div>

<h2 id="5-section">5ï¸âƒ£ Why does CopyOnWriteArrayList perform poorly on writes?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<div class="note">
<b>Every write operation creates a new copy of the entire underlying array.</b>
</div>

<h2>ğŸ”¹ How CopyOnWriteArrayList Works Internally</h2>

<p>
<code>CopyOnWriteArrayList</code> is built on one core idea:
</p>

<div class="note">
<b>Reads should be extremely fast and never block.</b>
</div>

<ul>
    <li>Internal array is <b>immutable for readers</b></li>
    <li>Writers always create a <b>brand-new array</b></li>
</ul>

<h2>ğŸ”¹ What Happens During a Write</h2>

<pre><code>list.add(x);</code></pre>

<h3>Internal Steps</h3>
<ol>
    <li>Acquire lock</li>
    <li>Create a <b>new array</b> (size + 1)</li>
    <li>Copy all existing elements</li>
    <li>Add new element</li>
    <li>Replace internal reference</li>
    <li>Release lock</li>
</ol>

<pre><code>Old Array â†’ [A, B, C]
New Array â†’ [A, B, C, X]   // full copy</code></pre>

<div class="danger">
â± Write Time Complexity: <b>O(n)</b><br>
ğŸ’¾ Memory Cost: <b>O(n)</b>
</div>

<h2>ğŸ”¹ What Happens During Reads (Why It Exists)</h2>

<pre><code>for (String s : list) {
    // lock-free read
}</code></pre>

<ul>
    <li>Readers see a <b>snapshot</b></li>
    <li>No locks</li>
    <li>No ConcurrentModificationException</li>
</ul>

<div class="success">
â± Read Cost: <b>O(1)</b> per access<br>
ğŸš€ Extremely fast & scalable
</div>

<h2>ğŸ”¹ Why Writes Are Expensive (Core Reason)</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>Cost</th>
    </tr>
    <tr>
        <td>Read</td>
        <td>O(1), lock-free</td>
    </tr>
    <tr>
        <td>Write (add/remove/set)</td>
        <td>âŒ O(n) + array copy</td>
    </tr>
</table>

<div class="danger">
If you have 1,000 elements:<br>
â€¢ 1 write â†’ copy 1,000 elements<br>
â€¢ 1,000 writes â†’ copy <b>1,000,000 elements</b>
</div>

<h2>ğŸ”¹ Real-Time Example (Bad Use Case âŒ)</h2>

<pre><code>CopyOnWriteArrayList<Event> events = new CopyOnWriteArrayList<>();

while (true) {
    events.add(new Event()); // terrible performance
}</code></pre>

<ul>
    <li>High CPU usage</li>
    <li>Excessive memory churn</li>
    <li>Poor throughput</li>
</ul>

<h2>ğŸ”¹ Real-Time Example (Perfect Use Case âœ…)</h2>

<h3>Event Listeners / Observers</h3>

<pre><code>CopyOnWriteArrayList<Listener> listeners = new CopyOnWriteArrayList<>();

public void notifyAll(Event e) {
    for (Listener l : listeners) {
        l.onEvent(e);
    }
}</code></pre>

<div class="success">
âœ” Read-heavy<br>
âœ” Very few writes<br>
âœ” No synchronization overhead
</div>

<h2>ğŸ”¹ When You SHOULD Use CopyOnWriteArrayList</h2>

<ul>
    <li>Reads â‰« Writes (1000:1)</li>
    <li>Iteration happens very frequently</li>
    <li>You want to avoid synchronization</li>
    <li>ConcurrentModificationException must be avoided</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Event subscribers</li>
    <li>Configuration listeners</li>
    <li>Feature flags</li>
    <li>Observer pattern</li>
</ul>

<h2>ğŸ”¹ When You Should NOT Use It</h2>

<ul>
    <li>Frequent writes</li>
    <li>Large collections</li>
    <li>High churn (add/remove often)</li>
</ul>

<p><b>Avoid for:</b></p>
<ul>
    <li>Queues</li>
    <li>Logs</li>
    <li>Caches</li>
    <li>Message buffers</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œCopyOnWriteArrayList performs poorly on writes because each write operation creates a new copy of the entire underlying array.  
This design favors fast, lock-free reads at the cost of expensive writes, making it suitable only for read-heavy and write-rare use cases.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” <b>Read-heavy â†’ CopyOnWriteArrayList</b><br>
âŒ <b>Write-heavy â†’ Avoid it</b>
</div>

<div class="divider"></div>

<h2 id="6-section">6ï¸âƒ£ Fail-Fast vs Fail-Safe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Fail-Fast throws CME; Fail-Safe iterates on a snapshot.</p>
<h2>ğŸ”¹ What is Fail-Fast?</h2>

<h3>Definition</h3>
<p>
A <b>fail-fast iterator</b> immediately throws
<code>ConcurrentModificationException</code> if a collection is structurally modified while iterating.
</p>

<div class="note">
ğŸ“Œ â€œFail early, fail loudly.â€
</div>

<h3>Example (Fail-Fast)</h3>

<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));

for (Integer i : list) {
    if (i == 2) {
        list.add(10);   // âŒ ConcurrentModificationException
    }
}</code></pre>

<h3>Internal Mechanism (VERY IMPORTANT)</h3>

<ul>
    <li>Collection maintains <code>modCount</code></li>
    <li>Iterator maintains <code>expectedModCount</code></li>
    <li>Checked on every <code>next()</code></li>
</ul>

<pre><code>if (modCount != expectedModCount)
    throw new ConcurrentModificationException();</code></pre>

<div class="danger">
âœ” Detects unsafe modification<br>
âŒ Does <b>NOT</b> guarantee thread safety
</div>

<h3>Fail-Fast Collections</h3>
<ul>
    <li>ArrayList</li>
    <li>LinkedList</li>
    <li>HashMap</li>
    <li>HashSet</li>
</ul>

<h2>ğŸ”¹ What is Fail-Safe?</h2>

<h3>Definition</h3>
<p>
A <b>fail-safe iterator</b> does <b>NOT</b> throw CME because it iterates over a
<b>snapshot copy</b> of the collection.
</p>

<div class="note">
ğŸ“Œ â€œIterate safely, even if modified.â€
</div>

<h3>Example (Fail-Safe)</h3>

<pre><code>CopyOnWriteArrayList&lt;Integer&gt; list =
    new CopyOnWriteArrayList&lt;&gt;(List.of(1, 2, 3));

for (Integer i : list) {
    list.add(10);   // âœ… NO EXCEPTION
}</code></pre>

<h3>Internal Mechanism</h3>

<ul>
    <li>Iterator works on a <b>cloned snapshot</b></li>
    <li>Writes create a <b>new copy</b></li>
    <li>Iterator never sees changes</li>
</ul>

<div class="success">
âœ” Thread-safe<br>
âœ” No CME<br>
âŒ Extra memory overhead
</div>

<h3>Fail-Safe Collections</h3>
<ul>
    <li>CopyOnWriteArrayList</li>
    <li>CopyOnWriteArraySet</li>
    <li>ConcurrentHashMap iterators</li>
</ul>

<h2>ğŸ”¹ Side-by-Side Comparison (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Fail-Fast</th>
        <th>Fail-Safe</th>
    </tr>
    <tr><td>CME thrown</td><td>âœ… Yes</td><td>âŒ No</td></tr>
    <tr><td>Iterator sees changes</td><td>âŒ</td><td>âŒ</td></tr>
    <tr><td>Works on original collection</td><td>âœ…</td><td>âŒ</td></tr>
    <tr><td>Thread-safe</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Memory usage</td><td>Low</td><td>High</td></tr>
    <tr><td>Performance</td><td>Faster</td><td>Slower (writes)</td></tr>
</table>

<h2>ğŸ”¹ Behavior Difference (Very Important)</h2>

<h3>Fail-Fast</h3>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
list.add(4);
it.next();   // âŒ CME</code></pre>

<h3>Fail-Safe</h3>

<pre><code>Iterator&lt;Integer&gt; it = cowList.iterator();
cowList.add(4);
it.next();   // âœ… Works (snapshot)</code></pre>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âœ… Use Fail-Fast when:</h3>
<ul>
    <li>Single-threaded logic</li>
    <li>Early bug detection</li>
    <li>High performance needed</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Business rules</li>
    <li>Validation logic</li>
    <li>Data processing loops</li>
</ul>

<h3>âœ… Use Fail-Safe when:</h3>
<ul>
    <li>Multi-threaded environments</li>
    <li>Read-heavy workloads</li>
    <li>Concurrent access required</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Event listeners</li>
    <li>Subscriber lists</li>
    <li>Cache readers</li>
</ul>

<h2>ğŸ”¹ Performance Trade-Off (Very Important)</h2>

<ul>
    <li><b>Fail-Fast:</b> Fast, low memory, unsafe modifications detected</li>
    <li><b>Fail-Safe:</b> Copy-on-write, slow writes, fast reads</li>
</ul>

<div class="note">
<b>Rule:</b> Many reads + few writes â†’ <b>Fail-Safe</b>
</div>

<h2>ğŸ”¹ Interview Traps (High Probability)</h2>

<div class>
â“ Is Fail-Safe always better?<br>
âŒ No â€” memory expensive
</div>

<br>

<div>
â“ Does Fail-Fast guarantee CME?<br>
âŒ No â€” best-effort only
</div>

<br>

<div>
â“ Can Fail-Safe iterators see new elements?<br>
âŒ No â€” snapshot only
</div>

<h2>ğŸ”¹ Perfect Interview Answer</h2>

<div class="success">
â€œFail-fast iterators throw ConcurrentModificationException when a collection is modified during iteration using a modCount check.  
Fail-safe iterators work on a snapshot copy of the collection, so they do not throw CME and are thread-safe, but they incur memory and performance overhead.â€
</div>

<h2>ğŸ”¹ One-Line Memory Trick ğŸ§ </h2>

<ul>
    <li><b>Fail-Fast</b> â†’ Detects bugs</li>
    <li><b>Fail-Safe</b> â†’ Avoids bugs</li>
</ul>

<h2>ğŸ”¹ Summary Table (Quick Revision)</h2>

<table>
    <tr>
        <th>Scenario</th>
        <th>Choose</th>
    </tr>
    <tr><td>Single thread</td><td>Fail-Fast</td></tr>
    <tr><td>High performance</td><td>Fail-Fast</td></tr>
    <tr><td>Multi-threaded</td><td>Fail-Safe</td></tr>
    <tr><td>Read-heavy system</td><td>Fail-Safe</td></tr>
</table>

<div class="divider"></div>

<h2 id="7-section">7ï¸âƒ£ Why does removeIf() not throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Internally uses iterator safely.</p>
<h2>â“ The Question</h2>

<pre><code>list.removeIf(x -> x &lt; 0);</code></pre>

<h2>ğŸ”¹ Short Answer (Interview-Ready)</h2>

<div class="note">
<b><code>removeIf()</code> internally uses the collectionâ€™s iterator and removes elements safely, keeping the iterator state consistent.</b>
</div>

<h2>ğŸ”¹ What Normally Causes ConcurrentModificationException</h2>

<pre><code>for (Integer x : list) {
    if (x &lt; 0) {
        list.remove(x); // âŒ CME
    }
}</code></pre>

<ul>
    <li>Enhanced for-loop uses an <b>Iterator</b></li>
    <li><code>list.remove()</code> modifies the collection <b>outside</b> the iterator</li>
    <li><code>modCount != expectedModCount</code> â†’ CME</li>
</ul>

<div class="danger">
âŒ This is the classic CME bug
</div>

<h2>ğŸ”¹ How <code>removeIf()</code> Works Internally (IMPORTANT)</h2>

<h3>Conceptual Internal Implementation</h3>

<pre><code>Iterator&lt;E&gt; it = list.iterator();
while (it.hasNext()) {
    if (predicate.test(it.next())) {
        it.remove(); // âœ… safe
    }
}</code></pre>

<h3>Why This Is Safe</h3>

<ul>
    <li><code>Iterator.remove()</code> updates the collection</li>
    <li>Also updates <code>expectedModCount</code></li>
    <li>No mismatch â†’ <b>No CME</b></li>
</ul>

<div class="success">
âœ” Iterator and collection stay in sync<br>
âœ” Safe structural modification
</div>

<h2>ğŸ”¹ Java 8 Design Decision</h2>

<p>
<code>removeIf()</code> was introduced in <b>Java 8</b> to:
</p>

<ul>
    <li>Provide safe functional-style removal</li>
    <li>Eliminate common CME bugs</li>
    <li>Encourage clean, readable code</li>
</ul>

<h2>ğŸ”¹ Time Complexity</h2>

<table>
    <tr>
        <th>Collection</th>
        <th>Complexity</th>
    </tr>
    <tr><td>ArrayList</td><td>O(n)</td></tr>
    <tr><td>LinkedList</td><td>O(n)</td></tr>
    <tr><td>HashSet</td><td>O(n)</td></tr>
</table>

<div class="note">
Still a single traversal â€” just safer.
</div>

<h2>ğŸ”¹ Real-Time Use Cases</h2>

<h3>Cleanup expired sessions</h3>
<pre><code>sessions.removeIf(Session::isExpired);</code></pre>

<h3>Remove invalid data</h3>
<pre><code>orders.removeIf(o -> o.getAmount() &lt;= 0);</code></pre>

<h3>Remove nulls</h3>
<pre><code>list.removeIf(Objects::isNull);</code></pre>

<h2>ğŸ”¹ Important Interview Traps</h2>

<div class="danger">
â“ Is <code>removeIf()</code> thread-safe?<br>
âŒ No â€” it only avoids CME in single-threaded iteration
</div>

<p><b>For concurrency use:</b></p>
<ul>
    <li>ConcurrentHashMap</li>
    <li>CopyOnWriteArrayList</li>
</ul>

<div class="danger">
â“ Does <code>removeIf()</code> work on immutable collections?<br>
âŒ No â€” throws UnsupportedOperationException
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œ<code>removeIf()</code> does not throw ConcurrentModificationException because it internally uses the collectionâ€™s iterator and calls <code>Iterator.remove()</code>, which keeps the iteratorâ€™s modification count in sync with the collection. This makes removal safe during traversal.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” <code>removeIf()</code> â†’ Safe removal<br>
âŒ for-each + remove() â†’ CME
</div>

<div class="divider"></div>

<h2 id="8-section">8ï¸âƒ£ Why override equals() and hashCode() together?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>HashMap uses both to ensure key uniqueness.</p>
<h2>â“ The Question</h2>

<h3>Short Answer (Interview-Ready)</h3>
<div class="note">
<b>HashMap uses <code>hashCode()</code> to locate the bucket and <code>equals()</code> to find the exact key inside that bucket.  
If they are inconsistent, key uniqueness breaks.</b>
</div>

<h2>ğŸ”¹ How HashMap Works Internally (IMPORTANT)</h2>

<pre><code>map.put(key, value);</code></pre>

<ul>
    <li><b>Step 1 â€“ hashCode()</b>: Determines the bucket</li>
    <li><b>Step 2 â€“ equals()</b>: Checks key equality inside the bucket</li>
</ul>

<h2>ğŸ”¹ Problem: equals() Without hashCode() âŒ</h2>

<pre><code>class User {
    String id;

    @Override
    public boolean equals(Object o) {
        return ((User) o).id.equals(this.id);
    }
    // hashCode() NOT overridden
}</code></pre>

<h3>What Goes Wrong</h3>
<ul>
    <li>Equal objects may produce different hash codes</li>
    <li>They go into different buckets</li>
</ul>

<pre><code>User u1 = new User("1");
User u2 = new User("1");

map.put(u1, "A");
map.put(u2, "B"); // âŒ Duplicate key allowed</code></pre>

<div class="danger">
HashMap thinks both keys are different.
</div>

<h2>ğŸ”¹ Problem: hashCode() Without equals() âŒ</h2>

<pre><code>class User {
    String id;

    @Override
    public int hashCode() {
        return id.hashCode();
    }
    // equals() NOT overridden
}</code></pre>

<h3>What Goes Wrong</h3>
<ul>
    <li>Keys land in the same bucket</li>
    <li>equals() falls back to reference comparison</li>
    <li>Logical duplicates are not detected</li>
</ul>

<div class="danger">
Lookups may fail and duplicates appear.
</div>

<h2>ğŸ”¹ The HashMap Contract (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Rule</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rule 1</td>
        <td>If <code>a.equals(b)</code> is true, then <code>a.hashCode() == b.hashCode()</code></td>
    </tr>
    <tr>
        <td>Rule 2</td>
        <td>Equal hash codes do NOT guarantee equals()</td>
    </tr>
    <tr>
        <td>Rule 3</td>
        <td>hashCode must be consistent</td>
    </tr>
</table>

<div class="note">
Violating this breaks HashMap, HashSet, ConcurrentHashMap.
</div>

<h2>ğŸ”¹ Correct Implementation âœ…</h2>

<pre><code>class User {
    private final String id;

    public User(String id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}</code></pre>

<div class="success">
âœ” Correct hashing<br>
âœ” No duplicates<br>
âœ” Reliable lookups
</div>

<h2>ğŸ”¹ Real-World Production Bug (VERY COMMON)</h2>

<ul>
    <li>User sessions stored in HashMap</li>
    <li>Cache misses</li>
    <li>Duplicate entries</li>
    <li>Memory leaks</li>
</ul>

<div class="danger">
<b>Root Cause:</b> equals() overridden but hashCode() missing
</div>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Always override both methods</li>
    <li>Use immutable fields</li>
    <li>Use <code>Objects.equals()</code> and <code>Objects.hash()</code></li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t override only one</li>
    <li>Donâ€™t use mutable fields in hashCode</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œHashMap uses <code>hashCode()</code> to locate the bucket and <code>equals()</code> to determine key equality within the bucket.  
Overriding only one breaks the hashing contract and leads to duplicate keys or lookup failures, so both must be overridden together.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” equals() â†’ logical equality<br>
âœ” hashCode() â†’ bucket location<br>
âœ” Both together â†’ correct hashing
</div>

<div class="divider"></div>

<h2 id="9-section">9ï¸âƒ£ Why is TreeMap slower than HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>TreeMap uses Red-Black Tree â†’ O(log n).</p>

<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>TreeMap is slower because it uses a Red-Black Tree to maintain sorted order, which requires O(log n) time for operations, whereas HashMap uses hashing for O(1) average-time access.</b>
</div>

<h2>ğŸ”¹ Internal Data Structures (Key Difference)</h2>

<table>
    <tr>
        <th>Map Type</th>
        <th>Internal Structure</th>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>Hash table (array + buckets)</td>
    </tr>
    <tr>
        <td>TreeMap</td>
        <td><b>Red-Black Tree</b> (self-balancing BST)</td>
    </tr>
</table>

<h2>ğŸ”¹ How HashMap Works (Fast)</h2>

<pre><code>map.get(key);</code></pre>

<ol>
    <li><code>hashCode()</code> â†’ bucket index</li>
    <li>Direct access to bucket</li>
    <li>Minimal comparisons</li>
</ol>

<div class="success">
â± <b>Average Time Complexity = O(1)</b>
</div>

<h2>ğŸ”¹ How TreeMap Works (Slower)</h2>

<pre><code>treeMap.get(key);</code></pre>

<ol>
    <li>Compare key with root</li>
    <li>Traverse left or right child</li>
    <li>Continue until key is found</li>
</ol>

<div class="danger">
â± <b>Time Complexity = O(log n)</b>
</div>

<h2>ğŸ”¹ Why TreeMap MUST Be Slower</h2>

<ul>
    <li>Maintains <b>sorted order</b></li>
    <li>Rebalances tree after inserts and deletes</li>
    <li>Performs <b>key comparisons</b> on every operation</li>
</ul>

<pre><code>        40
       /  \
     20    60</code></pre>

<p>
Tree rebalancing adds overhead that HashMap does not have.
</p>

<h2>ğŸ”¹ Big-O Comparison</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>HashMap</th>
        <th>TreeMap</th>
    </tr>
    <tr>
        <td>get()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>put()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>Sorted order</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âŒ Using TreeMap Unnecessarily</h3>

<pre><code>Map&lt;String, User&gt; users = new TreeMap&lt;&gt;();</code></pre>

<ul>
    <li>Slower lookups</li>
    <li>Extra CPU usage</li>
    <li>No benefit if ordering is not required</li>
</ul>

<h3>âœ… Correct Usage of TreeMap</h3>

<pre><code>TreeMap&lt;Integer, Order&gt; orders = new TreeMap&lt;&gt;();
orders.subMap(100, 200);</code></pre>

<div class="success">
âœ” Sorted keys<br>
âœ” Range queries<br>
âœ” Ordered iteration
</div>

<h2>ğŸ”¹ Interview Traps</h2>

<div class="danger">
â“ Does TreeMap use hashing?<br>
âŒ No â€” it uses <b>comparison</b>, not hashing
</div>

<div class="danger">
â“ Is TreeMap thread-safe?<br>
âŒ No â€” must be externally synchronized
</div>

<div class="note">
â“ Is TreeMap ever faster?<br>
âœ” Yes â€” for <b>range queries</b> and ordered traversal
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œTreeMap is slower than HashMap because it uses a Red-Black Tree to maintain sorted order, which requires O(log n) time for insert, delete, and lookup operations. HashMap uses hashing for direct bucket access, giving O(1) average-time performance.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Need sorting or ranges â†’ <b>TreeMap</b><br>
âœ” Need fast lookup â†’ <b>HashMap</b>
</div>
<div class="divider"></div>

<h2 id="10-section">10âƒ£  When to use EnumMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>Use EnumMap when all keys are from a single enum type and you want maximum performance, minimal memory usage, and predictable iteration order.</b>
</div>

<h2>ğŸ”¹ What Is EnumMap?</h2>

<pre><code>EnumMap&lt;Day, String&gt; map = new EnumMap&lt;&gt;(Day.class);</code></pre>

<ul>
    <li>Specialized <b>Map implementation</b></li>
    <li>Keys must be <b>enum constants</b></li>
    <li>Internally backed by an <b>array</b>, not hashing</li>
</ul>

<h2>ğŸ”¹ Why EnumMap Is Highly Optimized</h2>

<h3>Internal Working</h3>

<ul>
    <li>Uses <code>enum.ordinal()</code> as array index</li>
    <li>No hashing</li>
    <li>No collisions</li>
    <li>Direct array access</li>
</ul>

<pre><code>enum â†’ ordinal() â†’ array[index]</code></pre>

<div class="success">
â± get() â†’ <b>O(1)</b><br>
â± put() â†’ <b>O(1)</b><br>
âœ” Faster than HashMap<br>
âœ” More memory-efficient
</div>

<h2>ğŸ”¹ Ordering Behavior</h2>

<p>
Iteration order is the <b>same as enum declaration order</b>.
</p>

<pre><code>enum Day { MON, TUE, WED, THU, FRI }</code></pre>

<p>Iteration order:</p>

<pre><code>MON â†’ TUE â†’ WED â†’ THU â†’ FRI</code></pre>

<h2>ğŸ”¹ Real-World Scenarios (VERY IMPORTANT)</h2>

<ul>
    <li><b>Configuration by enum</b></li>
</ul>

<pre><code>EnumMap&lt;Environment, String&gt; envUrls;</code></pre>

<ul>
    <li><b>State machine / workflow</b></li>
</ul>

<pre><code>EnumMap&lt;OrderStatus, OrderHandler&gt; handlers;</code></pre>

<ul>
    <li><b>Strategy pattern</b></li>
</ul>

<pre><code>EnumMap&lt;PaymentType, PaymentProcessor&gt; processors;</code></pre>

<ul>
    <li><b>Feature flags</b></li>
</ul>

<pre><code>EnumMap&lt;Feature, Boolean&gt; flags;</code></pre>

<h2>ğŸ”¹ Example: Strategy Pattern</h2>

<pre><code>enum PaymentType { CARD, UPI, NETBANKING }

EnumMap&lt;PaymentType, PaymentProcessor&gt; map =
        new EnumMap&lt;&gt;(PaymentType.class);

map.put(PaymentType.CARD, new CardProcessor());
map.put(PaymentType.UPI, new UpiProcessor());

map.get(PaymentType.UPI).pay();</code></pre>

<div class="success">
âœ” Type-safe<br>
âœ” Fast<br>
âœ” Clean, extensible design
</div>

<h2>ğŸ”¹ Why NOT HashMap Here?</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>HashMap</th>
        <th>EnumMap</th>
    </tr>
    <tr>
        <td>Hashing</td>
        <td>Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Memory</td>
        <td>Higher</td>
        <td><b>Lower</b></td>
    </tr>
    <tr>
        <td>Performance</td>
        <td>Good</td>
        <td><b>Best</b></td>
    </tr>
    <tr>
        <td>Type safety</td>
        <td>Runtime</td>
        <td><b>Compile-time</b></td>
    </tr>
</table>

<h2>ğŸ”¹ Important Restrictions (Interview Trap)</h2>

<div class="danger">
âŒ Keys must be from <b>only one enum type</b><br>
âŒ <code>null</code> keys are not allowed
</div>

<pre><code>map.put(null, "x"); // âŒ NullPointerException</code></pre>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Use when keys are enums</li>
    <li>Prefer EnumMap over HashMap for enum keys</li>
    <li>Use in performance-critical paths</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t use for dynamic or non-enum keys</li>
    <li>Donâ€™t mix different enums</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œEnumMap should be used when all keys belong to a single enum type. It is highly optimized because it uses an array indexed by enum ordinals, making it faster and more memory-efficient than HashMap while maintaining predictable iteration order.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>Enum keys â†’ EnumMap (always)</b>
</div>
<div class="divider"></div>


<h2 id="11-section">1ï¸âƒ£1ï¸âƒ£ Iterator vs ListIterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>ListIterator supports bidirectional traversal and modification.</p>
<h2>1ï¸âƒ£ Iterator â€” Basics</h2>

<h3>ğŸ”¹ What is Iterator?</h3>
<p>
An <b>Iterator</b> allows <b>forward-only traversal</b> of a collection.
</p>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    Integer val = it.next();
}</code></pre>

<h3>ğŸ”¹ Key Capabilities</h3>
<ul>
    <li>âœ” Forward traversal only</li>
    <li>âœ” Read elements one by one</li>
    <li>âœ” Remove elements safely during iteration</li>
</ul>

<pre><code>it.remove(); // removes last returned element</code></pre>

<h3>ğŸ”¹ Where it works</h3>
<ul>
    <li>List</li>
    <li>Set</li>
    <li>Queue</li>
    <li>All Collection types</li>
</ul>

<h3>ğŸ”¹ Time Complexity</h3>
<ul>
    <li><code>next()</code> â†’ <b>O(1)</b></li>
    <li>Full traversal â†’ <b>O(n)</b></li>
</ul>

<div class="success">
<b>Real-World Usage</b><br>
Safe iteration and removal in LinkedList or generic collections.
</div>

<pre><code>Iterator&lt;User&gt; it = users.iterator();
while (it.hasNext()) {
    if (!it.next().isActive()) {
        it.remove();
    }
}</code></pre>

<h2>2ï¸âƒ£ ListIterator â€” Basics</h2>

<h3>ğŸ”¹ What is ListIterator?</h3>
<p>
A <b>bidirectional iterator</b> specifically for <b>List implementations</b>.
</p>

<pre><code>ListIterator&lt;Integer&gt; it = list.listIterator();</code></pre>

<h3>ğŸ”¹ Extra Capabilities (VERY IMPORTANT)</h3>
<ul>
    <li>âœ” Forward traversal</li>
    <li>âœ” <b>Backward traversal</b></li>
    <li>âœ” Modify list during iteration</li>
    <li>âœ” Access index positions</li>
</ul>

<h3>ğŸ”¹ Forward + Backward Traversal</h3>

<pre><code>while (it.hasNext()) {
    System.out.println(it.next());
}

while (it.hasPrevious()) {
    System.out.println(it.previous());
}</code></pre>

<h3>ğŸ”¹ Modification Support</h3>

<pre><code>it.add(100);   // add element
it.set(200);  // replace element</code></pre>

<div class="success">
<b>Real-World Usage</b><br>
Undo/Redo systems, text editors, cursor navigation, in-place list edits.
</div>

<h2>3ï¸âƒ£ Side-by-Side Comparison (Interview Favorite)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Iterator</th>
        <th>ListIterator</th>
    </tr>
    <tr>
        <td>Traversal</td>
        <td>Forward only</td>
        <td>Forward + Backward</td>
    </tr>
    <tr>
        <td>Works on</td>
        <td>All Collections</td>
        <td>List only</td>
    </tr>
    <tr>
        <td>Add elements</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Replace elements</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Remove elements</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Index access</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Start from index</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>4ï¸âƒ£ Starting From a Specific Position</h2>

<div class="danger">
âŒ Iterator â€“ Not possible
</div>

<div class="success">
âœ… ListIterator â€“ Supported
</div>

<pre><code>ListIterator&lt;String&gt; it = list.listIterator(3);</code></pre>

<p>Starts iteration from <b>index 3</b>.</p>

<h2>5ï¸âƒ£ LinkedList Performance Insight (VERY IMPORTANT)</h2>

<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);  // âŒ O(nÂ²) for LinkedList
}</code></pre>

<pre><code>for (Integer v : list) {
    // âœ… O(n)
}</code></pre>

<div class="note">
Enhanced for-loop internally uses an <b>Iterator / ListIterator</b>, not <code>get(i)</code>.
</div>

<h2>6ï¸âƒ£ Common Interview Traps</h2>

<div class="danger">
â“ Modify list using for-each?<br>
âŒ Throws ConcurrentModificationException
</div>

<div class="success">
âœ” Iterator.remove() â†’ Safe<br>
âœ” ListIterator.add()/set() â†’ Safe
</div>

<div class="note">
â“ Why ListIterator doesnâ€™t work with Set?<br>
Because Set has no indexes and no guaranteed order.
</div>

<h2>7ï¸âƒ£ When to Use What (Golden Rule)</h2>

<div class="success">
<b>Use Iterator when:</b><br>
âœ” Generic traversal<br>
âœ” Working with Set / Queue<br>
âœ” Forward traversal only
</div>

<div class="note">
<b>Use ListIterator when:</b><br>
âœ” Bidirectional traversal<br>
âœ” In-place modification<br>
âœ” Index awareness needed
</div>

<h2>8ï¸âƒ£ Perfect Interview Answer</h2>

<div class="success">
â€œIterator supports forward-only traversal for all collection types, whereas ListIterator is specific to List implementations and supports bidirectional traversal, element modification, and index-based navigation.â€
</div>

<h2>9ï¸âƒ£ Summary Table (Quick Revision)</h2>

<table>
    <tr>
        <th>Scenario</th>
        <th>Best Choice</th>
    </tr>
    <tr>
        <td>Iterate LinkedList</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Remove while iterating</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Traverse backward</td>
        <td>ListIterator</td>
    </tr>
    <tr>
        <td>Insert during iteration</td>
        <td>ListIterator</td>
    </tr>
    <tr>
        <td>Generic collection</td>
        <td>Iterator</td>
    </tr>
</table>
<div class="divider"></div>


<h2 id="12-section">1ï¸âƒ£2ï¸âƒ£ Why does enhanced for-loop throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>Enhanced for-loop internally uses a fail-fast Iterator.  
If the collection is modified directly during iteration, the iterator detects the change and throws ConcurrentModificationException.</b>
</div>

<h2>ğŸ”¹ What Really Happens Inside Enhanced For-Loop</h2>

<p>This code:</p>

<pre><code>for (Integer x : list) {
    // ...
}</code></pre>

<p>is compiled by Java roughly into:</p>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    Integer x = it.next();
    // ...
}</code></pre>

<div class="success">
âœ” Enhanced for-loop = <b>Iterator-based traversal</b>
</div>

<h2>ğŸ”¹ Why CME Occurs (Core Reason)</h2>

<p>Most collections (<code>ArrayList</code>, <code>HashMap</code>, etc.) are <b>fail-fast</b>.</p>

<ul>
    <li><code>modCount</code> â†’ actual modification count</li>
    <li><code>expectedModCount</code> â†’ iteratorâ€™s snapshot</li>
</ul>

<p>On every <code>next()</code> call:</p>

<pre><code>if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
}</code></pre>

<h2>ğŸ”¹ The Classic Failing Example âŒ</h2>

<pre><code>for (Integer x : list) {
    if (x &lt; 0) {
        list.remove(x);   // âŒ CME
    }
}</code></pre>

<h3>Why This Fails</h3>

<ul>
    <li>Iterator controls traversal</li>
    <li>Collection modified <b>directly</b></li>
    <li><code>modCount</code> changes</li>
    <li>Iterator detects mismatch â†’ <b>CME</b></li>
</ul>

<div class="danger">
CME is thrown to prevent inconsistent iteration state.
</div>

<h2>ğŸ”¹ Why This Is Called Fail-Fast</h2>

<ul>
    <li>Fails immediately</li>
    <li>Detects bugs early</li>
    <li>Prevents corrupted state</li>
</ul>

<div class="note">
<b>CME is a bug-detection mechanism, not thread safety.</b>
</div>

<h2>ğŸ”¹ Correct Ways to Avoid CME âœ…</h2>

<h3>âœ… Option 1: Use Iterator.remove()</h3>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    if (it.next() &lt; 0) {
        it.remove(); // safe
    }
}</code></pre>

<div class="success">
âœ” Updates expectedModCount<br>
âœ” No CME
</div>

<h3>âœ… Option 2: Use removeIf() (Java 8+)</h3>

<pre><code>list.removeIf(x -&gt; x &lt; 0);</code></pre>

<div class="success">
âœ” Internally uses iterator safely<br>
âœ” Clean and preferred
</div>

<h3>âœ… Option 3: Use Concurrent Collections</h3>

<pre><code>CopyOnWriteArrayList&lt;Integer&gt; list =
        new CopyOnWriteArrayList&lt;&gt;();</code></pre>

<div class="success">
âœ” No CME<br>
âœ” Snapshot-based iteration
</div>

<h2>ğŸ”¹ Important Interview Traps</h2>

<div class="danger">
â“ Is CME only for multithreading?<br>
âŒ No â€” happens even in single-threaded code
</div>

<div class="note">
â“ Why doesnâ€™t set() cause CME?<br>
Because it is <b>not a structural modification</b>
</div>

<pre><code>list.set(0, 100); // âœ… No CME</code></pre>

<div class="note">
â“ Does enhanced for-loop always throw CME?<br>
âŒ No â€” only when modified outside the iterator
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œEnhanced for-loop uses an internal fail-fast iterator.  
If the collection is structurally modified directly during iteration, the iterator detects a mismatch in modification count and throws ConcurrentModificationException.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Read-only traversal â†’ enhanced for-loop<br>
âœ” Removal during iteration â†’ Iterator.remove() / removeIf()<br>
âŒ Never modify collection directly inside for-each
</div>

<div class="divider"></div>


<h2 id="13-section">1ï¸âƒ£3ï¸âƒ£ Why is ArrayDeque preferred over Stack?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>
<code>Stack</code> is a legacy, synchronized class with poor performance, whereas
<code>ArrayDeque</code> is modern, faster, and unsynchronized, making it the recommended choice for stack operations in Java.
</b>
</div>

<h2>ğŸ”¹ What Is Wrong with <code>Stack</code>?</h2>

<pre><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code></pre>

<h3>Problems with <code>Stack</code></h3>

<ul>
    <li><b>Legacy class</b> â€“ introduced in Java 1.0</li>
    <li>Extends <code>Vector</code> (also legacy)</li>
    <li><b>Synchronized methods</b> â†’ unnecessary locking</li>
    <li>Poor performance even in single-threaded code</li>
    <li>Bad design â€“ inherits unrelated methods</li>
</ul>

<div class="danger">
âŒ <code>Stack</code> violates clean abstraction and modern performance expectations.
</div>

<h2>ğŸ”¹ Why <code>ArrayDeque</code> Is Better</h2>

<pre><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code></pre>

<h3>Advantages of <code>ArrayDeque</code></h3>

<ul>
    <li>Part of modern <b>Java Collections Framework</b></li>
    <li>No synchronization â†’ <b>faster</b></li>
    <li>Resizable array â†’ better cache locality</li>
    <li>Clean stack abstraction via <code>Deque</code></li>
    <li>Recommended by Oracle documentation</li>
</ul>

<div class="success">
âœ” Modern design<br>
âœ” High performance<br>
âœ” Clean API
</div>

<h2>ğŸ”¹ Stack Operations Comparison</h2>

<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Stack</th>
            <th>ArrayDeque</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Push</td>
            <td><code>push()</code></td>
            <td><code>push()</code></td>
        </tr>
        <tr>
            <td>Pop</td>
            <td><code>pop()</code></td>
            <td><code>pop()</code></td>
        </tr>
        <tr>
            <td>Peek</td>
            <td><code>peek()</code></td>
            <td><code>peek()</code></td>
        </tr>
    </tbody>
</table>

<pre><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
stack.push(10);
stack.push(20);
int top = stack.pop(); // 20</code></pre>

<h2>ğŸ”¹ Performance Comparison</h2>

<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>Stack</th>
            <th>ArrayDeque</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Synchronization</td>
            <td>Yes</td>
            <td>âŒ No</td>
        </tr>
        <tr>
            <td>Speed</td>
            <td>Slow</td>
            <td><b>Fast</b></td>
        </tr>
        <tr>
            <td>Thread-safe</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Recommended</td>
            <td>âŒ No</td>
            <td>âœ… Yes</td>
        </tr>
    </tbody>
</table>

<div class="note">
<b>Interview Tip:</b>  
If thread safety is required, use <code>ConcurrentLinkedDeque</code>.
</div>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âŒ Old Code (Avoid)</h3>

<pre><code>Stack&lt;String&gt; undoStack = new Stack&lt;&gt;();</code></pre>

<h3>âœ… Modern Code (Preferred)</h3>

<pre><code>Deque&lt;String&gt; undoStack = new ArrayDeque&lt;&gt;();</code></pre>

<p>Used in:</p>

<ul>
    <li>Expression evaluation</li>
    <li>Undo / Redo systems</li>
    <li>DFS algorithms</li>
    <li>Parsing logic</li>
</ul>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>

<ul>
    <li>Use <code>Deque</code> interface</li>
    <li>Prefer <code>ArrayDeque</code> for stack & queue</li>
    <li>Use concurrent deque if multithreaded</li>
</ul>

<h3>âŒ Donâ€™ts</h3>

<ul>
    <li>Donâ€™t use <code>Stack</code> in new code</li>
    <li>Donâ€™t rely on implicit synchronization</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œ<code>Stack</code> is a legacy class that extends <code>Vector</code> and synchronizes every method,
leading to poor performance. <code>ArrayDeque</code> is a modern, unsynchronized implementation
that provides faster stack operations and is the recommended replacement.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>Stack is obsolete â†’ Use ArrayDeque</b>
</div>
<div class="divider"></div>


<h2 id="14-section">1ï¸âƒ£4ï¸âƒ£ poll() vs remove()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<ul>
    <li>poll â†’ returns null</li>
    <li>remove â†’ throws exception</li>
</ul>

<div class="divider"></div>


<h2 id="15-section">1ï¸âƒ£5ï¸âƒ£ Why is Vector discouraged?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Global synchronization â†’ poor performance.</p>

<div class="divider"></div>


<h2 id="16-section">1ï¸âƒ£6 Why HashSet internally uses HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Keys ensure uniqueness; values are dummy.</p>

<div class="divider"></div>


<h2 id="17-section">1ï¸âƒ£7ï¸âƒ£ Why HashMap order is not guaranteed?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Depends on hash distribution.</p>

<div class="divider"></div>


<h2 id="18-section">1ï¸âƒ£8ï¸âƒ£ LinkedHashMap vs HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>LinkedHashMap preserves insertion/access order.</p>

<pre><code>new LinkedHashMap&lt;&gt;(16, 0.75f, true);</code></pre>

<div class="divider"></div>


<h2 id="19-section">1ï¸âƒ£9ï¸âƒ£ What is weakly consistent iterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>May reflect some updates but never throws CME.</p>

<div class="divider"></div>


<h2 id="20-section">2ï¸âƒ£0ï¸âƒ£ How does ConcurrentHashMap achieve thread safety?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>CAS + volatile + bucket-level locking.</p>

<div class="divider"></div>

<h2 id="21-section">2ï¸âƒ£1ï¸âƒ£ Why <code>containsKey()</code> + <code>put()</code> is unsafe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p><b>Explanation:</b> Between the check and put, another thread may modify the map â†’ race condition.</p>
<pre><code>map.putIfAbsent(k, v);</code></pre>
<div class="success">âœ” Use atomic operations like <code>putIfAbsent()</code></div>

<div class="divider"></div>


<h2 id="22-section">2ï¸âƒ£2ï¸âƒ£ Comparable vs Comparator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Comparable defines natural order inside the class. Comparator defines custom order externally.</p>

<div class="divider"></div>


<h2 id="23-section">2ï¸âƒ£3ï¸âƒ£ Why sorting a List of Objects may fail?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Objects must implement Comparable or be provided a Comparator.</p>

<div class="divider"></div>


<h2 id="24-section">2ï¸âƒ£4ï¸âƒ£ How does <code>Collections.unmodifiableList()</code> work?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Returns a read-only wrapper; modifications throw UnsupportedOperationException.</p>

<div class="divider"></div>


<h2 id="25-section">2ï¸âƒ£5ï¸âƒ£ Why is <code>size()</code> O(1) in most collections?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Size is stored as an internal counter and updated on modification.</p>

<div class="divider"></div>


<h2 id="26-section">2ï¸âƒ£6ï¸âƒ£ Why LinkedList uses more memory than ArrayList?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Each node stores data + previous + next references.</p>

<div class="divider"></div>


<h2 id="27-section">2ï¸âƒ£7ï¸âƒ£ When to use PriorityQueue?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>When elements must be processed by priority (heap-based).</p>

<div class="divider"></div>


<h2 id="28-section">2ï¸âƒ£8ï¸âƒ£ Queue vs Deque?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Deque supports insertion/removal at both ends.</p>

<div class="divider"></div>


<h2 id="29-section">2ï¸âƒ£9ï¸âƒ£ Why HashMap resize is expensive?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>All entries are rehashed and redistributed.</p>

<div class="divider"></div>


<h2 id="30-section">3ï¸âƒ£0ï¸âƒ£ What is load factor?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Controls resize threshold; default is 0.75.</p>

<div class="divider"></div>


<h2 id="31-section">3ï¸âƒ£1ï¸âƒ£ Why initial capacity matters?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Prevents frequent resizing and rehashing.</p>

<div class="divider"></div>


<h2 id="32-section">3ï¸âƒ£2ï¸âƒ£ Why Collections.sort() is stable?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Uses TimSort, which preserves relative order of equal elements.</p>

<div class="divider"></div>


<h2 id="33-section">3ï¸âƒ£3ï¸âƒ£ Why Stream <code>.collect()</code> may be slower?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Creates intermediate objects and lambdas.</p>

<div class="divider"></div>


<h2 id="34-section">3ï¸âƒ£4ï¸âƒ£ Why <code>Map.keySet()</code> is backed by map?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Changes in map reflect in keySet and vice versa.</p>

<div class="divider"></div>


<h2 id="35-section">3ï¸âƒ£5ï¸âƒ£ entrySet() vs keySet()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>entrySet avoids additional lookup.</p>

<div class="divider"></div>


<h2 id="36-section">3ï¸âƒ£6ï¸âƒ£ Why entrySet() is faster?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Key and value are already available; no get(key) call.</p>

<div class="divider"></div>


<h2 id="37-section">3ï¸âƒ£7ï¸âƒ£ Why subList() can cause issues?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>It is backed by original list; structural changes affect both.</p>

<div class="divider"></div>


<h2 id="38-section">3ï¸âƒ£8ï¸âƒ£ How to safely remove elements while iterating?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Use <code>Iterator.remove()</code>.</p>

<div class="divider"></div>


<h2 id="39-section">3ï¸âƒ£9ï¸âƒ£ Why HashMap is not thread-safe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>No synchronization; concurrent updates corrupt structure.</p>

<div class="divider"></div>


<h2 id="40-section">4ï¸âƒ£0ï¸âƒ£ Why <code>Collections.emptyList()</code> is immutable?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Shared singleton instance to save memory.</p>

<div class="divider"></div>


<h2 id="41-section">4ï¸âƒ£1ï¸âƒ£ When to use WeakHashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Keys should be garbage-collected when no longer referenced.</p>

<div class="divider"></div>


<h2 id="42-section">4ï¸âƒ£2ï¸âƒ£ Why modifying key breaks HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>hashCode changes â†’ lookup goes to wrong bucket.</p>

<div class="divider"></div>


<h2 id="43-section">4ï¸âƒ£3ï¸âƒ£ peek() vs element()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>peek returns null; element throws exception if empty.</p>

<div class="divider"></div>


<h2 id="44-section">4ï¸âƒ£4ï¸âƒ£ Why ConcurrentHashMap iterators donâ€™t throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>They are weakly consistent.</p>

<div class="divider"></div>


<h2 id="45-section">4ï¸âƒ£5ï¸âƒ£ When to use Spliterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Used for parallel stream processing.</p>

<div class="divider"></div>


<h2 id="46-section">4ï¸âƒ£6ï¸âƒ£ Why streams donâ€™t modify source collection?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>They follow functional immutability.</p>

<div class="divider"></div>


<h2 id="47-section">4ï¸âƒ£7ï¸âƒ£ toList() vs collect()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>toList() returns immutable list (Java 16+).</p>

<div class="divider"></div>


<h2 id="48-section">4ï¸âƒ£8ï¸âƒ£ Why TreeSet rejects null?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Needs comparison; null cannot be compared.</p>

<div class="divider"></div>


<h2 id="49-section">4ï¸âƒ£9ï¸âƒ£ When to use ConcurrentSkipListMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Thread-safe sorted map with O(log n) operations.</p>

<div class="divider"></div>


<h2 id="50-section">5ï¸âƒ£0ï¸âƒ£ Biggest Collections Interview Rule</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<div class="note">
<b>Choose collection based on access pattern, not habit.</b>
</div>

<div class="footer">
<h2>ğŸ§  FINAL INTERVIEW CLOSER</h2>
<div class="success">
â€œJava Collections are optimized data structures.  
The real skill lies in choosing the right collection based on lookup frequency, ordering, mutability, concurrency, and memory constraints.â€
</div>
</div>

</div>
<a href="#" class="back-to-top">â†‘</a>
</body>
</html>
