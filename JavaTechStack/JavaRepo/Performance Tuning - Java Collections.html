<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Real-World Performance Tuning â€“ Java Collections</title>
    <style>
        body {
            font-family: "Segoe UI", Roboto, Arial, sans-serif;
            background-color: #f7f8fa;
            color: #1f2937;
            line-height: 1.65;
            margin: 0;
            padding: 30px;
        }

        .container {
            max-width: 1050px;
            margin: auto;
            background: #ffffff;
            padding: 36px 44px;
            border-radius: 14px;
            box-shadow: 0 10px 28px rgba(0,0,0,0.08);
        }

        h1 {
            text-align: center;
            color: #0f172a;
            margin-bottom: 36px;
        }

        h2 {
            margin-top: 42px;
            color: #2563eb;
            border-left: 6px solid #2563eb;
            padding-left: 14px;
        }

        h3 {
            margin-top: 22px;
            color: #111827;
        }

        p {
            margin: 8px 0;
        }

        ul {
            margin: 8px 0 18px 26px;
        }

        li {
            margin-bottom: 6px;
        }

        pre {
            background: #0f172a;
            color: #e5e7eb;
            padding: 18px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 16px 0;
            font-size: 14px;
        }

        code {
            font-family: Consolas, monospace;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 18px;
        }

        table th, table td {
            border: 1px solid #e5e7eb;
            padding: 12px;
            text-align: left;
        }

        table th {
            background-color: #f1f5f9;
            font-weight: 600;
        }

        .note {
            background: #fef3c7;
            border-left: 6px solid #f59e0b;
            padding: 14px 18px;
            margin: 18px 0;
            border-radius: 8px;
        }

        .danger {
            background: #fee2e2;
            border-left: 6px solid #ef4444;
            padding: 14px 18px;
            margin: 18px 0;
            border-radius: 8px;
        }

        .success {
            background: #dcfce7;
            border-left: 6px solid #22c55e;
            padding: 14px 18px;
            margin: 18px 0;
            border-radius: 8px;
        }

        .footer {
            margin-top: 50px;
            padding-top: 24px;
            border-top: 1px solid #e5e7eb;
        }
		
		header {
			padding: 25px 20px;
		}

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            padding: 30px;
        }
        
        .feature-card {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border: 1px solid #eaeaea;
			display: block; /* Changed from default inline for anchor */
            text-decoration: none; /* Remove underline */
        }	
		
       .feature-header {
            background: linear-gradient(to right, #3498db, #2c3e50);
            color: white;
            padding: 15px 20px;
            font-size: 1.4rem;
            font-weight: 600;
            display: block;
            text-decoration: none;
        }

		/* Add hover effect */
        .clickable-header:hover {
            background: linear-gradient(to right, #2980b9, #1a252f);
            cursor: pointer;
        }
        
        /* Active/focus states */
        .clickable-header:active,
        .clickable-header:focus {
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
		
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #e74c3c;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            text-decoration: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .back-to-top:hover {
            transform: translateY(-5px);
            background: #c0392b;
        }	

		/* Back to Top button styling */
        .back-to-top-btn {
            display: inline-block;
            margin: 10px 0 20px;
            padding: 8px 15px;
            background: #f5f5f5;
            color: #2c3e50;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .back-to-top-btn:hover {
            background: #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }				
    </style>
</head>
<body>

<div class="container">


	<header>
		<h1>ğŸš€ Real-World Performance Tuning (Java Collections)</h1>
	</header>
	
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#Choose-section" class="feature-header clickable-header">Choose the RIGHT Collection</a>
		</div>		
		<div class="feature-card">
			<a href="#Kill-section" class="feature-header clickable-header">Kill Hidden O(nÂ²) Loops&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
		</div>
		<div class="feature-card">
			<a href="#Capacity-section" class="feature-header clickable-header">Capacity Planning (Memory + Speed)</a>
		</div>
		<div class="feature-card">
			<a href="#HashMap-section" class="feature-header clickable-header">HashMap Performance (Backend APIs)</a>
		</div>
		<div class="feature-card">
			<a href="#Sorting-section" class="feature-header clickable-header">Avoid Unnecessary Sorting&nbsp;&nbsp;&nbsp;&nbsp;</a>
		</div>
		<div class="feature-card">
			<a href="#Stream-section" class="feature-header clickable-header">Stream API: Powerful but Not Free</a>
		</div>
		<div class="feature-card">
			<a href="#Concurrency-section" class="feature-header clickable-header">Concurrency Tuning (High Traffic)</a>
		</div>
		<div class="feature-card">
			<a href="#Boxing-section" class="feature-header clickable-header">Avoid Boxing & Object Overhead</a>
		</div>
		<div class="feature-card">
			<a href="#Measure-section" class="feature-header clickable-header">Measure, Donâ€™t Guess&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
		</div>
		<div class="feature-card">
			<a href="#Real-World-section" class="feature-header clickable-header">Real-World Performance Checklist</a>
		</div>
		<div class="feature-card">
			<a href="#Final-section" class="feature-header clickable-header">Final Thought&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
		</div>	
	</div>	
<!-- 1 -->
<h2 id="Choose-section">ğŸ”¹ Choose the RIGHT Collection (80% of Performance)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<h3>Basics</h3>
<ul>
    <li>Most performance issues come from choosing the wrong collection</li>
    <li>Using <code>O(n)</code> search where <code>O(1)</code> lookup is required</li>
</ul>

<h3>Rule of Thumb</h3>
<table>
    <tr><th>Requirement</th><th>Use</th></tr>
    <tr><td>Lookup by ID</td><td>HashMap</td></tr>
    <tr><td>Ordered data</td><td>TreeMap</td></tr>
    <tr><td>Frequent iteration</td><td>ArrayList</td></tr>
    <tr><td>Queue / stack</td><td>ArrayDeque</td></tr>
    <tr><td>Priority</td><td>PriorityQueue</td></tr>
</table>

<h3>Advanced â€“ Anti-Pattern</h3>

<!-- Version 1 -->
<h2>ğŸ”¹ Version 1 â€” Using List (Linear Search)</h2>
<div class="danger">
<pre><code>List&lt;User&gt; users;

User findById(String id) {
    for (User u : users) {     // O(n)
        if (u.getId().equals(id)) {
            return u;
        }
    }
    return null;
}</code></pre>
</div>
<h3>â± Time Complexity</h3>
<ul>
    <li>Loop iterates through all users</li>
    <li>Worst case: element is last or not present</li>
</ul>

<div class="danger">
<b>ğŸ‘‰ Complexity: O(n)</b>
</div>

<h3>ğŸ” Whatâ€™s really happening</h3>
<ul>
    <li>Every elementâ€™s ID is compared</li>
    <li>No indexing</li>
    <li>No direct lookup</li>
</ul>

<div class="danger">
<h3>ğŸ“‰ Problems in Real Systems</h3>
<ul>
    <li>Performance degrades as data grows</li>
    <li>High CPU usage</li>
    <li>Poor scalability</li>
</ul>

<b>Real-world pain points:</b>
<ul>
    <li>Login user lookup</li>
    <li>Order lookup by ID</li>
    <li>Authorization checks</li>
    <li>API request validation</li>
</ul>

<p>
1,000 users â†’ acceptable<br>
100,000 users â†’ slow<br>
1,000,000 users â†’ <b>dangerous</b>
</p>
</div>

<!-- Version 2 -->
<h2>ğŸ”¹ Version 2 â€” Using Map (Hash Lookup)</h2>
<div class="success">
<pre><code>Map&lt;String, User&gt; userMap;

User findById(String id) {
    return userMap.get(id);    // O(1)
}</code></pre>
</div>
<h3>â± Time Complexity</h3>
<ul>
    <li>Hash-based lookup</li>
    <li>Direct bucket access</li>
</ul>

<div class="success">
<b>ğŸ‘‰ Complexity: O(1) (average case)</b>
</div>

<h3>ğŸ” Whatâ€™s really happening inside HashMap</h3>
<ol>
    <li><code>id.hashCode()</code> is computed</li>
    <li>Hash maps to a bucket</li>
    <li>Bucket lookup happens</li>
    <li><code>equals()</code> used only on collision</li>
</ol>

<ul>
    <li>âœ” No iteration</li>
    <li>âœ” No full scan</li>
</ul>

<!-- Comparison -->
<h2>ğŸ”¥ Why Map is the CORRECT Choice</h2>

<table>
    <tr>
        <th>Requirement</th>
        <th>List</th>
        <th>Map</th>
    </tr>
    <tr><td>Lookup by ID</td><td>âŒ Slow</td><td>âœ… Fast</td></tr>
    <tr><td>Scalability</td><td>âŒ Poor</td><td>âœ… Excellent</td></tr>
    <tr><td>Read-heavy systems</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Cache / Session store</td><td>âŒ</td><td>âœ…</td></tr>
</table>

<!-- Design Rule -->
<h2>ğŸ§  Real-World Design Rule</h2>

<div class="note">
If you frequently search by <b>key</b> â†’ <b>always use Map</b>
</div>

<ul>
    <li>userId â†’ User</li>
    <li>orderId â†’ Order</li>
    <li>email â†’ Account</li>
    <li>token â†’ Session</li>
</ul>

<!-- Interview Caveats -->
<h2>âš ï¸ Important Interview Caveats</h2>

<h3>â“ Is HashMap.get() always O(1)?</h3>
<div class="danger">
<ul>
    <li>âŒ No</li>
    <li>Poor hashCode or too many collisions</li>
    <li>Before Java 8 â†’ O(n)</li>
    <li>Java 8+ â†’ collision chains become trees â†’ O(log n)</li>
</ul>
</div>

<h3>â“ When is List still acceptable?</h3>
<ul>
    <li>Small datasets</li>
    <li>One-time processing</li>
    <li>Ordered traversal</li>
    <li>Sequential logic</li>
</ul>

<pre><code>processAllUsers(users);</code></pre>

<!-- Hybrid Pattern -->
<h2>ğŸ”„ Hybrid Real-World Pattern (BEST PRACTICE)</h2>

<pre><code>List&lt;User&gt; users;          // ordering / iteration
Map&lt;String, User&gt; userMap; // fast lookup</code></pre>

<pre><code>for (User u : users) {
    userMap.put(u.getId(), u);
}</code></pre>

<div class="note">
Used heavily in Spring Boot services, in-memory caches, and microservices.
</div>

<!-- Interview Answer -->
<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
<b>Why is Map faster than List for lookup?</b><br><br>
A List requires linear traversal (O(n)), whereas a HashMap uses hashing for direct access (O(1) on average). Hence, Map is the correct choice for frequent key-based lookups.
</div>

<!-- Summary -->
<h2>ğŸ§  Final Summary</h2>

<table>
    <tr><th>Code</th><th>Complexity</th></tr>
    <tr><td>List search</td><td>âŒ O(n)</td></tr>
    <tr><td>Map lookup</td><td>âœ… O(1) avg</td></tr>
    <tr><td>Map worst case</td><td>O(log n) (Java 8+)</td></tr>
</table>

<div class="note">
<b>Impact:</b>
<ul>
    <li>Lower latency</li>
    <li>Reduced CPU usage</li>
    <li>Linear scalability</li>
</ul>
</div>

<!-- 2 -->
<h2 id="Kill-section">ğŸ”¹ Kill Hidden O(nÂ²) Loops (MOST IMPORTANT)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<h3>Basics</h3>
<p>Nested loops or repeated list access silently destroy performance.</p>

<div class="danger">
<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);   // LinkedList â†’ O(n)
}</code></pre>
<p><b>Total Complexity:</b> O(nÂ²)</p>
</div>

<div class="success">
<pre><code>for (Integer val : list) {
    // O(n)
}</code></pre>
</div>

<!-- Case 1 -->
<h2>âŒ Case 1: Index-based loop on LinkedList</h2>
<div class="danger">
<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);   // LinkedList â†’ O(n)
}</code></pre>
</div>

<h3>ğŸ” What happens internally</h3>
<ul>
    <li><b>LinkedList</b> is a doubly linked list</li>
    <li>No direct index access</li>
    <li><code>get(i)</code> traverses node-by-node from head or tail</li>
</ul>

<div class="danger">
â± <b>Cost of get(i): O(n)</b> (worst case)
</div>

<h3>â± Total Time Complexity</h3>

<table>
    <tr>
        <th>Operation</th>
        <th>Complexity</th>
    </tr>
    <tr>
        <td>Loop runs</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>get(i) each time</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td><b>Total</b></td>
        <td><b>âŒ O(nÂ²)</b></td>
    </tr>
</table>

<div class="danger">
<b>Why this is bad</b>
<ul>
    <li>Performance degrades rapidly as list grows</li>
    <li>Very common real-world performance bug</li>
</ul>
</div>

<!-- Case 2 -->
<h2>âœ… Case 2: Enhanced for-loop (Iterator-based)</h2>
<div class="success">
<pre><code>for (Integer val : list) {
    // O(1) per step
}</code></pre>
</div>
<h3>ğŸ” What happens internally</h3>
<ul>
    <li>Uses an <b>Iterator</b></li>
    <li>Maintains pointer to current node</li>
    <li>Moves to <code>next()</code> in constant time</li>
</ul>

<div class="success">
â± <b>Cost per iteration: O(1)</b>
</div>

<h3>â± Total Time Complexity</h3>

<table>
    <tr>
        <th>Operation</th>
        <th>Complexity</th>
    </tr>
    <tr>
        <td>Loop runs</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Iterator traversal</td>
        <td>O(1) per step</td>
    </tr>
    <tr>
        <td><b>Total</b></td>
        <td><b>âœ… O(n)</b></td>
    </tr>
</table>

<!-- Key Difference -->
<h2>ğŸ”¥ Key Difference (Core Insight)</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>Index Loop</th>
        <th>Enhanced for-loop</th>
    </tr>
    <tr>
        <td>Access method</td>
        <td>get(i)</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Per access cost</td>
        <td>O(n)</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>Total complexity</td>
        <td>âŒ O(nÂ²)</td>
        <td>âœ… O(n)</td>
    </tr>
    <tr>
        <td>LinkedList-safe</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<!-- Golden Rule -->
<h2>ğŸ§  Interview Golden Rule</h2>

<div class="note">
ğŸ”¥ <b>Never iterate a LinkedList using index-based access</b>
</div>

<ul>
    <li>âœ” Use enhanced for-loop</li>
    <li>âœ” Use Iterator</li>
    <li>âœ” Use ListIterator for bidirectional traversal</li>
</ul>

<!-- Interview Answer -->
<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œIn a LinkedList, index-based access using <code>get(i)</code> is O(n) because the list must be traversed from the head or tail each time. When used inside a loop, this results in O(nÂ²) complexity. Using an enhanced for-loop internally uses an iterator, which traverses the list in O(n) total time.â€
</div>

<!-- Bonus -->
<h2>ğŸ“Œ Bonus Tip: ArrayList vs LinkedList</h2>

<table>
    <tr>
        <th>List Type</th>
        <th>Index Loop</th>
        <th>Enhanced for</th>
    </tr>
    <tr>
        <td>ArrayList</td>
        <td>O(n)</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>LinkedList</td>
        <td>âŒ O(nÂ²)</td>
        <td>âœ… O(n)</td>
    </tr>
</table>

<div class="footer">
<p><b>Key takeaway:</b> The same loop syntax can have drastically different performance depending on the data structure.</p>
</div>

<div class="note">
<b>Advanced Tip:</b>
<ul>
    <li>Never use index access on LinkedList</li>
    <li>Always use iterators or enhanced for-loops</li>
</ul>
</div>

<!-- 3 -->
<h2 id="Capacity-section">ğŸ”¹ Capacity Planning (Memory + Speed)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<h3>Basics</h3>
<ul>
    <li>Default capacity causes resizing</li>
    <li>Triggers array copying and GC pressure</li>
</ul>

<div class="danger">
<pre><code>List&lt;Order&gt; orders = new ArrayList&lt;&gt;();</code></pre>
</div>

<div class="success">
<pre><code>List&lt;Order&gt; orders = new ArrayList&lt;&gt;(10_000);</code></pre>
</div>

<div class="note">
<b>Advanced:</b>
<ul>
    <li>Reallocation is O(n)</li>
    <li>Causes GC pauses in high-throughput systems</li>
    <li>Common in batch jobs, ETL, Kafka consumers</li>
</ul>
</div>

<!-- 4 -->
<h2 id="HashMap-section">ğŸ”¹ HashMap Performance (Critical in Backend APIs)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<h3>Basics</h3>
<p>HashMap performance depends on <code>hashCode()</code> and <code>equals()</code>.</p>

<div class="danger">
<pre><code>class Order {
    String id;
    // no hashCode / equals
}</code></pre>
<p>Results in duplicates, O(n) lookup, memory leaks.</p>
</div>

<div class="success">
<pre><code>@Override
public int hashCode() {
    return Objects.hash(id);
}

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Order)) return false;
    return id.equals(((Order)o).id);
}</code></pre>
</div>

<div class="note">
Java 8+ converts heavy collision buckets into trees, but correct hashing is still faster.
</div>

<!-- 5 -->
<h2 id="Sorting-section">ğŸ”¹ Avoid Unnecessary Sorting</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<div class="danger">
<pre><code>Collections.sort(list);
return list.get(0);</code></pre>
</div>

<div class="success">
<pre><code>Collections.min(list);   // O(n)</code></pre>
</div>

    <h2>âœ… Correct Conclusion</h2>

    <div class="success">
        <strong>Collections.min(list)</strong> is better and more efficient
        when you only need the minimum value.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Why <code>Collections.sort()</code> is Inefficient</h2>

    <h3>What actually happens</h3>

    <pre>
Collections.sort(list);
    </pre>

    <ul>
        <li>Sorts the <strong>entire list</strong></li>
        <li>Uses <strong>TimSort</strong></li>
        <li>Time complexity: <strong>O(n log n)</strong></li>
    </ul>

    <pre>
list.get(0);
    </pre>

    <p>
        You sorted <strong>all elements</strong> just to get
        <strong>one value</strong>.
    </p>

    <div class="danger">
        âŒ Unnecessary work and poor performance choice.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Why <code>Collections.min()</code> is Optimal</h2>

    <pre>
Collections.min(list);
    </pre>

    <h3>What it does internally</h3>

    <ul>
        <li>Traverses the list <strong>once</strong></li>
        <li>Keeps track of the smallest element</li>
    </ul>

    <h3>Time Complexity</h3>

    <pre>
O(n)
    </pre>

    <h3>Equivalent Logic</h3>

    <pre>
T min = list.get(0);
for (T e : list) {
    if (e.compareTo(min) < 0) {
        min = e;
    }
}
return min;
    </pre>

    <div class="divider"></div>

    <h2>ğŸ“Š Performance Comparison</h2>

    <table>
        <tr>
            <th>Approach</th>
            <th>Time Complexity</th>
            <th>Extra Work</th>
        </tr>
        <tr>
            <td>Collections.sort() + get(0)</td>
            <td>O(n log n)</td>
            <td>Full sort</td>
        </tr>
        <tr>
            <td>Collections.min()</td>
            <td>O(n)</td>
            <td>Single traversal</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>ğŸ§  Interview-Ready Explanation</h2>

    <div class="note">
        Sorting the list just to find the minimum element is inefficient
        because sorting costs O(n log n).
        <code>Collections.min()</code> performs a linear scan in O(n),
        making it the optimal choice.
    </div>

    <div class="divider"></div>

    <h2>âš ï¸ Important Edge Case</h2>

    <p>Both methods throw:</p>

    <pre>
NoSuchElementException
    </pre>

    <p>if the list is empty.</p>

    <h3>Safe Version</h3>

    <pre>
if (list.isEmpty()) {
    throw new IllegalArgumentException("List is empty");
}
return Collections.min(list);
    </pre>

    <div class="divider"></div>

    <h2>ğŸ¯ When Should You Sort?</h2>

    <div class="success">
        âœ” When you need ordered data<br>
        âœ” When you need top-k elements repeatedly
    </div>

    <div class="danger">
        âŒ When you only need min or max once
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¥ Bonus Interview Tip</h2>

    <p>If you need both <strong>min and max</strong>:</p>

    <pre>
Collections.min(list);
Collections.max(list);
    </pre>
    <h2>â“ Case: <code>list.get(2)</code></h2>

    <h3>Code in Question</h3>

    <pre>
Collections.sort(list);
return list.get(2);
    </pre>

    <h3>What does this actually mean?</h3>

    <div class="note">
        <code>list.get(2)</code> returns the
        <strong>3rd smallest element</strong>
        (0-based indexing).
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Can We Use <code>Collections.min()</code>?</h2>

    <div class="danger">
        âŒ No â€” <code>Collections.min()</code> returns only
        the smallest element, not the 3rd smallest.
    </div>

    <div class="divider"></div>

    <h2>âœ… Correct Approaches (Interview-Grade)</h2>

    <h3>ğŸ”¹ Sorting (Simple but Costly)</h3>

    <pre>
Collections.sort(list);
return list.get(2);
    </pre>

    <ul>
        <li>Time Complexity: <strong>O(n log n)</strong></li>
        <li>Modifies original list</li>
        <li>Acceptable for small lists</li>
    </ul>

    <div class="divider"></div>

    <h3>ğŸ”¹ Using <code>PriorityQueue</code> (BEST for Large Lists)</h3>

    <pre>
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(list);

pq.poll(); // smallest
pq.poll(); // 2nd smallest
return pq.poll(); // 3rd smallest
    </pre>

    <ul>
        <li>Time: <strong>O(n + k log n)</strong> (k = 3)</li>
        <li>Does NOT modify original list</li>
        <li>Scales well for large datasets</li>
    </ul>

    <div class="divider"></div>

    <div class="divider"></div>

    <h3>âŒ Streams (Readable, Not Optimal)</h3>

    <pre>
return list.stream()
           .sorted()
           .skip(2)
           .findFirst()
           .orElseThrow();
    </pre>

    <div class="danger">
        âŒ Time Complexity: O(n log n)<br>
        âŒ Internally sorts entire stream
    </div>

    <div class="divider"></div>

    <h2>ğŸ“Š Comparison Summary</h2>

    <table>
        <tr>
            <th>Approach</th>
            <th>Time</th>
            <th>Space</th>
            <th>Modifies List</th>
            <th>Best When</th>
        </tr>
        <tr>
            <td>Sort + get(2)</td>
            <td>O(n log n)</td>
            <td>O(1)</td>
            <td>âœ… Yes</td>
            <td>Small list</td>
        </tr>
        <tr>
            <td>PriorityQueue</td>
            <td>O(n + k log n)</td>
            <td>O(n)</td>
            <td>âŒ No</td>
            <td>Large list</td>
        </tr>
        <tr>
            <td>Single-pass</td>
            <td>O(n)</td>
            <td>O(1)</td>
            <td>âŒ No</td>
            <td>Fixed k</td>
        </tr>
        <tr>
            <td>Streams</td>
            <td>O(n log n)</td>
            <td>O(n)</td>
            <td>âŒ No</td>
            <td>Readability</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>ğŸ¯ Interview One-Liner</h2>

    <div class="note">
        To get the 3rd smallest element, sorting works but is inefficient;
        a single-pass or priority queue approach is more optimal depending
        on constraints.
    </div>
<!-- 6 -->
<h2 id="Stream-section">ğŸ”¹ Stream API: Powerful but Not Free</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<div class="danger">
<pre><code>list.stream()
    .filter(x -> x.isActive())
    .map(User::getId)
    .collect(Collectors.toList());</code></pre>
</div>

<div class="success">
<pre><code>List&lt;String&gt; ids = new ArrayList&lt;&gt;();
for (User u : list) {
    if (u.isActive()) {
        ids.add(u.getId());
    }
}</code></pre>
</div>

<div class="note">
<ul>
    <li>Streams improve readability</li>
    <li>Loops are faster in hot paths</li>
    <li>parallelStream helps only for CPU-heavy work</li>
</ul>
</div>

<!-- 7 -->
<h2 id="Concurrency-section">ğŸ”¹ Concurrency Tuning (High Traffic)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<div class="danger">
<pre><code>Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>
</div>

<div class="success">
<pre><code>ConcurrentHashMap&lt;K, V&gt;</code></pre>
</div>

<div class="note">
<ul>
    <li>Lock striping</li>
    <li>Non-blocking reads</li>
    <li>Used in auth tokens, caches, rate limiters</li>
</ul>
</div>

<!-- 8 -->
<h2 id="Boxing-section">ğŸ”¹ Avoid Boxing & Object Overhead</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>
<div class="danger">
<pre><code>List&lt;Integer&gt; list;   // Boxing</code></pre>
</div>
<div class="success">
<pre><code>int[] arr;</code></pre>
</div>

<div class="note">
Critical in finance, trading, real-time analytics.
</div>

<!-- 9 -->
<h2 id="Measure-section">ğŸ”¹ Measure, Donâ€™t Guess</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>

<ul>
    <li>JMH</li>
    <li>Java Flight Recorder</li>
    <li>VisualVM</li>
    <li>GC Logs</li>
</ul>

<div class="note">
<b>Golden Rule:</b> Optimize only after finding bottlenecks.
</div>

<!-- Checklist -->
<h2 id="Real-World-section">ğŸ”¥ Real-World Performance Checklist</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>
<ul>
    <li>âœ” Use Map for lookups</li>
    <li>âœ” Avoid list search in loops</li>
    <li>âœ” Pre-size collections</li>
    <li>âœ” Proper hashCode()</li>
    <li>âœ” Avoid unnecessary sorting</li>
    <li>âœ” Prefer ArrayDeque over Stack</li>
    <li>âœ” Streams â‰  always faster</li>
    <li>âœ” Measure before tuning</li>
</ul>

<div class="footer">
<h2 id="Final-section">ğŸ§  Final Thought</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>
<p><b>Big-O decides scalability, but implementation decides speed.</b></p>
</div>

</div>
<a href="#" class="back-to-top">â†‘</a>
</body>
</html>
