<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java Collections â€“ Top 50 Interview Why Questions</title>
    <style>
        body {
            font-family: "Segoe UI", Roboto, Arial, sans-serif;
            background: #f7f8fa;
            color: #1f2937;
            line-height: 1.65;
            margin: 0;
            padding: 32px;
        }

        .container {
            max-width: 1100px;
            margin: auto;
            background: #ffffff;
            padding: 40px 48px;
            border-radius: 16px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.08);
        }

        h1 {
            text-align: center;
            margin-bottom: 42px;
            color: #0f172a;
        }

        h2 {
            margin-top: 46px;
            color: #2563eb;
            border-left: 6px solid #2563eb;
            padding-left: 14px;
        }

        h3 {
            margin-top: 22px;
            color: #111827;
        }

        p {
            margin: 8px 0;
        }

        ul {
            margin: 10px 0 20px 28px;
        }

        li {
            margin-bottom: 6px;
        }
		table {
			border-collapse: collapse;
			width: 100%;
			margin-top: 14px;
			background: #ffffff;
		}
		th, td {
			border: 1px solid #e5e7eb;
			padding: 10px;
			text-align: left;
		}
		th {
			background: #f1f5f9;
		}
        pre {
            background: #0f172a;
            color: #e5e7eb;
            padding: 18px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 18px 0;
            font-size: 14px;
        }

        code {
            font-family: Consolas, monospace;
        }

        .note {
            background: #fef3c7;
            border-left: 6px solid #f59e0b;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .success {
            background: #dcfce7;
            border-left: 6px solid #22c55e;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .danger {
            background: #fee2e2;
            border-left: 6px solid #ef4444;
            padding: 16px 18px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .divider {
            margin: 40px 0;
            border-top: 1px dashed #e5e7eb;
        }

        .footer {
            margin-top: 56px;
            padding-top: 28px;
            border-top: 1px solid #e5e7eb;
        }
		
		header {
			padding: 25px 20px;
		}

		/* =========================
		   FEATURE CARDS
		   ========================= */
		.features-grid {
		  display: grid;
		  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
		  gap: 5px;
		  justify-content: center;
		  padding: 5px;
		}

		.feature-card {
		  background: white;
		  border-radius: 10px;
		  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
		  border: 1px solid #eaeaea;
		  transition: all 0.3s ease;
		}

		.feature-header {
		  display: block;
		  background: linear-gradient(to right, #3498db, #2c3e50);
		  color: white;
		  padding: 2px 2px;
		  font-size: 0.8rem;
		  font-weight: 600;
		  text-decoration: none;
		  border-radius: 10px;
		  text-align: center;
		}

		.feature-header:hover {
		  background: linear-gradient(to right, #2980b9, #1a252f);
		}
		
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #e74c3c;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            text-decoration: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .back-to-top:hover {
            transform: translateY(-5px);
            background: #c0392b;
        }	

		/* Back to Top button styling */
        .back-to-top-btn {
            display: inline-block;
            margin: 10px 0 20px;
            padding: 8px 15px;
            background: #f5f5f5;
            color: #2c3e50;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .back-to-top-btn:hover {
            background: #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }	

		blockquote {
			background: #eef2ff;
			border-left: 5px solid #6366f1;
			padding: 12px 16px;
			margin: 14px 0;
			font-style: italic;
		}

		.ok {
			color: #059669;
			font-weight: 600;
		}
		.warn {
			color: #d97706;
			font-weight: 600;
		}
    .bad {
        color: #dc2626;
        font-weight: 600;
    }		
    .good {
        color: #059669;
        font-weight: 600;
    }	
    </style>
</head>
<body>

<div class="container">

	<h1>â˜• Java Collections â€” Top 50 â€œWHYâ€ Interview Questions</h1>
	<h4>Map Interface (HashMap, TreeMap, etc.)</h4>
	<div class="features-grid" id="features-overview">	
		<div class="feature-card">
			<a href="#18-section" class="feature-header">LinkedHashMap vs HashMap?</a>
		</div>				
		<div class="feature-card">
			<a href="#17-section" class="feature-header">Why HashMap order is not guaranteed?</a>
		</div>	
		<div class="feature-card">
			<a href="#39-section" class="feature-header">Why HashMap is not thread-safe?</a>
		</div>	
		<div class="feature-card">
			<a href="#41-section" class="feature-header">When to use WeakHashMap?</a>
		</div>			
		<div class="feature-card">
			<a href="#42-section" class="feature-header">Why modifying key breaks HashMap?</a>
		</div>		
		<div class="feature-card">
			<a href="#35-section" class="feature-header">entrySet() vs keySet()??</a>
		</div>		
		<div class="feature-card">
			<a href="#36-section" class="feature-header">Why entrySet() is faster?</a>
		</div>			
		<div class="feature-card">
			<a href="#29-section" class="feature-header">Why HashMap resize is expensive?</a>
		</div>		
		<div class="feature-card">
			<a href="#21-section" class="feature-header">Why containsKey() + put() is unsafe?</a>
		</div>
		<div class="feature-card">
			<a href="#2-section" class="feature-header">HashMap.get() O(1) but worst-case O(log n)?</a>
		</div>		
		<div class="feature-card">
			<a href="#9-section" class="feature-header">Why is TreeMap slower than HashMap?</a>
		</div>			
		<div class="feature-card">
			<a href="#16-section" class="feature-header">Why HashSet internally uses HashMap?</a>
		</div>		
		<div class="feature-card">
			<a href="#34-section" class="feature-header">Why Map.keySet() is backed by map?</a>
		</div>		
		<div class="feature-card">
			<a href="#10-section" class="feature-header">When to use EnumMap?</a>
		</div>				
		<div class="feature-card">
			<a href="#30-section" class="feature-header">What is load factor?</a>
		</div>						
	</div>
	<h4>List Interface (ArrayList, LinkedList)</h4>
	<div class="features-grid" id="features-overview">

		<div class="feature-card">
			<a href="#1-section" class="feature-header">LnkdLst indx access O(n) but iter trav O(1)?</a>
		</div>	
		<div class="feature-card">
			<a href="#26-section" class="feature-header">LnkdLst uses more memory than ArrayList?</a>
		</div>	
		<div class="feature-card">
			<a href="#37-section" class="feature-header">Why subList() can cause issues?</a>
		</div>		
		<div class="feature-card">
			<a href="#15-section" class="feature-header">Why is Vector discouraged?</a>
		</div>
	</div>
	<h4>Queue & Deque Interfaces</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#28-section" class="feature-header">Queue vs Deque?</a>
		</div>
		<div class="feature-card">
			<a href="#13-section" class="feature-header">Why is ArrayDeque preferred over Stack?</a>
		</div>	
		<div class="feature-card">
			<a href="#27-section" class="feature-header">When to use PriorityQueue?</a>
		</div>		
		<div class="feature-card">
			<a href="#14-section" class="feature-header">poll() vs remove()?</a>
		</div>		
		<div class="feature-card">
			<a href="#43-section" class="feature-header">peek() vs element()?</a>
		</div>	
	</div>
	<h4>Set Interface</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#51-section" class="feature-header">What is Set?</a>
		</div>	
		<div class="feature-card">
			<a href="#52-section" class="feature-header">What is HashSet?</a>
		</div>	
		<div class="feature-card">
			<a href="#53-section" class="feature-header">What is LinkedHashSet?</a>
		</div>	
		<div class="feature-card">
			<a href="#54-section" class="feature-header">What is SortedSet?</a>
		</div>	
		<div class="feature-card">
			<a href="#55-section" class="feature-header">What is NavigableSet?</a>
		</div>	
		<div class="feature-card">
			<a href="#56-section" class="feature-header">Overview?</a>
		</div>			
		<div class="feature-card">
			<a href="#48-section" class="feature-header">Why TreeSet rejects null?</a>
		</div>	
	</div>
	<h4>Concurrent & Thread-Safe Collections</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#58-section" class="feature-header">ConcurrentHashMap</a>
		</div>	
		<div class="feature-card">
			<a href="#57-section" class="feature-header">ConcurrentModificationException</a>
		</div>	
		<div class="feature-card">
			<a href="#20-section" class="feature-header">Conc.HashMap achieve thread safety?</a>
		</div>
		<div class="feature-card">
			<a href="#3-section" class="feature-header">Conc.HashMap not allow null keys or values?</a>
		</div>
		<div class="feature-card">
			<a href="#5-section" class="feature-header">CopyOnWriteArrayList perf poor on writes?</a>
		</div>	
		<div class="feature-card">
			<a href="#4-section" class="feature-header">synchronizedMap and ConcurrentHashMap</a>
		</div>	
		<div class="feature-card">
			<a href="#44-section" class="feature-header">Conc.HashMap iterators donâ€™t throw CME?</a>
		</div>			
		<div class="feature-card">
			<a href="#49-section" class="feature-header">When to use ConcurrentSkipListMap?</a>
		</div>		
	</div>
	<h4>Iterators & Traversal</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#11-section" class="feature-header">Iterator vs ListIterator?</a>
		</div>		
		<div class="feature-card">
			<a href="#6-section" class="feature-header">Fail-Fast vs Fail-Safe</a>
		</div>
		<div class="feature-card">
			<a href="#19-section" class="feature-header">What is weakly consistent iterator?</a>
		</div>
		<div class="feature-card">
			<a href="#38-section" class="feature-header">How to safely rem elmnts while iterating?</a>
		</div>	
		<div class="feature-card">
			<a href="#12-section" class="feature-header">Why does enhanced for-loop throw CME?</a>
		</div>	
		<div class="feature-card">
			<a href="#7-section" class="feature-header">Why does removeIf() not throw CME?</a>
		</div>
		<div class="feature-card">
			<a href="#45-section" class="feature-header">When to use Spliterator?</a>
		</div>	
	</div>
	<h4>Java Streams & Functional Programming</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#46-section" class="feature-header">Why streams donâ€™t modify source collection?</a>
		</div>
		<div class="feature-card">
			<a href="#33-section" class="feature-header">Why Stream .collect() may be slower?</a>
		</div>		
		<div class="feature-card">
			<a href="#47-section" class="feature-header">toList() vs collect()?</a>
		</div>		
	</div>
	<h4>General Concepts & Utility Classes</h4>
	<div class="features-grid" id="features-overview">
		<div class="feature-card">
			<a href="#22-section" class="feature-header">Comparable vs Comparator?</a>
		</div>
		<div class="feature-card">
			<a href="#8-section" class="feature-header">Why override equals() and hashCode()?</a>
		</div>
		<div class="feature-card">
			<a href="#32-section" class="feature-header">Why Collections.sort() is stable?</a>
		</div>
		<div class="feature-card">
			<a href="#24-section" class="feature-header">How Collections.unmodifiableList() work?</a>
		</div>	
		<div class="feature-card">
			<a href="#40-section" class="feature-header">Why Collections.emptyList() is immutable?</a>
		</div>
		<div class="feature-card">
			<a href="#25-section" class="feature-header">Why is size() O(1) in most collections?</a>
		</div>
		<div class="feature-card">
			<a href="#31-section" class="feature-header">Why initial capacity matters?</a>
		</div>	
		<div class="feature-card">
			<a href="#23-section" class="feature-header">Why sorting a List of Objects may fail?</a>
		</div>
		<div class="feature-card">
			<a href="#21-section" class="feature-header">Why containsKey() + put() is unsafe?</a>
		</div>		
		<div class="feature-card">
			<a href="#50-section" class="feature-header">Biggest Collections Interview Rule</a>
		</div>			
	</div>	

<h2 id="1-section">1ï¸âƒ£ Why is LinkedList index access O(n) but iterator traversal O(1)?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h3>ğŸ”¹ Why LinkedList Index Access is O(n)</h3>

<h3>How LinkedList is Implemented</h3>
<ul>
    <li>LinkedList is a <b>doubly linked list</b></li>
    <li>Each element is stored as a <b>node</b></li>
    <li>Each node contains:
        <ul>
            <li><code>prev</code></li>
            <li><code>next</code></li>
            <li><code>value</code></li>
        </ul>
    </li>
</ul>

<div class="note">
There is <b>NO array</b> and <b>NO direct index access</b>.
</div>

<h3>What Happens in <code>list.get(i)</code></h3>

<pre><code>list.get(i);</code></pre>

<p><b>Internally:</b></p>
<ol>
    <li>Traversal starts from <b>head</b> (or tail if index &gt; size/2)</li>
    <li>Moves <b>node by node</b></li>
    <li>Stops when index <code>i</code> is reached</li>
</ol>

<div class="danger">
â± <b>Time complexity of one get(i): O(n)</b> (worst case)
</div>

<h3>ğŸ”¹ Why This Loop Becomes O(nÂ²)</h3>

<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);   // O(n)
}</code></pre>

<h3>Breakdown</h3>
<ul>
    <li>Loop runs <b>n</b> times</li>
    <li>Each <code>get(i)</code> costs <b>O(n)</b></li>
</ul>

<div class="danger">
ğŸ‘‰ <b>Total Complexity = O(n Ã— n) = O(nÂ²)</b><br>
ğŸ“Œ This is a <b>very common real-world performance bug</b>.
</div>

<h3>ğŸ”¹ Why Iterator Traversal is O(1) per Step</h3>

<pre><code>for (Integer i : list) {
}</code></pre>

<h3>What Really Happens</h3>
<ul>
    <li>Enhanced for-loop uses an <b>Iterator</b></li>
    <li>Iterator keeps a reference to the <b>current node</b></li>
    <li><code>next()</code> simply moves to <code>current.next</code></li>
</ul>

<pre><code>node = node.next;   // constant time</code></pre>

<div class="success">
â± Cost per step = <b>O(1)</b><br>
â± Total traversal = <b>O(n)</b>
</div>

<h3>ğŸ”¹ Visual Difference</h3>

<h3>Index Access</h3>
<pre><code>HEAD â†’ node1 â†’ node2 â†’ node3 â†’ ... â†’ node(i)
(restart traversal every time)</code></pre>

<h3>Iterator Traversal</h3>
<pre><code>HEAD â†’ node1 â†’ node2 â†’ node3 â†’ ...
(single continuous traversal)</code></pre>

<h3>ğŸ”¹ Final Complexity Comparison</h3>

<table>
    <tr>
        <th>Code</th>
        <th>Time Complexity</th>
    </tr>
    <tr>
        <td>Index-based loop on LinkedList</td>
        <td>âŒ O(nÂ²)</td>
    </tr>
    <tr>
        <td>Iterator / for-each on LinkedList</td>
        <td>âœ… O(n)</td>
    </tr>
    <tr>
        <td>Index-based loop on ArrayList</td>
        <td>âœ… O(n)</td>
    </tr>
</table>

<h3>ğŸ¯ Perfect Interview Answer</h3>

<div class="success">
â€œLinkedList does not support direct index access.  
Each call to <code>get(i)</code> requires traversal from the head or tail, which is O(n).  
When used inside a loop, this results in O(nÂ²).  
Iterator traversal maintains a pointer to the current node and moves sequentially, making each step O(1) and the overall traversal O(n).â€
</div>

<h3>ğŸ§  Golden Rule</h3>

<div class="note">
ğŸ”¥ <b>Never use index-based loops with LinkedList.  
Always use iterators or enhanced for-loops.</b>
</div>
<div class="divider"></div>
<h2 id="2-section">2ï¸âƒ£ Why is HashMap.get() O(1) but worst-case O(log n)?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	

<p>Average lookup uses hashing. In Java 8+, collision chains convert to Red-Black Trees.</p>

<h3>ğŸ”¹ Why HashMap.get() is O(1) on Average</h3>

<pre><code>map.get(key);</code></pre>

<h3>What happens internally (Average Case)</h3>
<ol>
    <li><code>key.hashCode()</code> is computed</li>
    <li>Hash is transformed into a bucket index</li>
    <li>Java jumps directly to that bucket</li>
    <li>Key is found immediately (no collision)</li>
</ol>

<div class="success">
ğŸ“Œ Direct bucket access â†’ <b>Constant Time</b><br>
â± <b>Average Complexity = O(1)</b>
</div>

<h3>Why Hashing Gives O(1)</h3>
<ul>
    <li>Buckets accessed by index</li>
    <li>No full map scan</li>
    <li>Works best with:
        <ul>
            <li>Good <code>hashCode()</code></li>
            <li>Low collisions</li>
            <li>Proper capacity & load factor</li>
        </ul>
    </li>
</ul>

<h3>ğŸ”¹ Why Collisions Happen</h3>

<p>
Different keys can map to the same bucket:
</p>

<pre><code>Bucket 5:
   keyA â†’ valueA
   keyB â†’ valueB</code></pre>

<p>
Now Java must compare keys using <code>equals()</code>.
</p>

<h3>ğŸ”¹ Preâ€“Java 8 (Worst Case = O(n))</h3>

<ul>
    <li>Buckets used <b>LinkedList</b></li>
    <li>Heavy collisions â†’ linear search</li>
</ul>

<pre><code>Bucket â†’ LinkedList â†’ scan all nodes</code></pre>

<div class="danger">
â± Worst-case complexity (Java 7 and earlier) = <b>O(n)</b>
</div>

<h3>ğŸ”¹ Java 8+ Optimization â€” Treeification â­</h3>

<h3>What Changed in Java 8</h3>
<ul>
    <li>If bucket size exceeds <b>8</b></li>
    <li>AND map size â‰¥ <b>64</b></li>
    <li>Bucket converts from LinkedList â†’ <b>Red-Black Tree</b></li>
</ul>

<pre><code>Bucket â†’ Red-Black Tree</code></pre>

<h3>ğŸ”¹ Why Red-Black Tree?</h3>

<table>
    <tr>
        <th>Structure</th>
        <th>Lookup Complexity</th>
    </tr>
    <tr>
        <td>LinkedList</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Red-Black Tree</td>
        <td><b>O(log n)</b></td>
    </tr>
</table>

<div class="success">
ğŸ“Œ Even under heavy collisions:<br>
â± <b>Worst-case complexity = O(log n)</b>
</div>

<h3>ğŸ”¹ When Does Treeification Happen?</h3>

<ul>
    <li>Bucket size â‰¥ 8</li>
    <li>Map size â‰¥ 64</li>
    <li>Keys are Comparable or tie-break ordering applies</li>
</ul>

<p>
Otherwise, HashMap resizes instead of treeifying.
</p>

<h3>ğŸ”¹ Complexity Summary</h3>

<table>
    <tr>
        <th>Scenario</th>
        <th>Complexity</th>
    </tr>
    <tr>
        <td>Average case</td>
        <td><b>O(1)</b></td>
    </tr>
    <tr>
        <td>Worst case (Java 7)</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Worst case (Java 8+)</td>
        <td><b>O(log n)</b></td>
    </tr>
</table>

<h3>ğŸ”¹ Real-World Justification</h3>

<ul>
    <li>Protects against hash collision attacks</li>
    <li>Prevents severe performance degradation</li>
    <li>Makes HashMap safer for:
        <ul>
            <li>Web applications</li>
            <li>Microservices</li>
            <li>Caching</li>
            <li>User-provided keys</li>
        </ul>
    </li>
</ul>

<h3>ğŸ”¹ Common Interview Traps</h3>

<div class="danger">
â“ Is HashMap.get() always O(1)?<br>
âŒ No â€” Average O(1), Worst O(log n)
</div>

<div class="note">
â“ Does treeification make HashMap sorted?<br>
âŒ No â€” trees exist only inside individual buckets
</div>

<h3>ğŸ¯ Perfect Interview Answer</h3>

<div class="success">
â€œHashMap.get() is O(1) on average because hashing enables direct bucket access.  
In Java 8 and later, if too many collisions occur, the bucket is converted into a Red-Black Tree, reducing the worst-case lookup time from O(n) to O(log n).â€
</div>

<h3>ğŸ§  Golden Rules</h3>

<div class="note">
ğŸ”¥ Good hashCode â†’ O(1)<br>
ğŸ”¥ Too many collisions â†’ Tree â†’ O(log n)<br>
ğŸ”¥ Never assume HashMap is always O(1)
</div>
<div class="divider"></div>

<h2 id="3-section">3ï¸âƒ£ Why does ConcurrentHashMap not allow null keys or values?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ The Problem</h2>

<pre><code>map.put(null, "x");      // âŒ NullPointerException
map.put("key", null);   // âŒ NullPointerException</code></pre>

<h2>ğŸ”¹ Short Answer (What Interviewers Expect)</h2>

<div class="note">
<b>Because <code>null</code> would make concurrent reads ambiguous.</b>
</div>

<h2>ğŸ”¹ The Real Reason (Deep Explanation)</h2>

<h3>In a Normal HashMap</h3>

<pre><code>map.get(key);</code></pre>

<p>If this returns <code>null</code>, it can mean:</p>
<ul>
    <li>The key is <b>not present</b></li>
    <li>The key exists but the value is <b>null</b></li>
</ul>

<div class="note">
In single-threaded code, this ambiguity is tolerable.
</div>

<h2>ğŸ”¹ Why This Breaks in Concurrent Systems</h2>

<h3>Imagine this in ConcurrentHashMap</h3>

<pre><code>User user = map.get(userId);</code></pre>

<p>The result is <code>null</code>. What does it mean?</p>

<ul>
    <li>â“ Another thread removed the key?</li>
    <li>â“ The key was never added?</li>
    <li>â“ The value is explicitly null?</li>
    <li>â“ A write is still in progress?</li>
</ul>

<div class="danger">
ğŸ‘‰ There is <b>no safe way</b> to distinguish these cases concurrently.
</div>

<h2>ğŸ”¹ Atomic Operations Would Break</h2>

<p>ConcurrentHashMap provides atomic methods like:</p>

<pre><code>map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> createUser());</code></pre>

<h3>If null were allowed:</h3>

<pre><code>map.put("A", null);
map.computeIfAbsent("A", k -> new User());</code></pre>

<ul>
    <li>â“ Should <code>computeIfAbsent</code> run?</li>
    <li>â“ Is <code>null</code> â€œabsentâ€ or â€œpresentâ€?</li>
</ul>

<div class="danger">
â¡ï¸ Undefined behavior â†’ âŒ NOT acceptable in concurrent code
</div>

<h2>ğŸ”¹ HashMap vs ConcurrentHashMap</h2>

<table>
    <tr>
        <th>Map Type</th>
        <th>Allows null</th>
        <th>Reason</th>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>âœ… Yes</td>
        <td>Single-threaded, ambiguity acceptable</td>
    </tr>
    <tr>
        <td>ConcurrentHashMap</td>
        <td>âŒ No</td>
        <td>Concurrency + atomic guarantees</td>
    </tr>
</table>

<h2>ğŸ”¹ Design Decision (Very Important)</h2>

<div class="success">
<b>ConcurrentHashMap chooses correctness and clarity over flexibility.</b>
</div>

<ul>
    <li>Eliminates ambiguity</li>
    <li>Simplifies concurrency guarantees</li>
    <li>Enables lock-free reads</li>
    <li>Makes atomic operations safe</li>
</ul>

<h2>ğŸ”¹ Correct Alternatives</h2>

<h3>âœ… Use Optional</h3>

<pre><code>ConcurrentHashMap&lt;String, Optional&lt;User&gt;&gt; map = new ConcurrentHashMap<>();

map.put("u1", Optional.empty());</code></pre>

<pre><code>Optional&lt;User&gt; user = map.get("u1");
user.ifPresent(u -> process(u));</code></pre>

<h3>âœ… Sentinel Object</h3>

<pre><code>static final User NULL_USER = new User("NA");

map.put("u1", NULL_USER);</code></pre>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œConcurrentHashMap does not allow null keys or values because null would make concurrent reads ambiguous.  
In a multi-threaded environment, a null return could mean absence, a concurrent removal, or an incomplete write.  
Disallowing null enables clear semantics and safe atomic operations like computeIfAbsent.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” HashMap â†’ convenience<br>
âœ” ConcurrentHashMap â†’ correctness<br>
âœ” No nulls â†’ predictable concurrency
</div>
<div class="divider"></div>

<h2 id="4-section">4ï¸âƒ£ Difference between synchronizedMap and ConcurrentHashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<ul>
    <li>synchronizedMap â†’ single global lock</li>
    <li>ConcurrentHashMap â†’ bucket-level locking</li>
</ul>
<h2>ğŸ”¹ Collections.synchronizedMap() â€” How It Works</h2>

<pre><code>Map&lt;String, String&gt; map =
    Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>

<h3>Basic</h3>
<ul>
    <li>Wraps a normal HashMap</li>
    <li>Adds <code>synchronized</code> to every method</li>
</ul>

<h3>Advanced â€“ Internal Behavior</h3>
<ul>
    <li>Uses <b>ONE global lock</b></li>
    <li>Only one thread can read/write/iterate at a time</li>
</ul>

<pre><code>Thread 1 â†’ LOCK â†’ read/write
Thread 2 â†’ WAIT
Thread 3 â†’ WAIT</code></pre>

<div class="danger">
â± <b>Performance Impact</b>
<ul>
    <li>High contention under load</li>
    <li>Poor scalability</li>
    <li>Threads block even for reads</li>
</ul>
</div>

<h3>âŒ Iteration Caveat (Very Important)</h3>

<pre><code>synchronized (map) {
    for (String key : map.keySet()) {
        // safe iteration
    }
}</code></pre>

<div class="danger">
âŒ Forgetting synchronization during iteration may cause  
<b>ConcurrentModificationException</b>
</div>

<h2>ğŸ”¹ ConcurrentHashMap â€” How It Works</h2>

<pre><code>ConcurrentHashMap&lt;String, String&gt; map =
    new ConcurrentHashMap&lt;&gt;();</code></pre>

<h3>Basic</h3>
<ul>
    <li>Built for <b>high concurrency</b></li>
    <li>Thread-safe without a global lock</li>
</ul>

<h3>Advanced â€“ Java 8+ Internals</h3>
<ul>
    <li><b>Lock-free reads</b></li>
    <li><b>Fine-grained locking</b> on buckets</li>
    <li>Uses CAS, volatile, and synchronized blocks only when required</li>
</ul>

<pre><code>Thread A â†’ Bucket 1
Thread B â†’ Bucket 5
Thread C â†’ READ (no lock)</code></pre>

<div class="success">
â± <b>Performance Impact</b>
<ul>
    <li>Multiple threads read/write simultaneously</li>
    <li>Scales with CPU cores</li>
    <li>Ideal for microservices</li>
</ul>
</div>

<h3>âœ… Iteration Behavior</h3>

<pre><code>for (Map.Entry&lt;String, String&gt; e : map.entrySet()) {
    // safe
}</code></pre>

<div class="success">
âœ” No ConcurrentModificationException<br>
âœ” Weakly consistent iterator
</div>

<h2>ğŸ”¹ Side-by-Side Comparison (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>synchronizedMap</th>
        <th>ConcurrentHashMap</th>
    </tr>
    <tr><td>Thread safety</td><td>âœ…</td><td>âœ…</td></tr>
    <tr><td>Locking</td><td>âŒ Global</td><td>âœ… Bucket-level</td></tr>
    <tr><td>Concurrent reads</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Concurrent writes</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Performance</td><td>âŒ Poor</td><td>âœ… High</td></tr>
    <tr><td>CME risk</td><td>Possible</td><td>âŒ Never</td></tr>
    <tr><td>Null keys/values</td><td>âœ…</td><td>âŒ</td></tr>
    <tr><td>Atomic operations</td><td>âŒ</td><td>âœ…</td></tr>
</table>

<h2>ğŸ”¹ Real-World Scenario Comparison</h2>

<h3>âŒ synchronizedMap (Bad Under Load)</h3>

<pre><code>Map&lt;String, User&gt; cache =
    Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre>

<ul>
    <li>50 threads â†’ serialized access</li>
    <li>High latency</li>
    <li>Thread starvation</li>
</ul>

<h3>âœ… ConcurrentHashMap (Production-Grade)</h3>

<pre><code>ConcurrentHashMap&lt;String, User&gt; cache =
    new ConcurrentHashMap&lt;&gt;();</code></pre>

<ul>
    <li>Parallel reads & writes</li>
    <li>Low latency</li>
    <li>High throughput</li>
</ul>

<h2>ğŸ”¹ Atomic Operations (Huge Advantage)</h2>

<h3>âŒ synchronizedMap (NOT atomic)</h3>

<pre><code>if (!map.containsKey(key)) {
    map.put(key, value); // race condition
}</code></pre>

<h3>âœ… ConcurrentHashMap (Atomic)</h3>

<pre><code>map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> loadUser());</code></pre>

<div class="success">
âœ” Thread-safe<br>
âœ” No race conditions
</div>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts (Interview Critical)</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Prefer ConcurrentHashMap for concurrency</li>
    <li>Use atomic methods (<code>computeIfAbsent</code>)</li>
    <li>Use for caches, sessions, rate limiters</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t use synchronizedMap in high-traffic systems</li>
    <li>Donâ€™t assume HashMap + synchronized scales</li>
    <li>Donâ€™t allow nulls in ConcurrentHashMap</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œCollections.synchronizedMap uses a single global lock, allowing only one thread at a time, which limits scalability.  
ConcurrentHashMap uses fine-grained locking and lock-free reads, enabling high concurrency and better performance.  
Thatâ€™s why ConcurrentHashMap is preferred in multi-threaded and microservices environments.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Low concurrency â†’ synchronizedMap (rare)<br>
âœ” High concurrency â†’ ConcurrentHashMap (default choice)
</div>
<div class="divider"></div>

<h2 id="5-section">5ï¸âƒ£ Why does CopyOnWriteArrayList perform poorly on writes?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<div class="note">
<b>Every write operation creates a new copy of the entire underlying array.</b>
</div>

<h2>ğŸ”¹ How CopyOnWriteArrayList Works Internally</h2>

<p>
<code>CopyOnWriteArrayList</code> is built on one core idea:
</p>

<div class="note">
<b>Reads should be extremely fast and never block.</b>
</div>

<ul>
    <li>Internal array is <b>immutable for readers</b></li>
    <li>Writers always create a <b>brand-new array</b></li>
</ul>

<h2>ğŸ”¹ What Happens During a Write</h2>

<pre><code>list.add(x);</code></pre>

<h3>Internal Steps</h3>
<ol>
    <li>Acquire lock</li>
    <li>Create a <b>new array</b> (size + 1)</li>
    <li>Copy all existing elements</li>
    <li>Add new element</li>
    <li>Replace internal reference</li>
    <li>Release lock</li>
</ol>

<pre><code>Old Array â†’ [A, B, C]
New Array â†’ [A, B, C, X]   // full copy</code></pre>

<div class="danger">
â± Write Time Complexity: <b>O(n)</b><br>
ğŸ’¾ Memory Cost: <b>O(n)</b>
</div>

<h2>ğŸ”¹ What Happens During Reads (Why It Exists)</h2>

<pre><code>for (String s : list) {
    // lock-free read
}</code></pre>

<ul>
    <li>Readers see a <b>snapshot</b></li>
    <li>No locks</li>
    <li>No ConcurrentModificationException</li>
</ul>

<div class="success">
â± Read Cost: <b>O(1)</b> per access<br>
ğŸš€ Extremely fast & scalable
</div>

<h2>ğŸ”¹ Why Writes Are Expensive (Core Reason)</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>Cost</th>
    </tr>
    <tr>
        <td>Read</td>
        <td>O(1), lock-free</td>
    </tr>
    <tr>
        <td>Write (add/remove/set)</td>
        <td>âŒ O(n) + array copy</td>
    </tr>
</table>

<div class="danger">
If you have 1,000 elements:<br>
â€¢ 1 write â†’ copy 1,000 elements<br>
â€¢ 1,000 writes â†’ copy <b>1,000,000 elements</b>
</div>

<h2>ğŸ”¹ Real-Time Example (Bad Use Case âŒ)</h2>

<pre><code>CopyOnWriteArrayList<Event> events = new CopyOnWriteArrayList<>();

while (true) {
    events.add(new Event()); // terrible performance
}</code></pre>

<ul>
    <li>High CPU usage</li>
    <li>Excessive memory churn</li>
    <li>Poor throughput</li>
</ul>

<h2>ğŸ”¹ Real-Time Example (Perfect Use Case âœ…)</h2>

<h3>Event Listeners / Observers</h3>

<pre><code>CopyOnWriteArrayList<Listener> listeners = new CopyOnWriteArrayList<>();

public void notifyAll(Event e) {
    for (Listener l : listeners) {
        l.onEvent(e);
    }
}</code></pre>

<div class="success">
âœ” Read-heavy<br>
âœ” Very few writes<br>
âœ” No synchronization overhead
</div>

<h2>ğŸ”¹ When You SHOULD Use CopyOnWriteArrayList</h2>

<ul>
    <li>Reads â‰« Writes (1000:1)</li>
    <li>Iteration happens very frequently</li>
    <li>You want to avoid synchronization</li>
    <li>ConcurrentModificationException must be avoided</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Event subscribers</li>
    <li>Configuration listeners</li>
    <li>Feature flags</li>
    <li>Observer pattern</li>
</ul>

<h2>ğŸ”¹ When You Should NOT Use It</h2>

<ul>
    <li>Frequent writes</li>
    <li>Large collections</li>
    <li>High churn (add/remove often)</li>
</ul>

<p><b>Avoid for:</b></p>
<ul>
    <li>Queues</li>
    <li>Logs</li>
    <li>Caches</li>
    <li>Message buffers</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œCopyOnWriteArrayList performs poorly on writes because each write operation creates a new copy of the entire underlying array.  
This design favors fast, lock-free reads at the cost of expensive writes, making it suitable only for read-heavy and write-rare use cases.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” <b>Read-heavy â†’ CopyOnWriteArrayList</b><br>
âŒ <b>Write-heavy â†’ Avoid it</b>
</div>

<div class="divider"></div>

<h2 id="6-section">6ï¸âƒ£ Fail-Fast vs Fail-Safe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Fail-Fast throws CME; Fail-Safe iterates on a snapshot.</p>
<h2>ğŸ”¹ What is Fail-Fast?</h2>

<h3>Definition</h3>
<p>
A <b>fail-fast iterator</b> immediately throws
<code>ConcurrentModificationException</code> if a collection is structurally modified while iterating.
</p>

<div class="note">
ğŸ“Œ â€œFail early, fail loudly.â€
</div>

<h3>Example (Fail-Fast)</h3>

<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));

for (Integer i : list) {
    if (i == 2) {
        list.add(10);   // âŒ ConcurrentModificationException
    }
}</code></pre>

<h3>Internal Mechanism (VERY IMPORTANT)</h3>

<ul>
    <li>Collection maintains <code>modCount</code></li>
    <li>Iterator maintains <code>expectedModCount</code></li>
    <li>Checked on every <code>next()</code></li>
</ul>

<pre><code>if (modCount != expectedModCount)
    throw new ConcurrentModificationException();</code></pre>

<div class="danger">
âœ” Detects unsafe modification<br>
âŒ Does <b>NOT</b> guarantee thread safety
</div>

<h3>Fail-Fast Collections</h3>
<ul>
    <li>ArrayList</li>
    <li>LinkedList</li>
    <li>HashMap</li>
    <li>HashSet</li>
</ul>

<h2>ğŸ”¹ What is Fail-Safe?</h2>

<h3>Definition</h3>
<p>
A <b>fail-safe iterator</b> does <b>NOT</b> throw CME because it iterates over a
<b>snapshot copy</b> of the collection.
</p>

<div class="note">
ğŸ“Œ â€œIterate safely, even if modified.â€
</div>

<h3>Example (Fail-Safe)</h3>

<pre><code>CopyOnWriteArrayList&lt;Integer&gt; list =
    new CopyOnWriteArrayList&lt;&gt;(List.of(1, 2, 3));

for (Integer i : list) {
    list.add(10);   // âœ… NO EXCEPTION
}</code></pre>

<h3>Internal Mechanism</h3>

<ul>
    <li>Iterator works on a <b>cloned snapshot</b></li>
    <li>Writes create a <b>new copy</b></li>
    <li>Iterator never sees changes</li>
</ul>

<div class="success">
âœ” Thread-safe<br>
âœ” No CME<br>
âŒ Extra memory overhead
</div>

<h3>Fail-Safe Collections</h3>
<ul>
    <li>CopyOnWriteArrayList</li>
    <li>CopyOnWriteArraySet</li>
    <li>ConcurrentHashMap iterators</li>
</ul>

<h2>ğŸ”¹ Side-by-Side Comparison (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Fail-Fast</th>
        <th>Fail-Safe</th>
    </tr>
    <tr><td>CME thrown</td><td>âœ… Yes</td><td>âŒ No</td></tr>
    <tr><td>Iterator sees changes</td><td>âŒ</td><td>âŒ</td></tr>
    <tr><td>Works on original collection</td><td>âœ…</td><td>âŒ</td></tr>
    <tr><td>Thread-safe</td><td>âŒ</td><td>âœ…</td></tr>
    <tr><td>Memory usage</td><td>Low</td><td>High</td></tr>
    <tr><td>Performance</td><td>Faster</td><td>Slower (writes)</td></tr>
</table>

<h2>ğŸ”¹ Behavior Difference (Very Important)</h2>

<h3>Fail-Fast</h3>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
list.add(4);
it.next();   // âŒ CME</code></pre>

<h3>Fail-Safe</h3>

<pre><code>Iterator&lt;Integer&gt; it = cowList.iterator();
cowList.add(4);
it.next();   // âœ… Works (snapshot)</code></pre>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âœ… Use Fail-Fast when:</h3>
<ul>
    <li>Single-threaded logic</li>
    <li>Early bug detection</li>
    <li>High performance needed</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Business rules</li>
    <li>Validation logic</li>
    <li>Data processing loops</li>
</ul>

<h3>âœ… Use Fail-Safe when:</h3>
<ul>
    <li>Multi-threaded environments</li>
    <li>Read-heavy workloads</li>
    <li>Concurrent access required</li>
</ul>

<p><b>Examples:</b></p>
<ul>
    <li>Event listeners</li>
    <li>Subscriber lists</li>
    <li>Cache readers</li>
</ul>

<h2>ğŸ”¹ Performance Trade-Off (Very Important)</h2>

<ul>
    <li><b>Fail-Fast:</b> Fast, low memory, unsafe modifications detected</li>
    <li><b>Fail-Safe:</b> Copy-on-write, slow writes, fast reads</li>
</ul>

<div class="note">
<b>Rule:</b> Many reads + few writes â†’ <b>Fail-Safe</b>
</div>

<h2>ğŸ”¹ Interview Traps (High Probability)</h2>

<div class>
â“ Is Fail-Safe always better?<br>
âŒ No â€” memory expensive
</div>

<br>

<div>
â“ Does Fail-Fast guarantee CME?<br>
âŒ No â€” best-effort only
</div>

<br>

<div>
â“ Can Fail-Safe iterators see new elements?<br>
âŒ No â€” snapshot only
</div>

<h2>ğŸ”¹ Perfect Interview Answer</h2>

<div class="success">
â€œFail-fast iterators throw ConcurrentModificationException when a collection is modified during iteration using a modCount check.  
Fail-safe iterators work on a snapshot copy of the collection, so they do not throw CME and are thread-safe, but they incur memory and performance overhead.â€
</div>

<h2>ğŸ”¹ One-Line Memory Trick ğŸ§ </h2>

<ul>
    <li><b>Fail-Fast</b> â†’ Detects bugs</li>
    <li><b>Fail-Safe</b> â†’ Avoids bugs</li>
</ul>

<h2>ğŸ”¹ Summary Table (Quick Revision)</h2>

<table>
    <tr>
        <th>Scenario</th>
        <th>Choose</th>
    </tr>
    <tr><td>Single thread</td><td>Fail-Fast</td></tr>
    <tr><td>High performance</td><td>Fail-Fast</td></tr>
    <tr><td>Multi-threaded</td><td>Fail-Safe</td></tr>
    <tr><td>Read-heavy system</td><td>Fail-Safe</td></tr>
</table>

<div class="divider"></div>

<h2 id="7-section">7ï¸âƒ£ Why does removeIf() not throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Internally uses iterator safely.</p>
<h2>â“ The Question</h2>

<pre><code>list.removeIf(x -> x &lt; 0);</code></pre>

<h2>ğŸ”¹ Short Answer (Interview-Ready)</h2>

<div class="note">
<b><code>removeIf()</code> internally uses the collectionâ€™s iterator and removes elements safely, keeping the iterator state consistent.</b>
</div>

<h2>ğŸ”¹ What Normally Causes ConcurrentModificationException</h2>

<pre><code>for (Integer x : list) {
    if (x &lt; 0) {
        list.remove(x); // âŒ CME
    }
}</code></pre>

<ul>
    <li>Enhanced for-loop uses an <b>Iterator</b></li>
    <li><code>list.remove()</code> modifies the collection <b>outside</b> the iterator</li>
    <li><code>modCount != expectedModCount</code> â†’ CME</li>
</ul>

<div class="danger">
âŒ This is the classic CME bug
</div>

<h2>ğŸ”¹ How <code>removeIf()</code> Works Internally (IMPORTANT)</h2>

<h3>Conceptual Internal Implementation</h3>

<pre><code>Iterator&lt;E&gt; it = list.iterator();
while (it.hasNext()) {
    if (predicate.test(it.next())) {
        it.remove(); // âœ… safe
    }
}</code></pre>

<h3>Why This Is Safe</h3>

<ul>
    <li><code>Iterator.remove()</code> updates the collection</li>
    <li>Also updates <code>expectedModCount</code></li>
    <li>No mismatch â†’ <b>No CME</b></li>
</ul>

<div class="success">
âœ” Iterator and collection stay in sync<br>
âœ” Safe structural modification
</div>

<h2>ğŸ”¹ Java 8 Design Decision</h2>

<p>
<code>removeIf()</code> was introduced in <b>Java 8</b> to:
</p>

<ul>
    <li>Provide safe functional-style removal</li>
    <li>Eliminate common CME bugs</li>
    <li>Encourage clean, readable code</li>
</ul>

<h2>ğŸ”¹ Time Complexity</h2>

<table>
    <tr>
        <th>Collection</th>
        <th>Complexity</th>
    </tr>
    <tr><td>ArrayList</td><td>O(n)</td></tr>
    <tr><td>LinkedList</td><td>O(n)</td></tr>
    <tr><td>HashSet</td><td>O(n)</td></tr>
</table>

<div class="note">
Still a single traversal â€” just safer.
</div>

<h2>ğŸ”¹ Real-Time Use Cases</h2>

<h3>Cleanup expired sessions</h3>
<pre><code>sessions.removeIf(Session::isExpired);</code></pre>

<h3>Remove invalid data</h3>
<pre><code>orders.removeIf(o -> o.getAmount() &lt;= 0);</code></pre>

<h3>Remove nulls</h3>
<pre><code>list.removeIf(Objects::isNull);</code></pre>

<h2>ğŸ”¹ Important Interview Traps</h2>

<div class="danger">
â“ Is <code>removeIf()</code> thread-safe?<br>
âŒ No â€” it only avoids CME in single-threaded iteration
</div>

<p><b>For concurrency use:</b></p>
<ul>
    <li>ConcurrentHashMap</li>
    <li>CopyOnWriteArrayList</li>
</ul>

<div class="danger">
â“ Does <code>removeIf()</code> work on immutable collections?<br>
âŒ No â€” throws UnsupportedOperationException
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œ<code>removeIf()</code> does not throw ConcurrentModificationException because it internally uses the collectionâ€™s iterator and calls <code>Iterator.remove()</code>, which keeps the iteratorâ€™s modification count in sync with the collection. This makes removal safe during traversal.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” <code>removeIf()</code> â†’ Safe removal<br>
âŒ for-each + remove() â†’ CME
</div>

<div class="divider"></div>

<h2 id="8-section">8ï¸âƒ£ Why override equals() and hashCode() together?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>HashMap uses both to ensure key uniqueness.</p>
<h2>â“ The Question</h2>

<h3>Short Answer (Interview-Ready)</h3>
<div class="note">
<b>HashMap uses <code>hashCode()</code> to locate the bucket and <code>equals()</code> to find the exact key inside that bucket.  
If they are inconsistent, key uniqueness breaks.</b>
</div>

<h2>ğŸ”¹ How HashMap Works Internally (IMPORTANT)</h2>

<pre><code>map.put(key, value);</code></pre>

<ul>
    <li><b>Step 1 â€“ hashCode()</b>: Determines the bucket</li>
    <li><b>Step 2 â€“ equals()</b>: Checks key equality inside the bucket</li>
</ul>

<h2>ğŸ”¹ Problem: equals() Without hashCode() âŒ</h2>

<pre><code>class User {
    String id;

    @Override
    public boolean equals(Object o) {
        return ((User) o).id.equals(this.id);
    }
    // hashCode() NOT overridden
}</code></pre>

<h3>What Goes Wrong</h3>
<ul>
    <li>Equal objects may produce different hash codes</li>
    <li>They go into different buckets</li>
</ul>

<pre><code>User u1 = new User("1");
User u2 = new User("1");

map.put(u1, "A");
map.put(u2, "B"); // âŒ Duplicate key allowed</code></pre>

<div class="danger">
HashMap thinks both keys are different.
</div>

<h2>ğŸ”¹ Problem: hashCode() Without equals() âŒ</h2>

<pre><code>class User {
    String id;

    @Override
    public int hashCode() {
        return id.hashCode();
    }
    // equals() NOT overridden
}</code></pre>

<h3>What Goes Wrong</h3>
<ul>
    <li>Keys land in the same bucket</li>
    <li>equals() falls back to reference comparison</li>
    <li>Logical duplicates are not detected</li>
</ul>

<div class="danger">
Lookups may fail and duplicates appear.
</div>

<h2>ğŸ”¹ The HashMap Contract (INTERVIEW FAVORITE)</h2>

<table>
    <tr>
        <th>Rule</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rule 1</td>
        <td>If <code>a.equals(b)</code> is true, then <code>a.hashCode() == b.hashCode()</code></td>
    </tr>
    <tr>
        <td>Rule 2</td>
        <td>Equal hash codes do NOT guarantee equals()</td>
    </tr>
    <tr>
        <td>Rule 3</td>
        <td>hashCode must be consistent</td>
    </tr>
</table>

<div class="note">
Violating this breaks HashMap, HashSet, ConcurrentHashMap.
</div>

<h2>ğŸ”¹ Correct Implementation âœ…</h2>

<pre><code>class User {
    private final String id;

    public User(String id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}</code></pre>

<div class="success">
âœ” Correct hashing<br>
âœ” No duplicates<br>
âœ” Reliable lookups
</div>

<h2>ğŸ”¹ Real-World Production Bug (VERY COMMON)</h2>

<ul>
    <li>User sessions stored in HashMap</li>
    <li>Cache misses</li>
    <li>Duplicate entries</li>
    <li>Memory leaks</li>
</ul>

<div class="danger">
<b>Root Cause:</b> equals() overridden but hashCode() missing
</div>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Always override both methods</li>
    <li>Use immutable fields</li>
    <li>Use <code>Objects.equals()</code> and <code>Objects.hash()</code></li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t override only one</li>
    <li>Donâ€™t use mutable fields in hashCode</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œHashMap uses <code>hashCode()</code> to locate the bucket and <code>equals()</code> to determine key equality within the bucket.  
Overriding only one breaks the hashing contract and leads to duplicate keys or lookup failures, so both must be overridden together.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” equals() â†’ logical equality<br>
âœ” hashCode() â†’ bucket location<br>
âœ” Both together â†’ correct hashing
</div>

<div class="divider"></div>

<h2 id="9-section">9ï¸âƒ£ Why is TreeMap slower than HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>TreeMap uses Red-Black Tree â†’ O(log n).</p>

<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>TreeMap is slower because it uses a Red-Black Tree to maintain sorted order, which requires O(log n) time for operations, whereas HashMap uses hashing for O(1) average-time access.</b>
</div>

<h2>ğŸ”¹ Internal Data Structures (Key Difference)</h2>

<table>
    <tr>
        <th>Map Type</th>
        <th>Internal Structure</th>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>Hash table (array + buckets)</td>
    </tr>
    <tr>
        <td>TreeMap</td>
        <td><b>Red-Black Tree</b> (self-balancing BST)</td>
    </tr>
</table>

<h2>ğŸ”¹ How HashMap Works (Fast)</h2>

<pre><code>map.get(key);</code></pre>

<ol>
    <li><code>hashCode()</code> â†’ bucket index</li>
    <li>Direct access to bucket</li>
    <li>Minimal comparisons</li>
</ol>

<div class="success">
â± <b>Average Time Complexity = O(1)</b>
</div>

<h2>ğŸ”¹ How TreeMap Works (Slower)</h2>

<pre><code>treeMap.get(key);</code></pre>

<ol>
    <li>Compare key with root</li>
    <li>Traverse left or right child</li>
    <li>Continue until key is found</li>
</ol>

<div class="danger">
â± <b>Time Complexity = O(log n)</b>
</div>

<h2>ğŸ”¹ Why TreeMap MUST Be Slower</h2>

<ul>
    <li>Maintains <b>sorted order</b></li>
    <li>Rebalances tree after inserts and deletes</li>
    <li>Performs <b>key comparisons</b> on every operation</li>
</ul>

<pre><code>        40
       /  \
     20    60</code></pre>

<p>
Tree rebalancing adds overhead that HashMap does not have.
</p>

<h2>ğŸ”¹ Big-O Comparison</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>HashMap</th>
        <th>TreeMap</th>
    </tr>
    <tr>
        <td>get()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>put()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>O(1) avg</td>
        <td><b>O(log n)</b></td>
    </tr>
    <tr>
        <td>Sorted order</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âŒ Using TreeMap Unnecessarily</h3>

<pre><code>Map&lt;String, User&gt; users = new TreeMap&lt;&gt;();</code></pre>

<ul>
    <li>Slower lookups</li>
    <li>Extra CPU usage</li>
    <li>No benefit if ordering is not required</li>
</ul>

<h3>âœ… Correct Usage of TreeMap</h3>

<pre><code>TreeMap&lt;Integer, Order&gt; orders = new TreeMap&lt;&gt;();
orders.subMap(100, 200);</code></pre>

<div class="success">
âœ” Sorted keys<br>
âœ” Range queries<br>
âœ” Ordered iteration
</div>

<h2>ğŸ”¹ Interview Traps</h2>

<div class="danger">
â“ Does TreeMap use hashing?<br>
âŒ No â€” it uses <b>comparison</b>, not hashing
</div>

<div class="danger">
â“ Is TreeMap thread-safe?<br>
âŒ No â€” must be externally synchronized
</div>

<div class="note">
â“ Is TreeMap ever faster?<br>
âœ” Yes â€” for <b>range queries</b> and ordered traversal
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œTreeMap is slower than HashMap because it uses a Red-Black Tree to maintain sorted order, which requires O(log n) time for insert, delete, and lookup operations. HashMap uses hashing for direct bucket access, giving O(1) average-time performance.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Need sorting or ranges â†’ <b>TreeMap</b><br>
âœ” Need fast lookup â†’ <b>HashMap</b>
</div>
<div class="divider"></div>

<h2 id="10-section">ğŸ”Ÿ When to use EnumMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>Use EnumMap when all keys are from a single enum type and you want maximum performance, minimal memory usage, and predictable iteration order.</b>
</div>

<h2>ğŸ”¹ What Is EnumMap?</h2>

<pre><code>EnumMap&lt;Day, String&gt; map = new EnumMap&lt;&gt;(Day.class);</code></pre>

<ul>
    <li>Specialized <b>Map implementation</b></li>
    <li>Keys must be <b>enum constants</b></li>
    <li>Internally backed by an <b>array</b>, not hashing</li>
</ul>

<h2>ğŸ”¹ Why EnumMap Is Highly Optimized</h2>

<h3>Internal Working</h3>

<ul>
    <li>Uses <code>enum.ordinal()</code> as array index</li>
    <li>No hashing</li>
    <li>No collisions</li>
    <li>Direct array access</li>
</ul>

<pre><code>enum â†’ ordinal() â†’ array[index]</code></pre>

<div class="success">
â± get() â†’ <b>O(1)</b><br>
â± put() â†’ <b>O(1)</b><br>
âœ” Faster than HashMap<br>
âœ” More memory-efficient
</div>

<h2>ğŸ”¹ Ordering Behavior</h2>

<p>
Iteration order is the <b>same as enum declaration order</b>.
</p>

<pre><code>enum Day { MON, TUE, WED, THU, FRI }</code></pre>

<p>Iteration order:</p>

<pre><code>MON â†’ TUE â†’ WED â†’ THU â†’ FRI</code></pre>

<h2>ğŸ”¹ Real-World Scenarios (VERY IMPORTANT)</h2>

<ul>
    <li><b>Configuration by enum</b></li>
</ul>

<pre><code>EnumMap&lt;Environment, String&gt; envUrls;</code></pre>

<ul>
    <li><b>State machine / workflow</b></li>
</ul>

<pre><code>EnumMap&lt;OrderStatus, OrderHandler&gt; handlers;</code></pre>

<ul>
    <li><b>Strategy pattern</b></li>
</ul>

<pre><code>EnumMap&lt;PaymentType, PaymentProcessor&gt; processors;</code></pre>

<ul>
    <li><b>Feature flags</b></li>
</ul>

<pre><code>EnumMap&lt;Feature, Boolean&gt; flags;</code></pre>

<h2>ğŸ”¹ Example: Strategy Pattern</h2>

<pre><code>enum PaymentType { CARD, UPI, NETBANKING }

EnumMap&lt;PaymentType, PaymentProcessor&gt; map =
        new EnumMap&lt;&gt;(PaymentType.class);

map.put(PaymentType.CARD, new CardProcessor());
map.put(PaymentType.UPI, new UpiProcessor());

map.get(PaymentType.UPI).pay();</code></pre>

<div class="success">
âœ” Type-safe<br>
âœ” Fast<br>
âœ” Clean, extensible design
</div>

<h2>ğŸ”¹ Why NOT HashMap Here?</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>HashMap</th>
        <th>EnumMap</th>
    </tr>
    <tr>
        <td>Hashing</td>
        <td>Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Memory</td>
        <td>Higher</td>
        <td><b>Lower</b></td>
    </tr>
    <tr>
        <td>Performance</td>
        <td>Good</td>
        <td><b>Best</b></td>
    </tr>
    <tr>
        <td>Type safety</td>
        <td>Runtime</td>
        <td><b>Compile-time</b></td>
    </tr>
</table>

<h2>ğŸ”¹ Important Restrictions (Interview Trap)</h2>

<div class="danger">
âŒ Keys must be from <b>only one enum type</b><br>
âŒ <code>null</code> keys are not allowed
</div>

<pre><code>map.put(null, "x"); // âŒ NullPointerException</code></pre>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Use when keys are enums</li>
    <li>Prefer EnumMap over HashMap for enum keys</li>
    <li>Use in performance-critical paths</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t use for dynamic or non-enum keys</li>
    <li>Donâ€™t mix different enums</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œEnumMap should be used when all keys belong to a single enum type. It is highly optimized because it uses an array indexed by enum ordinals, making it faster and more memory-efficient than HashMap while maintaining predictable iteration order.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>Enum keys â†’ EnumMap (always)</b>
</div>
<div class="divider"></div>


<h2 id="11-section">1ï¸âƒ£1ï¸âƒ£ Iterator vs ListIterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>ListIterator supports bidirectional traversal and modification.</p>
<h2>ğŸ”¹ Iterator â€” Basics</h2>

<h3>ğŸ”¹ What is Iterator?</h3>
<p>
An <b>Iterator</b> allows <b>forward-only traversal</b> of a collection.
</p>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    Integer val = it.next();
}</code></pre>

<h3>ğŸ”¹ Key Capabilities</h3>
<ul>
    <li>âœ” Forward traversal only</li>
    <li>âœ” Read elements one by one</li>
    <li>âœ” Remove elements safely during iteration</li>
</ul>

<pre><code>it.remove(); // removes last returned element</code></pre>

<h3>ğŸ”¹ Where it works</h3>
<ul>
    <li>List</li>
    <li>Set</li>
    <li>Queue</li>
    <li>All Collection types</li>
</ul>

<h3>ğŸ”¹ Time Complexity</h3>
<ul>
    <li><code>next()</code> â†’ <b>O(1)</b></li>
    <li>Full traversal â†’ <b>O(n)</b></li>
</ul>

<div class="success">
<b>Real-World Usage</b><br>
Safe iteration and removal in LinkedList or generic collections.
</div>

<pre><code>Iterator&lt;User&gt; it = users.iterator();
while (it.hasNext()) {
    if (!it.next().isActive()) {
        it.remove();
    }
}</code></pre>

<h2>ğŸ”¹ ListIterator â€” Basics</h2>

<h3>ğŸ”¹ What is ListIterator?</h3>
<p>
A <b>bidirectional iterator</b> specifically for <b>List implementations</b>.
</p>

<pre><code>ListIterator&lt;Integer&gt; it = list.listIterator();</code></pre>

<h3>ğŸ”¹ Extra Capabilities (VERY IMPORTANT)</h3>
<ul>
    <li>âœ” Forward traversal</li>
    <li>âœ” <b>Backward traversal</b></li>
    <li>âœ” Modify list during iteration</li>
    <li>âœ” Access index positions</li>
</ul>

<h3>ğŸ”¹ Forward + Backward Traversal</h3>

<pre><code>while (it.hasNext()) {
    System.out.println(it.next());
}

while (it.hasPrevious()) {
    System.out.println(it.previous());
}</code></pre>

<h3>ğŸ”¹ Modification Support</h3>

<pre><code>it.add(100);   // add element
it.set(200);  // replace element</code></pre>

<div class="success">
<b>Real-World Usage</b><br>
Undo/Redo systems, text editors, cursor navigation, in-place list edits.
</div>

<h2>ğŸ”¹ Side-by-Side Comparison (Interview Favorite)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Iterator</th>
        <th>ListIterator</th>
    </tr>
    <tr>
        <td>Traversal</td>
        <td>Forward only</td>
        <td>Forward + Backward</td>
    </tr>
    <tr>
        <td>Works on</td>
        <td>All Collections</td>
        <td>List only</td>
    </tr>
    <tr>
        <td>Add elements</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Replace elements</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Remove elements</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Index access</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Start from index</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ Starting From a Specific Position</h2>

<div class="danger">
âŒ Iterator â€“ Not possible
</div>

<div class="success">
âœ… ListIterator â€“ Supported
</div>

<pre><code>ListIterator&lt;String&gt; it = list.listIterator(3);</code></pre>

<p>Starts iteration from <b>index 3</b>.</p>

<h2>ğŸ”¹ LinkedList Performance Insight (VERY IMPORTANT)</h2>

<pre><code>for (int i = 0; i &lt; list.size(); i++) {
    list.get(i);  // âŒ O(nÂ²) for LinkedList
}</code></pre>

<pre><code>for (Integer v : list) {
    // âœ… O(n)
}</code></pre>

<div class="note">
Enhanced for-loop internally uses an <b>Iterator / ListIterator</b>, not <code>get(i)</code>.
</div>

<h2>ğŸ”¹ Common Interview Traps</h2>

<div class="danger">
â“ Modify list using for-each?<br>
âŒ Throws ConcurrentModificationException
</div>

<div class="success">
âœ” Iterator.remove() â†’ Safe<br>
âœ” ListIterator.add()/set() â†’ Safe
</div>

<div class="note">
â“ Why ListIterator doesnâ€™t work with Set?<br>
Because Set has no indexes and no guaranteed order.
</div>

<h2>ğŸ”¹ When to Use What (Golden Rule)</h2>

<div class="success">
<b>Use Iterator when:</b><br>
âœ” Generic traversal<br>
âœ” Working with Set / Queue<br>
âœ” Forward traversal only
</div>

<div class="note">
<b>Use ListIterator when:</b><br>
âœ” Bidirectional traversal<br>
âœ” In-place modification<br>
âœ” Index awareness needed
</div>

<h2>ğŸ”¹ Perfect Interview Answer</h2>

<div class="success">
â€œIterator supports forward-only traversal for all collection types, whereas ListIterator is specific to List implementations and supports bidirectional traversal, element modification, and index-based navigation.â€
</div>

<h2>ğŸ”¹ Summary Table (Quick Revision)</h2>

<table>
    <tr>
        <th>Scenario</th>
        <th>Best Choice</th>
    </tr>
    <tr>
        <td>Iterate LinkedList</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Remove while iterating</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Traverse backward</td>
        <td>ListIterator</td>
    </tr>
    <tr>
        <td>Insert during iteration</td>
        <td>ListIterator</td>
    </tr>
    <tr>
        <td>Generic collection</td>
        <td>Iterator</td>
    </tr>
</table>
<div class="divider"></div>


<h2 id="12-section">1ï¸âƒ£2ï¸âƒ£ Why does enhanced for-loop throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>Enhanced for-loop internally uses a fail-fast Iterator.  
If the collection is modified directly during iteration, the iterator detects the change and throws ConcurrentModificationException.</b>
</div>

<h2>ğŸ”¹ What Really Happens Inside Enhanced For-Loop</h2>

<p>This code:</p>

<pre><code>for (Integer x : list) {
    // ...
}</code></pre>

<p>is compiled by Java roughly into:</p>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    Integer x = it.next();
    // ...
}</code></pre>

<div class="success">
âœ” Enhanced for-loop = <b>Iterator-based traversal</b>
</div>

<h2>ğŸ”¹ Why CME Occurs (Core Reason)</h2>

<p>Most collections (<code>ArrayList</code>, <code>HashMap</code>, etc.) are <b>fail-fast</b>.</p>

<ul>
    <li><code>modCount</code> â†’ actual modification count</li>
    <li><code>expectedModCount</code> â†’ iteratorâ€™s snapshot</li>
</ul>

<p>On every <code>next()</code> call:</p>

<pre><code>if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
}</code></pre>

<h2>ğŸ”¹ The Classic Failing Example âŒ</h2>

<pre><code>for (Integer x : list) {
    if (x &lt; 0) {
        list.remove(x);   // âŒ CME
    }
}</code></pre>

<h3>Why This Fails</h3>

<ul>
    <li>Iterator controls traversal</li>
    <li>Collection modified <b>directly</b></li>
    <li><code>modCount</code> changes</li>
    <li>Iterator detects mismatch â†’ <b>CME</b></li>
</ul>

<div class="danger">
CME is thrown to prevent inconsistent iteration state.
</div>

<h2>ğŸ”¹ Why This Is Called Fail-Fast</h2>

<ul>
    <li>Fails immediately</li>
    <li>Detects bugs early</li>
    <li>Prevents corrupted state</li>
</ul>

<div class="note">
<b>CME is a bug-detection mechanism, not thread safety.</b>
</div>

<h2>ğŸ”¹ Correct Ways to Avoid CME âœ…</h2>

<h3>âœ… Option 1: Use Iterator.remove()</h3>

<pre><code>Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    if (it.next() &lt; 0) {
        it.remove(); // safe
    }
}</code></pre>

<div class="success">
âœ” Updates expectedModCount<br>
âœ” No CME
</div>

<h3>âœ… Option 2: Use removeIf() (Java 8+)</h3>

<pre><code>list.removeIf(x -&gt; x &lt; 0);</code></pre>

<div class="success">
âœ” Internally uses iterator safely<br>
âœ” Clean and preferred
</div>

<h3>âœ… Option 3: Use Concurrent Collections</h3>

<pre><code>CopyOnWriteArrayList&lt;Integer&gt; list =
        new CopyOnWriteArrayList&lt;&gt;();</code></pre>

<div class="success">
âœ” No CME<br>
âœ” Snapshot-based iteration
</div>

<h2>ğŸ”¹ Important Interview Traps</h2>

<div class="danger">
â“ Is CME only for multithreading?<br>
âŒ No â€” happens even in single-threaded code
</div>

<div class="note">
â“ Why doesnâ€™t set() cause CME?<br>
Because it is <b>not a structural modification</b>
</div>

<pre><code>list.set(0, 100); // âœ… No CME</code></pre>

<div class="note">
â“ Does enhanced for-loop always throw CME?<br>
âŒ No â€” only when modified outside the iterator
</div>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œEnhanced for-loop uses an internal fail-fast iterator.  
If the collection is structurally modified directly during iteration, the iterator detects a mismatch in modification count and throws ConcurrentModificationException.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Read-only traversal â†’ enhanced for-loop<br>
âœ” Removal during iteration â†’ Iterator.remove() / removeIf()<br>
âŒ Never modify collection directly inside for-each
</div>

<div class="divider"></div>


<h2 id="13-section">1ï¸âƒ£3ï¸âƒ£ Why is ArrayDeque preferred over Stack?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b>
<code>Stack</code> is a legacy, synchronized class with poor performance, whereas
<code>ArrayDeque</code> is modern, faster, and unsynchronized, making it the recommended choice for stack operations in Java.
</b>
</div>

<h2>ğŸ”¹ What Is Wrong with <code>Stack</code>?</h2>

<pre><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code></pre>

<h3>Problems with <code>Stack</code></h3>

<ul>
    <li><b>Legacy class</b> â€“ introduced in Java 1.0</li>
    <li>Extends <code>Vector</code> (also legacy)</li>
    <li><b>Synchronized methods</b> â†’ unnecessary locking</li>
    <li>Poor performance even in single-threaded code</li>
    <li>Bad design â€“ inherits unrelated methods</li>
</ul>

<div class="danger">
âŒ <code>Stack</code> violates clean abstraction and modern performance expectations.
</div>

<h2>ğŸ”¹ Why <code>ArrayDeque</code> Is Better</h2>

<pre><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code></pre>

<h3>Advantages of <code>ArrayDeque</code></h3>

<ul>
    <li>Part of modern <b>Java Collections Framework</b></li>
    <li>No synchronization â†’ <b>faster</b></li>
    <li>Resizable array â†’ better cache locality</li>
    <li>Clean stack abstraction via <code>Deque</code></li>
    <li>Recommended by Oracle documentation</li>
</ul>

<div class="success">
âœ” Modern design<br>
âœ” High performance<br>
âœ” Clean API
</div>

<h2>ğŸ”¹ Stack Operations Comparison</h2>

<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Stack</th>
            <th>ArrayDeque</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Push</td>
            <td><code>push()</code></td>
            <td><code>push()</code></td>
        </tr>
        <tr>
            <td>Pop</td>
            <td><code>pop()</code></td>
            <td><code>pop()</code></td>
        </tr>
        <tr>
            <td>Peek</td>
            <td><code>peek()</code></td>
            <td><code>peek()</code></td>
        </tr>
    </tbody>
</table>

<pre><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
stack.push(10);
stack.push(20);
int top = stack.pop(); // 20</code></pre>

<h2>ğŸ”¹ Performance Comparison</h2>

<table>
    <thead>
        <tr>
            <th>Aspect</th>
            <th>Stack</th>
            <th>ArrayDeque</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Synchronization</td>
            <td>Yes</td>
            <td>âŒ No</td>
        </tr>
        <tr>
            <td>Speed</td>
            <td>Slow</td>
            <td><b>Fast</b></td>
        </tr>
        <tr>
            <td>Thread-safe</td>
            <td>Yes</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Recommended</td>
            <td>âŒ No</td>
            <td>âœ… Yes</td>
        </tr>
    </tbody>
</table>

<div class="note">
<b>Interview Tip:</b>  
If thread safety is required, use <code>ConcurrentLinkedDeque</code>.
</div>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3>âŒ Old Code (Avoid)</h3>

<pre><code>Stack&lt;String&gt; undoStack = new Stack&lt;&gt;();</code></pre>

<h3>âœ… Modern Code (Preferred)</h3>

<pre><code>Deque&lt;String&gt; undoStack = new ArrayDeque&lt;&gt;();</code></pre>

<p>Used in:</p>

<ul>
    <li>Expression evaluation</li>
    <li>Undo / Redo systems</li>
    <li>DFS algorithms</li>
    <li>Parsing logic</li>
</ul>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>

<ul>
    <li>Use <code>Deque</code> interface</li>
    <li>Prefer <code>ArrayDeque</code> for stack & queue</li>
    <li>Use concurrent deque if multithreaded</li>
</ul>

<h3>âŒ Donâ€™ts</h3>

<ul>
    <li>Donâ€™t use <code>Stack</code> in new code</li>
    <li>Donâ€™t rely on implicit synchronization</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œ<code>Stack</code> is a legacy class that extends <code>Vector</code> and synchronizes every method,
leading to poor performance. <code>ArrayDeque</code> is a modern, unsynchronized implementation
that provides faster stack operations and is the recommended replacement.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>Stack is obsolete â†’ Use ArrayDeque</b>
</div>
<div class="divider"></div>


<h2 id="14-section">1ï¸âƒ£4ï¸âƒ£ poll() vs remove() â€” Queue / Deque?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>
This is a <b>classic interview question</b>.  
Interviewers expect you to explain <b>design intent, behavior, performance, and real-world usage</b> â€” not just syntax.
</p>

<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b><code>poll()</code> returns <code>null</code> if the queue is empty, whereas <code>remove()</code> throws a <code>NoSuchElementException</code>.</b>
</div>

<h2>ğŸ”¹ What Each Method Does</h2>

<h3>poll()</h3>

<pre><code>Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
Integer x = q.poll();   // returns null if empty</code></pre>

<ul>
    <li>Removes <b>and returns</b> the head</li>
    <li><b>No exception</b> if queue is empty</li>
    <li>Safe for conditional logic</li>
</ul>

<h3>remove()</h3>

<pre><code>Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
Integer x = q.remove(); // throws exception if empty</code></pre>

<ul>
    <li>Removes <b>and returns</b> the head</li>
    <li>Throws <b>NoSuchElementException</b> if empty</li>
    <li>Enforces strict contract</li>
</ul>

<h2>ğŸ”¹ Behavior Comparison (Interview Favorite)</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>poll()</th>
        <th>remove()</th>
    </tr>
    <tr>
        <td>Empty queue</td>
        <td>returns <code>null</code></td>
        <td>throws exception</td>
    </tr>
    <tr>
        <td>Exception</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Use case</td>
        <td>Safe / conditional</td>
        <td>Strict / guaranteed</td>
    </tr>
    <tr>
        <td>Common usage</td>
        <td>Non-blocking checks</td>
        <td>Validation logic</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-Time Usage Scenarios</h2>

<h3>âœ… Use poll() when emptiness is expected</h3>

<pre><code>Job job;
while ((job = queue.poll()) != null) {
    process(job);
}</code></pre>

<div class="success">
âœ” Background workers<br>
âœ” Retry queues<br>
âœ” Non-blocking processing
</div>

<h3>âœ… Use remove() when empty is an error</h3>

<pre><code>Order order = queue.remove(); // must exist</code></pre>

<div class="note">
âœ” Business rules<br>
âœ” Guaranteed data presence
</div>

<h2>ğŸ”¹ Important Interview Traps</h2>

<div class="note">
â“ What if the queue allows <code>null</code> elements?<br>
Most queues (<b>ArrayDeque</b>, <b>PriorityQueue</b>) <b>do NOT allow null</b>.<br>
So <code>poll() == null</code> safely means <b>empty</b>.
</div>

<div class="danger">
â“ Does <code>remove()</code> ever return null?<br>
âŒ No â€” it either returns an element or throws
</div>

<h2>ğŸ”¹ Queue API Family (Related Methods)</h2>

<table>
    <tr>
        <th>Method</th>
        <th>Empty Behavior</th>
    </tr>
    <tr>
        <td>poll()</td>
        <td>returns <code>null</code></td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>throws exception</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>returns <code>null</code></td>
    </tr>
    <tr>
        <td>element()</td>
        <td>throws exception</td>
    </tr>
</table>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œ<code>poll()</code> safely returns null when the queue is empty, while <code>remove()</code> throws a NoSuchElementException.  
<code>poll()</code> is preferred in non-blocking or conditional processing, whereas <code>remove()</code> is used when the presence of an element is guaranteed.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
âœ” Uncertain emptiness â†’ <b>poll()</b><br>
âœ” Guaranteed element â†’ <b>remove()</b>
</div>

<p>
<b>Design Insight:</b>  
This API design allows developers to choose between <b>defensive programming</b> (poll) and <b>strict correctness</b> (remove) without extra checks.
</p>

<div class="divider"></div>


<h2 id="15-section">1ï¸âƒ£5ï¸âƒ£ Why is Vector discouraged?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Global synchronization â†’ poor performance.</p>

<h2>â“ Short Answer (Interview-Ready)</h2>

<div class="note">
<b><code>Vector</code> is discouraged because it synchronizes every method using a single global lock, causing poor performance and scalability. It is a legacy class and modern alternatives should be used.</b>
</div>

<h2>ğŸ”¹ What Is Vector?</h2>

<pre><code>Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();</code></pre>

<ul>
    <li>Introduced in <b>Java 1.0</b></li>
    <li>Part of <b>legacy collections</b></li>
    <li>All public methods are <b>synchronized</b></li>
</ul>

<h2>ğŸ”¹ Core Problem: Global Synchronization âŒ</h2>

<p>Every operation in <code>Vector</code> is synchronized:</p>

<pre><code>public synchronized boolean add(E e) { ... }
public synchronized E get(int index) { ... }</code></pre>

<h3>What This Means</h3>

<ul>
    <li>Only <b>one thread</b> can access the Vector at a time</li>
    <li>Even <b>read operations block each other</b></li>
    <li>Severe contention under load</li>
</ul>

<pre><code>Thread 1 â†’ LOCK â†’ read
Thread 2 â†’ WAIT
Thread 3 â†’ WAIT</code></pre>

<div class="danger">
â± Result â†’ <b>Poor throughput and scalability</b>
</div>

<h2>ğŸ”¹ Performance Impact (Why Interviewers Care)</h2>

<table>
    <tr>
        <th>Scenario</th>
        <th>Vector</th>
        <th>Alternative</th>
    </tr>
    <tr>
        <td>Single-threaded</td>
        <td>âŒ Slow</td>
        <td>âœ… ArrayList</td>
    </tr>
    <tr>
        <td>Multi-threaded</td>
        <td>âŒ Bottleneck</td>
        <td>âœ… Concurrent Collections</td>
    </tr>
    <tr>
        <td>Scalability</td>
        <td>âŒ Poor</td>
        <td>âœ… High</td>
    </tr>
</table>

<h2>ğŸ”¹ Bad Design (Important Interview Point)</h2>

<ul>
    <li>Extends <code>List</code> but forces synchronization</li>
    <li>No flexibility to choose locking strategy</li>
    <li>Violates modern <b>separation of concerns</b></li>
    <li>Inherited legacy design decisions</li>
</ul>

<h2>ğŸ”¹ Better Alternatives (What to Use Instead)</h2>

<h3>âœ… If Thread Safety Is NOT Required</h3>

<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></pre>

<h3>âœ… If Thread Safety IS Required</h3>

<pre><code>List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></pre>

<p>or</p>

<pre><code>List&lt;Integer&gt; list =
    Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre>

<div class="success">
âœ” Prefer <b>CopyOnWriteArrayList</b> for read-heavy workloads
</div>

<h2>ğŸ”¹ Real-World Example</h2>

<h3>âŒ Avoid</h3>

<pre><code>Vector&lt;String&gt; users = new Vector&lt;&gt;();</code></pre>

<h3>âœ… Prefer</h3>

<pre><code>List&lt;String&gt; users = new ArrayList&lt;&gt;();</code></pre>

<p>or (concurrent):</p>

<pre><code>List&lt;String&gt; users = new CopyOnWriteArrayList&lt;&gt;();</code></pre>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Avoid Vector in new code</li>
    <li>Use modern collection classes</li>
    <li>Choose concurrency explicitly</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t rely on implicit synchronization</li>
    <li>Donâ€™t use Vector for scalability</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œVector is discouraged because all its methods are synchronized using a single global lock, which severely impacts performance and scalability. It is a legacy class, and modern alternatives like ArrayList, CopyOnWriteArrayList, or other concurrent collections should be used instead.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>Legacy + Global Lock = Avoid</b>
</div>
<div class="divider"></div>


<h2 id="16-section">1ï¸âƒ£6 Why HashSet internally uses HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<p>Keys ensure uniqueness; values are dummy.</p>
<h2>âœ… Short Answer (Interview-Ready)</h2>

<div class="note">
<b>
HashSet uses a HashMap internally because HashMap already provides hashing,
collision handling, and uniqueness of keys.  
Set elements are stored as keys, and the values are dummy objects.
</b>
</div>

<h2>ğŸ”¹ Internal Implementation (IMPORTANT)</h2>

<p>Simplified source-code structure of <code>HashSet</code>:</p>

<pre><code>public class HashSet&lt;E&gt; {
    private transient HashMap&lt;E, Object&gt; map;
    private static final Object PRESENT = new Object();
}</code></pre>

<h3>When you do:</h3>

<pre><code>set.add("A");</code></pre>

<h3>Internally:</h3>

<pre><code>map.put("A", PRESENT);</code></pre>

<ul>
    <li>âœ” Key = element</li>
    <li>âœ” Value = dummy placeholder</li>
</ul>

<h2>ğŸ”¹ Why This Design Makes Sense</h2>

<h3>1ï¸âƒ£ Uniqueness Is Guaranteed</h3>

<ul>
    <li>HashMap does <b>not allow duplicate keys</b></li>
    <li>HashSet gets uniqueness <b>for free</b></li>
</ul>

<h3>2ï¸âƒ£ Reuse Proven Hashing Logic</h3>

<p>HashMap already implements:</p>

<ul>
    <li><code>hashCode()</code></li>
    <li><code>equals()</code></li>
    <li>Collision resolution</li>
    <li>Resizing</li>
    <li>Treeification (Java 8+)</li>
</ul>

<div class="success">
âœ” No need to re-implement complex hashing logic
</div>

<h3>3ï¸âƒ£ Performance Benefits</h3>

<table>
    <tr>
        <th>Operation</th>
        <th>Time Complexity</th>
    </tr>
    <tr>
        <td>add()</td>
        <td>O(1) average</td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>O(1) average</td>
    </tr>
    <tr>
        <td>contains()</td>
        <td>O(1) average</td>
    </tr>
</table>

<h2>ğŸ”¹ Why a Dummy Value Is Needed</h2>

<p>
HashMap stores <b>key-value pairs</b>, but a Set only cares about keys.
So Java uses a single static dummy object:
</p>

<pre><code>private static final Object PRESENT = new Object();</code></pre>

<ul>
    <li>âœ” Saves memory</li>
    <li>âœ” Value itself is meaningless</li>
</ul>

<h2>ğŸ”¹ What Happens on Duplicate Insert?</h2>

<pre><code>set.add("A"); // true
set.add("A"); // false</code></pre>

<p>Internally:</p>

<pre><code>map.put("A", PRESENT); // returns old value</code></pre>

<ul>
    <li>If key already exists â†’ value replaced</li>
    <li>No structural change â†’ duplicate rejected</li>
</ul>

<h2>ğŸ”¹ Real-World Implication (Interview Gold)</h2>

<div class="danger">
â— If <code>equals()</code> or <code>hashCode()</code> is wrong,
HashSet uniqueness breaks.
</div>

<p>
Because:  
<b>HashSet â†’ HashMap â†’ hashing logic</b>
</p>

<h2>ğŸ”¹ Why Not Use TreeMap?</h2>

<p>Actually, it does ğŸ™‚</p>

<pre><code>TreeSet â†’ TreeMap</code></pre>

<p>
Same design idea, but with sorted order and <code>O(log n)</code> complexity.
</p>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Override <code>equals()</code> and <code>hashCode()</code></li>
    <li>Use immutable objects as set elements</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t modify objects after insertion</li>
    <li>Donâ€™t use mutable keys</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<div class="success">
â€œHashSet internally uses a HashMap because HashMap already provides hashing,
collision handling, and uniqueness of keys. The set elements are stored as keys,
and a dummy object is used as the value since Set only cares about uniqueness.â€
</div>

<h2>ğŸ§  Golden Rule</h2>

<div class="note">
<b>
Set â†’ keys only<br>
Map â†’ key + value<br>
Reuse Map to implement Set behavior
</b>
</div>
<div class="divider"></div>


<h2 id="17-section">1ï¸âƒ£7ï¸âƒ£ Why HashMap order is not guaranteed?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<h2>âœ… Short Answer (Interview-ready)</h2>
<blockquote>
    HashMap does not guarantee order because entries are stored based on 
    <strong>hash distribution into buckets</strong>, not insertion or sorted order.
</blockquote>

<h2>ğŸ”¹ How <code>HashMap</code> stores data internally</h2>
<ul>
    <li>Uses an <strong>array of buckets</strong></li>
    <li>Each keyâ€™s <code>hashCode()</code> determines the bucket index</li>
    <li>Iteration follows <strong>bucket order</strong>, not insertion order</li>
</ul>

<pre>
Bucket 0 â†’ keyB
Bucket 3 â†’ keyA
Bucket 7 â†’ keyC
</pre>

<p>
Iteration order = <strong>0 â†’ 3 â†’ 7</strong><br><br>
<span class="danger">NOT insertion order</span>
</p>

<h2>ğŸ”¹ Why hash distribution breaks ordering</h2>

<h3>Hash index calculation (simplified)</h3>
<pre>
index = (n - 1) &amp; hash;
</pre>

<ul>
    <li>If hash codes change</li>
    <li>If capacity changes</li>
    <li>If collisions differ</li>
</ul>

<p>â¡ï¸ Entry placement changes</p>

<h2>ğŸ”¹ Resizing makes order unpredictable (IMPORTANT)</h2>
<p>When <code>HashMap</code> resizes:</p>
<ul>
    <li>Capacity doubles</li>
    <li>All entries are <strong>rehashed</strong></li>
    <li>Buckets change</li>
</ul>

<pre>
Before resize â†’ After resize
Bucket 2      â†’ Bucket 10
Bucket 5      â†’ Bucket 21
</pre>

<p>ğŸ‘‰ Iteration order <strong>changes automatically</strong></p>

<h2>ğŸ”¹ Java 8 Treeification doesnâ€™t fix order</h2>
<ul>
    <li>Buckets may become <strong>Red-Black Trees</strong></li>
    <li>âŒ Order is only <strong>within a bucket</strong></li>
    <li>âŒ Overall iteration order is still undefined</li>
</ul>

<h2>ğŸ”¹ Why HashMap deliberately avoids ordering</h2>

<h3>Design intent</h3>
<ul>
    <li>Prioritize <strong>performance</strong></li>
    <li>Avoid overhead of maintaining order</li>
    <li>Keep <code>get()</code> and <code>put()</code> fast</li>
</ul>

<div class="note">
    Maintaining order would increase memory usage and slow down inserts.
</div>

<h2>ğŸ”¹ Real-World Example (Interview Trap)</h2>
<pre>
Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
map.put(3, "C");
map.put(1, "A");
map.put(2, "B");

System.out.println(map);
</pre>

<p>Possible outputs:</p>

<pre>
{1=A, 2=B, 3=C}
</pre>

<pre>
{3=C, 1=A, 2=B}
</pre>

<p class="danger">â¡ï¸ Never rely on this order</p>

<h2>ğŸ”¹ Correct Map choices when order matters</h2>

<table>
    <tr>
        <th>Requirement</th>
        <th>Map to Use</th>
    </tr>
    <tr>
        <td>Insertion order</td>
        <td><code>LinkedHashMap</code></td>
    </tr>
    <tr>
        <td>Sorted order</td>
        <td><code>TreeMap</code></td>
    </tr>
    <tr>
        <td>Access order</td>
        <td><code>LinkedHashMap</code> (accessOrder=true)</td>
    </tr>
</table>

<h2>ğŸ”¹ Interview Traps</h2>

<h3>â“ Is HashMap ever ordered?</h3>
<p>âŒ No (by contract)</p>

<h3>â“ Can iteration order change during runtime?</h3>
<p>âœ” Yes (after resize or rehash)</p>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    HashMap does not guarantee iteration order because entries are stored based on
    hash distribution into buckets. Resizing and rehashing can change bucket
    placement, so iteration order is intentionally undefined to optimize performance.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>HashMap = fast lookup, not order</strong>
</blockquote>

<div class="divider"></div>


<h2 id="18-section">1ï¸âƒ£8ï¸âƒ£ LinkedHashMap vs HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	

<h3>âœ… Short Answer (Interview-ready)</h3>
<blockquote>
    HashMap does not guarantee iteration order, while LinkedHashMap preserves
    insertion order or access order by maintaining a doubly linked list in addition
    to hashing.
</blockquote>

<h2>ğŸ”¹ HashMap â€” Quick Recap</h2>

<pre>
Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
</pre>

<h3>Characteristics</h3>
<ul>
    <li>Uses a <strong>hash table</strong></li>
    <li>Order depends on <strong>hash distribution</strong></li>
    <li>Fastest for lookup</li>
    <li>No ordering guarantees</li>
</ul>

<p>âœ” O(1) average <code>get()</code> / <code>put()</code><br><br>
<span class="danger">âŒ Unpredictable iteration order</span></p>

<h2>ğŸ”¹ LinkedHashMap â€” Whatâ€™s special?</h2>

<pre>
Map&lt;Integer, String&gt; map =
    new LinkedHashMap&lt;&gt;(16, 0.75f, true);
</pre>

<h3>Key Add-On</h3>
<ul>
    <li>Maintains a <strong>doubly linked list</strong> of entries</li>
    <li>Preserves <strong>iteration order</strong></li>
</ul>

<pre>
HashMap + Doubly Linked List
</pre>

<h2>ğŸ”¹ Two Ordering Modes (VERY IMPORTANT)</h2>

<h3>1ï¸âƒ£ Insertion Order (default)</h3>

<pre>
new LinkedHashMap&lt;&gt;();
</pre>

<pre>
put(3) â†’ put(1) â†’ put(2)
Iteration: 3 â†’ 1 â†’ 2
</pre>

<h3>2ï¸âƒ£ Access Order (LRU style)</h3>

<pre>
new LinkedHashMap&lt;&gt;(16, 0.75f, true);
</pre>

<ul>
    <li>Order changes when <code>get()</code> is called</li>
    <li>Most recently accessed entry moves to the end</li>
</ul>

<pre>
map.get(1);
Iteration: 3 â†’ 2 â†’ 1
</pre>

<h2>ğŸ”¹ Performance Comparison</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>HashMap</th>
        <th>LinkedHashMap</th>
    </tr>
    <tr>
        <td>Lookup</td>
        <td>O(1)</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>Insertion</td>
        <td>O(1)</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>Iteration order</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Memory usage</td>
        <td>Low</td>
        <td>Higher</td>
    </tr>
    <tr>
        <td>LRU support</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<div class="note">
    LinkedHashMap is slightly slower due to linked list maintenance.
</div>

<h2>ğŸ”¹ Real-World Use Cases (INTERVIEW GOLD)</h2>

<h3>âœ… Use HashMap when:</h3>
<ul>
    <li>Order doesnâ€™t matter</li>
    <li>Maximum performance needed</li>
    <li>Cache lookup only</li>
</ul>

<pre>
Map&lt;String, User&gt; cache = new HashMap&lt;&gt;();
</pre>

<h3>âœ… Use LinkedHashMap when:</h3>
<ul>
    <li>Predictable iteration order required</li>
    <li>Implementing <strong>LRU cache</strong></li>
    <li>API responses need stable order</li>
</ul>

<h2>ğŸ”¹ LRU Cache Implementation (VERY POPULAR)</h2>

<pre>
class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {

    private final int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true); // accessOrder = true
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {
        return size() &gt; capacity;
    }
}
</pre>

<p>âœ” Used in real systems<br>
âœ” Frequently asked in interviews</p>

<h2>ğŸ”¹ Interview Traps</h2>

<h3>â“ Does LinkedHashMap sort keys?</h3>
<p>âŒ No<br>âœ” Preserves insertion or access order only</p>

<h3>â“ Is LinkedHashMap thread-safe?</h3>
<p>âŒ No<br>âœ” Wrap or use concurrent alternatives</p>

<h3>â“ Does access order affect <code>put()</code>?</h3>
<ul>
    <li><code>put()</code> always inserts at the end</li>
    <li><code>get()</code> affects order only if <code>accessOrder = true</code></li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    HashMap provides fast key-value access but does not guarantee iteration order.
    LinkedHashMap extends HashMap and maintains a doubly linked list of entries,
    preserving insertion order or access order. This makes LinkedHashMap ideal for
    predictable iteration and LRU cache implementations.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>No order needed â†’ HashMap</strong><br>
    <strong>Order / LRU needed â†’ LinkedHashMap</strong>
</blockquote>

<div class="divider"></div>


<h2 id="19-section">1ï¸âƒ£9ï¸âƒ£ What is weakly consistent iterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	

<blockquote>
    A <strong>weakly consistent iterator</strong> may reflect <strong>some</strong>
    modifications made to the collection during iteration, but it
    <strong>never throws ConcurrentModificationException (CME)</strong> and
    never returns corrupted data.
</blockquote>

<h2>ğŸ”¹ Why do weakly consistent iterators exist?</h2>
<p>
Fail-fast iterators (<code>ArrayList</code>, <code>HashMap</code>) are excellent for
<strong>bug detection</strong>, but they donâ€™t scale well in
<strong>highly concurrent systems</strong>.
</p>

<p>Concurrent collections need:</p>
<ul>
    <li>Safe iteration</li>
    <li>No global locks</li>
    <li>No CME</li>
    <li>Acceptable visibility of concurrent updates</li>
</ul>

<p>
ğŸ‘‰ Thatâ€™s why <strong>weakly consistent iterators</strong> were introduced.
</p>

<h2>ğŸ”¹ Key Characteristics (IMPORTANT)</h2>
<ul>
    <li class="ok">âœ” Never throws CME</li>
    <li class="ok">âœ” Thread-safe iteration</li>
    <li class="warn">âœ” May or may not see concurrent updates</li>
    <li class="ok">âœ” No locking of the entire collection</li>
    <li class="ok">âœ” Always sees a consistent (non-corrupted) state</li>
</ul>

<div class="note">
    â€œWeaklyâ€ refers to <strong>visibility guarantees</strong>, not correctness.
</div>

<h2>ğŸ”¹ Collections with Weakly Consistent Iterators</h2>

<table>
    <tr>
        <th>Collection</th>
        <th>Iterator Type</th>
    </tr>
    <tr>
        <td>ConcurrentHashMap</td>
        <td>Weakly consistent</td>
    </tr>
    <tr>
        <td>ConcurrentLinkedQueue</td>
        <td>Weakly consistent</td>
    </tr>
    <tr>
        <td>ConcurrentLinkedDeque</td>
        <td>Weakly consistent</td>
    </tr>
    <tr>
        <td>CopyOnWriteArrayList</td>
        <td>Snapshot (stronger guarantee)</td>
    </tr>
</table>

<h2>ğŸ”¹ Example: ConcurrentHashMap</h2>

<pre>
ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
map.put("A", 1);
map.put("B", 2);

for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {
    map.put("C", 3);   // âœ… NO CME
    System.out.println(e);
}
</pre>

<h3>What can happen?</h3>
<ul>
    <li>The iterator <strong>may</strong> print <code>"C"</code></li>
    <li>Or <strong>may not</strong></li>
    <li>It will <strong>never crash</strong></li>
    <li>It will <strong>never show corrupted data</strong></li>
</ul>

<h2>ğŸ”¹ Weakly Consistent vs Fail-Fast</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Fail-Fast</th>
        <th>Weakly Consistent</th>
    </tr>
    <tr>
        <td>CME</td>
        <td>âŒ Throws</td>
        <td>âœ… Never</td>
    </tr>
    <tr>
        <td>Thread-safe</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Sees updates</td>
        <td>âŒ No</td>
        <td>âš ï¸ Maybe</td>
    </tr>
    <tr>
        <td>Performance</td>
        <td>Fast</td>
        <td>Scalable</td>
    </tr>
</table>

<h2>ğŸ”¹ Weakly Consistent vs Snapshot Iterators</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Snapshot (CopyOnWriteArrayList)</th>
        <th>Weakly Consistent</th>
    </tr>
    <tr>
        <td>Sees updates</td>
        <td>âŒ Never</td>
        <td>âš ï¸ Maybe</td>
    </tr>
    <tr>
        <td>Memory usage</td>
        <td>High (copy)</td>
        <td>Low</td>
    </tr>
    <tr>
        <td>Write cost</td>
        <td>Expensive</td>
        <td>Normal</td>
    </tr>
    <tr>
        <td>Best use</td>
        <td>Read-heavy systems</td>
        <td>Highly concurrent systems</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Usage (VERY IMPORTANT)</h2>

<p>Perfect for:</p>
<ul>
    <li>Caches</li>
    <li>Session stores</li>
    <li>Metrics</li>
    <li>Rate limiters</li>
    <li>Concurrent maps in microservices</li>
</ul>

<p>
You donâ€™t need a perfect snapshot â€” you need
<strong>availability and safety</strong>.
</p>

<h2>ğŸ”¹ Common Interview Traps</h2>

<h3>â“ Does weakly consistent mean inconsistent data?</h3>
<p>âŒ No<br>âœ” Data is always valid; visibility may vary</p>

<h3>â“ Does it guarantee to see latest updates?</h3>
<p>âŒ No<br>âœ” Guarantees safety, not freshness</p>

<h3>â“ Is it fail-safe?</h3>
<p>âœ” Yes (in practice), but technically called <em>weakly consistent</em></p>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    A weakly consistent iterator is used by concurrent collections. It does not
    throw ConcurrentModificationException and may reflect some modifications made
    during iteration, but it always maintains a consistent view of the data without
    locking the entire collection.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>Fail-fast â†’ bug detection</strong><br>
    <strong>Weakly consistent â†’ concurrency &amp; scalability</strong>
</blockquote>

<div class="divider"></div>


<h2 id="20-section">2ï¸âƒ£0ï¸âƒ£ How does ConcurrentHashMap achieve thread safety?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    ConcurrentHashMap achieves thread safety using a combination of
    <strong>CAS (Compare-And-Swap)</strong>, <strong>volatile variables</strong>,
    and <strong>fine-grained bucket-level locking</strong>, instead of a single
    global lock.
</blockquote>

<h2>ğŸ”¹ The 3 Core Techniques (VERY IMPORTANT)</h2>

<h3>1. CAS (Compare-And-Swap) â€” Lock-Free Updates</h3>

<p><strong>What is CAS?</strong></p>
<p>A CPU-level atomic operation:</p>

<pre>
Update value ONLY if current value matches expected value
</pre>

<p><strong>Used in ConcurrentHashMap for:</strong></p>
<ul>
    <li>Initial bucket insertion</li>
    <li>Resizing control</li>
    <li>Counter updates</li>
</ul>

<pre>
if (CAS(tab[i], null, newNode)) {
    // insert succeeded
}
</pre>

<ul>
    <li class="ok">âœ” No locking</li>
    <li class="ok">âœ” Very fast</li>
    <li class="ok">âœ” Avoids thread blocking</li>
</ul>

<h3>2. <code>volatile</code> â€” Memory Visibility</h3>

<p><strong>Why volatile?</strong></p>
<ul>
    <li>Ensures writes by one thread are <strong>visible</strong> to others</li>
    <li>Prevents instruction reordering</li>
</ul>

<p><strong>Where used?</strong></p>

<pre>
volatile Node&lt;K,V&gt;[] table;
</pre>

<ul>
    <li class="ok">âœ” Safe publication</li>
    <li class="ok">âœ” Enables lock-free reads</li>
</ul>

<h3>3. Bucket-Level Locking (Fine-Grained)</h3>

<p><strong>Java 8+ Strategy</strong></p>
<ul>
    <li>No global lock</li>
    <li>Only the <strong>specific bucket (bin)</strong> is locked</li>
</ul>

<pre>
synchronized (bin) {
    // modify this bucket only
}
</pre>

<p><strong>What this enables</strong></p>

<pre>
Thread A â†’ modifies bucket 2
Thread B â†’ modifies bucket 9
Thread C â†’ READ (no lock)
</pre>

<ul>
    <li class="ok">âœ” High concurrency</li>
    <li class="ok">âœ” Minimal contention</li>
</ul>

<h2>ğŸ”¹ Reads vs Writes (CRITICAL INTERVIEW POINT)</h2>

<h3>ğŸ” Reads (<code>get</code>)</h3>

<pre>
map.get(key);
</pre>

<ul>
    <li>No locking</li>
    <li>Uses <code>volatile</code> reads</li>
    <li>Multiple threads read simultaneously</li>
</ul>

<p class="ok">â± Lock-free &amp; extremely fast</p>

<h3>âœ Writes (<code>put</code>, <code>remove</code>)</h3>

<pre>
map.put(key, value);
</pre>

<p><strong>Flow:</strong></p>
<ol>
    <li>Try CAS</li>
    <li>If collision â†’ lock only that bucket</li>
    <li>Update bucket safely</li>
</ol>

<ul>
    <li class="ok">âœ” Other buckets remain accessible</li>
    <li class="ok">âœ” No full map lock</li>
</ul>

<h2>ğŸ”¹ Internal Data Structure (Java 8+)</h2>

<p>Same structure as HashMap, but thread-safe:</p>

<pre>
Bucket (Bin)
 â”œâ”€ Linked List (low collisions)
 â””â”€ Red-Black Tree (high collisions)
</pre>

<p>Treeification prevents worst-case <strong>O(n)</strong> behavior.</p>

<h2>ğŸ”¹ Atomic Methods (BIG ADVANTAGE)</h2>

<pre>
map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> load());
</pre>

<p><strong>Why these are safe:</strong></p>
<ul>
    <li>Entire operation is atomic</li>
    <li>No race conditions</li>
    <li>No external synchronization needed</li>
</ul>

<h2>ğŸ”¹ Why NOT Global Synchronization?</h2>

<h3><code>Collections.synchronizedMap()</code></h3>

<pre>
Thread 1 â†’ LOCK map
Thread 2 â†’ WAIT
Thread 3 â†’ WAIT
</pre>

<h3><code>ConcurrentHashMap</code></h3>

<pre>
Thread 1 â†’ bucket 3
Thread 2 â†’ bucket 7
Thread 3 â†’ READ (no lock)
</pre>

<h2>ğŸ”¹ Guarantees Provided</h2>

<ul>
    <li class="ok">âœ” Thread safety</li>
    <li class="ok">âœ” High throughput</li>
    <li class="ok">âœ” No CME</li>
    <li class="ok">âœ” Weakly consistent iterators</li>
    <li class="ok">âœ” Scales with CPU cores</li>
</ul>

<h2>ğŸ”¹ What <code>ConcurrentHashMap</code> Does NOT Guarantee</h2>

<ul>
    <li class="warn">âŒ No ordering</li>
    <li class="warn">âŒ No null keys or values</li>
    <li class="warn">âŒ Not fully lock-free (writes may lock bins)</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    ConcurrentHashMap achieves thread safety using CAS for lock-free updates,
    volatile variables for memory visibility, and fine-grained bucket-level locking
    for writes. Reads are lock-free, and only the affected bucket is synchronized
    during updates, allowing high concurrency without a global lock.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>CAS â†’ speed</strong><br>
    <strong>volatile â†’ visibility</strong><br>
    <strong>bucket locking â†’ scalability</strong>
</blockquote>

<div class="divider"></div>

<h2 id="21-section">2ï¸âƒ£1ï¸âƒ£ Why <code>containsKey()</code> + <code>put()</code> is unsafe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Because the check and the put are <strong>two separate operations</strong>, and
    another thread can modify the map between them, causing a
    <strong>race condition</strong>.
</blockquote>

<h2>ğŸ”¹ The Unsafe Pattern âŒ</h2>

<pre>
if (!map.containsKey(key)) {
    map.put(key, value);   // âŒ NOT atomic
}
</pre>

<h3>What can go wrong?</h3>
<ol>
    <li><strong>Thread A</strong> checks â†’ key not present</li>
    <li><strong>Thread B</strong> checks â†’ key not present</li>
    <li><strong>Thread A</strong> puts value</li>
    <li><strong>Thread B</strong> puts value again (overwrites)</li>
</ol>

<p class="danger">
ğŸ‘‰ Duplicate work, lost updates, inconsistent state.
</p>

<h2>ğŸ”¹ Why Synchronization Alone Doesnâ€™t Fix the Logic</h2>

<ul>
    <li><code>ConcurrentHashMap</code> methods are individually thread-safe</li>
    <li>But <code>containsKey()</code> + <code>put()</code> together are <strong>NOT atomic</strong></li>
</ul>

<div class="note">
    Thread-safe method â‰  thread-safe sequence
</div>

<h2>ğŸ”¹ Timeline Illustration (Race Condition)</h2>

<pre>
Time â†’
Thread A: containsKey(k) â†’ false
Thread B: containsKey(k) â†’ false
Thread A: put(k, v1)
Thread B: put(k, v2)   âŒ overwrite
</pre>

<h2>ğŸ”¹ Correct & Safe Solutions âœ…</h2>

<h3>âœ… <code>putIfAbsent()</code></h3>

<pre>
map.putIfAbsent(key, value);
</pre>

<ul>
    <li class="ok">âœ” Inserts only if key is absent</li>
    <li class="ok">âœ” Operation is atomic</li>
    <li class="ok">âœ” No race condition</li>
</ul>

<h3>âœ… <code>computeIfAbsent()</code> (Most Preferred)</h3>

<pre>
map.computeIfAbsent(key, k -> createValue());
</pre>

<ul>
    <li class="ok">âœ” Value created only once</li>
    <li class="ok">âœ” Fully thread-safe</li>
    <li class="ok">âœ” Clean, expressive code</li>
</ul>

<h2>ğŸ”¹ Why These Methods Are Safe</h2>

<ul>
    <li>Use CAS (Compare-And-Swap)</li>
    <li>Use bucket-level locking</li>
    <li>Execute the logic as <strong>one atomic unit</strong></li>
</ul>

<h2>ğŸ”¹ Real-World Example (Very Common)</h2>

<h3>âŒ Bad Cache Code</h3>

<pre>
User user = cache.get(id);
if (user == null) {
    user = loadFromDB(id);
    cache.put(id, user);
}
</pre>

<h3>âœ… Correct Cache Code</h3>

<pre>
User user = cache.computeIfAbsent(id, this::loadFromDB);
</pre>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Use atomic map operations</li>
    <li>Prefer <code>computeIfAbsent()</code></li>
    <li>Think in terms of atomicity</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t combine multiple map calls for one logical operation</li>
    <li>Donâ€™t assume thread-safe = race-free</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    <code>containsKey()</code> followed by <code>put()</code> is unsafe because the
    two operations are not atomic. Another thread can modify the map between the
    check and the put, leading to race conditions. Atomic methods like
    <code>putIfAbsent()</code> or <code>computeIfAbsent()</code> should be used
    instead.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>Thread-safe method â‰  thread-safe sequence</strong><br>
    <strong>Atomic operations prevent race conditions</strong>
</blockquote>

<div class="divider"></div>


<h2 id="22-section">2ï¸âƒ£2ï¸âƒ£ Comparable vs Comparator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <strong>Comparable</strong> defines the natural ordering of objects
    <em>inside the class</em>, while <strong>Comparator</strong> defines a
    custom ordering <em>externally</em>, without modifying the class.
</blockquote>

<h2>ğŸ”¹ Comparable</h2>

<h3>ğŸ“Œ What it is</h3>
<ul>
    <li>An interface implemented by the <strong>class itself</strong></li>
    <li>Defines <strong>natural order</strong></li>
    <li>Method: <code>compareTo()</code></li>
</ul>

<pre>
class User implements Comparable&lt;User&gt; {
    int age;

    @Override
    public int compareTo(User other) {
        return Integer.compare(this.age, other.age);
    }
}
</pre>

<h3>ğŸ” How itâ€™s used</h3>
<pre>
Collections.sort(users);  // uses compareTo()
</pre>

<h3>â± Time Complexity</h3>
<p>Sorting: <strong>O(n log n)</strong></p>

<h3>âœ… When to use Comparable</h3>
<ul>
    <li class="ok">âœ” Only one natural ordering exists</li>
    <li class="ok">âœ” Order is intrinsic to the object</li>
    <li class="ok">âœ” Sorting by ID, age, date, etc.</li>
</ul>

<h3>âŒ Drawbacks</h3>
<ul>
    <li class="warn">âŒ Only one ordering possible</li>
    <li class="warn">âŒ Modifies the domain class</li>
</ul>

<h2>ğŸ”¹ Comparator</h2>

<h3>ğŸ“Œ What it is</h3>
<ul>
    <li>A <strong>separate object</strong></li>
    <li>Defines <strong>custom or multiple orderings</strong></li>
    <li>Method: <code>compare()</code></li>
</ul>

<pre>
Comparator&lt;User&gt; byName =
    (u1, u2) -&gt; u1.name.compareTo(u2.name);
</pre>

<h3>ğŸ” How itâ€™s used</h3>
<pre>
Collections.sort(users, byName);
</pre>

<p>Java 8+</p>
<pre>
users.sort(Comparator.comparing(User::getName));
</pre>

<h3>âœ… When to use Comparator</h3>
<ul>
    <li class="ok">âœ” Multiple sorting strategies</li>
    <li class="ok">âœ” Cannot or should not modify the class</li>
    <li class="ok">âœ” Runtime / on-the-fly sorting decisions</li>
</ul>

<h3>âŒ Drawbacks</h3>
<ul>
    <li>âŒ Slightly more verbose (pre-Java 8)</li>
    <li>âŒ External logic to maintain</li>
</ul>

<h2>ğŸ”¹ Side-by-Side Comparison (Interview Favorite)</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>Comparable</th>
        <th>Comparator</th>
    </tr>
    <tr>
        <td>Defined in</td>
        <td>Same class</td>
        <td>Separate class</td>
    </tr>
    <tr>
        <td>Method</td>
        <td><code>compareTo()</code></td>
        <td><code>compare()</code></td>
    </tr>
    <tr>
        <td>Number of orders</td>
        <td>One</td>
        <td>Multiple</td>
    </tr>
    <tr>
        <td>Modifies class</td>
        <td>âœ… Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Use case</td>
        <td>Natural order</td>
        <td>Custom order</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Example (VERY COMMON)</h2>

<h3>User entity</h3>
<pre>
class User {
    String name;
    int age;
}
</pre>

<h3>Sort by age (natural)</h3>
<pre>
class User implements Comparable&lt;User&gt; {
    public int compareTo(User u) {
        return Integer.compare(this.age, u.age);
    }
}
</pre>

<h3>Sort by name (custom)</h3>
<pre>
users.sort(Comparator.comparing(User::getName));
</pre>

<h3>Sort by age descending</h3>
<pre>
users.sort(Comparator.comparing(User::getAge).reversed());
</pre>

<h2>ğŸ”¹ Interview Traps (Important)</h2>

<h3>â“ Can we use both?</h3>
<p>âœ” Yes â€” very common in real projects</p>

<h3>â“ What happens if Comparable is not implemented?</h3>
<pre>
Collections.sort(list); // âŒ ClassCastException
</pre>

<h3>â“ Which is preferred in real projects?</h3>
<p class="ok">âœ” Comparator (more flexible and cleaner)</p>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>Use Comparator for flexibility</li>
    <li>Use method references (<code>Comparator.comparing</code>)</li>
    <li>Keep <code>compareTo()</code> consistent with <code>equals()</code></li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>âŒ Donâ€™t return <code>this.age - other.age</code> (overflow risk)</li>
    <li>âŒ Donâ€™t mix inconsistent ordering logic</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    Comparable defines the natural ordering of a class by implementing
    <code>compareTo()</code> inside the class, whereas Comparator defines external,
    custom orderings using <code>compare()</code>. Comparator is more flexible and
    preferred when multiple sorting strategies are required.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>One natural order â†’ Comparable</strong><br>
    <strong>Multiple / custom orders â†’ Comparator</strong>
</blockquote>
<div class="divider"></div>


<h2 id="23-section">2ï¸âƒ£3ï¸âƒ£ Why sorting a List of Objects may fail?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Sorting fails if the objects <strong>do not implement Comparable</strong>
    and <strong>no Comparator is provided</strong>.
</blockquote>

<h2>ğŸ”¹ How sorting works internally</h2>

<p>When you call:</p>

<pre>
Collections.sort(list);
</pre>

<p>Java does <strong>one of these</strong>:</p>

<ul>
    <li>Uses <code>compareTo()</code> if elements implement <code>Comparable</code></li>
    <li>Uses <code>Comparator.compare()</code> if a <code>Comparator</code> is provided</li>
</ul>

<p class="note">
    If <strong>neither exists</strong>, Java has <strong>no way to compare objects</strong>.
</p>

<h2>ğŸ”¹ The Failure Scenario âŒ</h2>

<h3>Class without Comparable</h3>

<pre>
class User {
    int age;
}
</pre>

<h3>Sorting attempt</h3>

<pre>
List&lt;User&gt; users = List.of(new User(), new User());
Collections.sort(users); // âŒ Runtime error
</pre>

<h3>Exception thrown</h3>

<pre>
java.lang.ClassCastException:
User cannot be cast to java.lang.Comparable
</pre>

<p class="warn">
    Java tries to cast <code>User</code> to <code>Comparable</code> and fails.
</p>

<h2>ğŸ”¹ Why Java cannot guess comparison logic</h2>

<p>For objects, Java cannot assume:</p>

<ul>
    <li>Should it sort by age?</li>
    <li>name?</li>
    <li>id?</li>
    <li>creation time?</li>
</ul>

<p class="note">
    Ordering is <strong>domain-specific</strong>, so <strong>you must define it</strong>.
</p>

<h2>ğŸ”¹ Correct Solutions âœ…</h2>

<h3>âœ… Solution 1: Implement Comparable (Natural Order)</h3>

<pre>
class User implements Comparable&lt;User&gt; {
    int age;

    @Override
    public int compareTo(User other) {
        return Integer.compare(this.age, other.age);
    }
}
</pre>

<pre>
Collections.sort(users); // âœ… works
</pre>

<ul>
    <li class="ok">âœ” Use when there is one natural order</li>
</ul>

<h3>âœ… Solution 2: Provide a Comparator (Preferred)</h3>

<pre>
Collections.sort(users, Comparator.comparing(User::getAge));
</pre>

<p>Java 8+</p>

<pre>
users.sort(Comparator.comparing(User::getAge));
</pre>

<ul>
    <li class="ok">âœ” More flexible</li>
    <li class="ok">âœ” Does not modify the class</li>
    <li class="ok">âœ” Industry-preferred</li>
</ul>

<h2>ğŸ”¹ Another Common Reason Sorting Fails (INTERVIEW TRAP)</h2>

<h3>âŒ Inconsistent comparison logic</h3>

<pre>
compareTo() inconsistent with equals()
</pre>

<p>This can cause:</p>

<ul>
    <li>Incorrect ordering</li>
    <li>TreeSet / TreeMap bugs</li>
    <li>Duplicate entries</li>
</ul>

<h2>ğŸ”¹ Special Case: <code>null</code> elements âŒ</h2>

<pre>
List&lt;Integer&gt; list = Arrays.asList(3, null, 1);
Collections.sort(list); // âŒ NullPointerException
</pre>

<h3>Fix</h3>

<pre>
list.sort(Comparator.nullsLast(Integer::compareTo));
</pre>

<h2>ğŸ”¹ Summary Table (Interview Favorite)</h2>

<table>
    <tr>
        <th>Situation</th>
        <th>Result</th>
    </tr>
    <tr>
        <td>Objects not Comparable</td>
        <td class="warn">âŒ ClassCastException</td>
    </tr>
    <tr>
        <td>Comparator not provided</td>
        <td class="warn">âŒ Sorting fails</td>
    </tr>
    <tr>
        <td>Null elements present</td>
        <td class="warn">âŒ NullPointerException</td>
    </tr>
    <tr>
        <td>Valid Comparable / Comparator</td>
        <td class="ok">âœ… Sorting works</td>
    </tr>
</table>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    Sorting a list of objects may fail if the objects do not implement
    <code>Comparable</code> and no <code>Comparator</code> is provided.
    Java requires explicit comparison logic to order objects, otherwise it
    throws a <code>ClassCastException</code> at runtime.
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    <strong>Objects need comparison logic to be sorted</strong><br>
    <strong>Comparator &gt; Comparable in real projects</strong>
</blockquote>

<div class="divider"></div>


<h2 id="24-section">2ï¸âƒ£4ï¸âƒ£ How does <code>Collections.unmodifiableList()</code> work?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Collections.unmodifiableList()</code> returns a
    <strong>read-only wrapper</strong> around the original list.
    Any attempt to modify the list through the wrapper throws
    <strong>UnsupportedOperationException</strong>.
</blockquote>

<h2>ğŸ”¹ What it actually does (IMPORTANT)</h2>

<pre>
List&lt;String&gt; original = new ArrayList&lt;&gt;();
List&lt;String&gt; readonly = Collections.unmodifiableList(original);
</pre>

<ul>
    <li>Java creates a <strong>wrapper object</strong></li>
    <li>Wrapper <strong>delegates read methods</strong> to the original list</li>
    <li>Wrapper <strong>overrides modification methods</strong> to throw exceptions</li>
</ul>

<p class="note">
    ğŸ“Œ <strong>No data is copied</strong>.
</p>

<h2>ğŸ”¹ Internal Behavior (Conceptual)</h2>

<pre>
class UnmodifiableList&lt;E&gt; extends AbstractList&lt;E&gt; {
    final List&lt;E&gt; list;

    public E get(int index) {
        return list.get(index);
    }

    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
}
</pre>

<h2>ğŸ”¹ Key Point (INTERVIEW TRAP)</h2>

<blockquote>
    â— <strong>It is NOT immutable</strong>
</blockquote>

<pre>
original.add("A");
System.out.println(readonly); // [A]
</pre>

<ul>
    <li class="ok">âœ” Underlying list changes are visible</li>
    <li class="warn">âŒ Wrapper only blocks modification through itself</li>
</ul>

<h2>ğŸ”¹ What throws <code>UnsupportedOperationException</code></h2>

<pre>
readonly.add("X");     // âŒ
readonly.remove(0);    // âŒ
readonly.clear();      // âŒ
</pre>

<h2>ğŸ”¹ What is allowed</h2>

<pre>
readonly.get(0);        // âœ…
readonly.size();        // âœ…
readonly.contains("A");// âœ…
</pre>

<h2>ğŸ”¹ Why Java designed it this way</h2>

<ul>
    <li>Avoid expensive copying</li>
    <li>Provide <strong>defensive read-only views</strong></li>
    <li>Protect APIs from accidental modification</li>
</ul>

<h2>ğŸ”¹ Real-World Use Cases (VERY IMPORTANT)</h2>

<h3>âœ… Defensive programming</h3>

<pre>
public List&lt;User&gt; getUsers() {
    return Collections.unmodifiableList(users);
}
</pre>

<p>Prevents callers from mutating internal state.</p>

<h3>âœ… Configuration exposure</h3>

<pre>
return Collections.unmodifiableList(configList);
</pre>

<h2>ğŸ”¹ Common Interview Traps</h2>

<h3>â“ Is it thread-safe?</h3>
<p class="warn">âŒ No</p>
<p class="ok">âœ” Thread safety depends on the underlying list</p>

<h3>â“ Does it make the list immutable?</h3>
<p class="warn">âŒ No</p>
<p class="ok">âœ” Only prevents modification via that reference</p>

<h3>â“ How to create a truly immutable list?</h3>

<pre>
List.of("A", "B", "C"); // Java 9+
</pre>

or

<pre>
Collections.unmodifiableList(new ArrayList&lt;&gt;(list));
</pre>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3>âœ… Doâ€™s</h3>
<ul>
    <li>âœ” Use for API safety</li>
    <li>âœ” Use defensive copying if immutability is required</li>
</ul>

<h3>âŒ Donâ€™ts</h3>
<ul>
    <li>âŒ Donâ€™t assume itâ€™s immutable</li>
    <li>âŒ Donâ€™t rely on it for thread safety</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œ<code>Collections.unmodifiableList()</code> returns a read-only wrapper
    around an existing list. It does not copy the data but overrides
    modification methods to throw <code>UnsupportedOperationException</code>,
    preventing changes through that reference.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Unmodifiable â‰  Immutable</strong>
</blockquote>
<div class="divider"></div>


<h2 id="25-section">2ï¸âƒ£5ï¸âƒ£ Why is <code>size()</code> O(1) in most collections?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Because Java collections maintain an <strong>internal counter</strong> that is updated
    whenever elements are added or removed, allowing <code>size()</code> to return the value
    directly in constant time.
</blockquote>

<h2>ğŸ”¹ How it works internally</h2>

<p>Most collections store an internal field like:</p>

<pre>
int size;
</pre>

<h3>Example: <code>ArrayList</code> (simplified)</h3>

<pre>
public class ArrayList&lt;E&gt; {
    private int size;

    public int size() {
        return size; // O(1)
    }

    public boolean add(E e) {
        elementData[size++] = e; // size updated
        return true;
    }

    public E remove(int index) {
        size--;
        // shift elements
    }
}
</pre>

<ul>
    <li class="ok">âœ” No traversal</li>
    <li class="ok">âœ” Constant-time access</li>
</ul>

<h2>ğŸ”¹ Collections where <code>size()</code> is O(1)</h2>

<table>
    <tr>
        <th>Collection</th>
        <th>Reason</th>
    </tr>
    <tr>
        <td>ArrayList</td>
        <td>Maintains internal size field</td>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>Maintains entry count</td>
    </tr>
    <tr>
        <td>HashSet</td>
        <td>Delegates to internal HashMap size</td>
    </tr>
    <tr>
        <td>LinkedList</td>
        <td>Maintains node count</td>
    </tr>
    <tr>
        <td>ConcurrentHashMap</td>
        <td>Uses internal counters (Java 8+)</td>
    </tr>
</table>

<h2>ğŸ”¹ Why this design matters (Performance)</h2>

<p>If <code>size()</code> were O(n), common patterns would become very expensive:</p>

<pre>
for (int i = 0; i &lt; list.size(); i++) {
    // disastrous if size() were O(n)
}
</pre>

<p class="note">
    ğŸ“Œ Java guarantees <code>size()</code> is cheap so loops and APIs remain efficient.
</p>

<h2>ğŸ”¹ Important Exception (INTERVIEW TRAP)</h2>

<h3>â— <code>size()</code> is NOT always O(1)</h3>

<ul>
    <li>Some data structures in other languages compute size dynamically</li>
    <li>Java <strong>streams are not collections</strong></li>
</ul>

<pre>
stream.count(); // O(n)
</pre>

<p>Streams must traverse elements to count them.</p>

<h2>ğŸ”¹ Concurrent Collections Note</h2>

<h3><code>ConcurrentHashMap.size()</code></h3>

<ul>
    <li>Java 7: expensive and approximate</li>
    <li>Java 8+: striped counters</li>
    <li class="ok">âœ” Effectively O(1), but slightly more overhead</li>
</ul>

<h2>ğŸ”¹ Why not compute size dynamically?</h2>

<ul>
    <li class="warn">âŒ Would make <code>size()</code> O(n)</li>
    <li class="warn">âŒ Break performance assumptions</li>
    <li class="warn">âŒ Hurt loops and APIs</li>
</ul>

<p>Instead:</p>

<ul>
    <li class="ok">âœ” Maintain a counter</li>
    <li class="ok">âœ” Update it on every modification</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œIn most Java collections, <code>size()</code> is O(1) because the collection maintains
    an internal counter that is incremented or decremented whenever elements are added or
    removed, allowing the size to be returned directly without traversal.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Collections store size â€” they donâ€™t compute it</strong>
</blockquote>

<div class="divider"></div>


<h2 id="26-section">2ï¸âƒ£6ï¸âƒ£ Why LinkedList uses more memory than ArrayList?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>LinkedList</code> uses more memory because each element is wrapped in a node
    containing the data <strong>plus references to the previous and next nodes</strong>,
    whereas <code>ArrayList</code> stores elements in a single contiguous array with minimal
    per-element overhead.
</blockquote>

<h2>ğŸ”¹ Internal Structure Comparison</h2>

<h3>ğŸŸ¦ ArrayList</h3>

<pre>
Object[] array
[ e0 | e1 | e2 | e3 ]
</pre>

<ul>
    <li>Single array reference</li>
    <li>Each slot holds only the element reference</li>
    <li class="ok">Minimal memory overhead per element</li>
</ul>

<h3>ğŸŸ¥ LinkedList</h3>

<pre>
Node
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  prev  |  item  | next â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>

<ul>
    <li>Each element is a separate Node object</li>
    <li>Stores:
        <ul>
            <li>item (data reference)</li>
            <li>prev reference</li>
            <li>next reference</li>
        </ul>
    </li>
    <li class="bad">3 references per element + object header</li>
</ul>

<h2>ğŸ”¹ Memory Breakdown (Approximate)</h2>
<p><em>64-bit JVM with compressed OOPs enabled</em></p>

<table>
    <tr>
        <th>Structure</th>
        <th>Approximate Memory Usage</th>
    </tr>
    <tr>
        <td>ArrayList (per element)</td>
        <td>1 reference â†’ ~4â€“8 bytes</td>
    </tr>
    <tr>
        <td>LinkedList (per element)</td>
        <td>
            Node header: ~12â€“16 bytes<br>
            item reference: ~4â€“8 bytes<br>
            prev reference: ~4â€“8 bytes<br>
            next reference: ~4â€“8 bytes
        </td>
    </tr>
</table>

<p class="note">
    ğŸ“Œ <strong>LinkedList typically uses 3â€“5Ã— more memory per element</strong> than ArrayList.
</p>

<h2>ğŸ”¹ Why LinkedList was designed this way</h2>

<ul>
    <li>Optimized for frequent insertions/removals in the middle</li>
    <li>No need to shift elements</li>
</ul>

<p>Trade-offs:</p>
<ul>
    <li class="bad">Extra objects and references</li>
    <li class="bad">Poor cache locality</li>
</ul>

<h2>ğŸ”¹ Performance Side Effects (Interview Gold)</h2>

<h3>Cache Locality</h3>

<ul>
    <li><strong>ArrayList</strong> â†’ contiguous memory â†’ CPU cache-friendly</li>
    <li><strong>LinkedList</strong> â†’ scattered nodes â†’ cache misses</li>
</ul>

<p class="note">
    ğŸ‘‰ Even sequential traversal is slower in <code>LinkedList</code>.
</p>

<h2>ğŸ”¹ Real-World Implication</h2>

<h3 class="bad">âŒ Bad Choice</h3>

<pre>
List&lt;Integer&gt; list = new LinkedList<>();
// large dataset
</pre>

<ul>
    <li>High memory consumption</li>
    <li>Slower traversal</li>
</ul>

<h3 class="ok">âœ… Better Choice (Most Cases)</h3>

<pre>
List&lt;Integer&gt; list = new ArrayList<>();
</pre>

<ul>
    <li>Memory efficient</li>
    <li>Cache-friendly</li>
    <li>Faster iteration</li>
</ul>

<h2>ğŸ”¹ When should you still use LinkedList?</h2>

<ul>
    <li>Frequent insertions/removals at head or tail</li>
    <li>Deque / queue semantics</li>
</ul>

<pre>
Deque&lt;Integer&gt; deque = new LinkedList<>();
</pre>

<p class="note">
    âš ï¸ In most cases, <strong>ArrayDeque</strong> is still a better choice.
</p>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œLinkedList uses more memory because each element is stored in a node containing the data
    along with references to the previous and next nodes, whereas ArrayList stores elements in
    a single array with minimal per-element overhead.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>ArrayList â†’ memory & cache efficient</strong><br>
    âŒ <strong>LinkedList â†’ heavy memory overhead</strong>
</blockquote>

<div class="divider"></div>


<h2 id="27-section">2ï¸âƒ£7ï¸âƒ£ When to use PriorityQueue?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Use <code>PriorityQueue</code> when elements must be processed based on
    <strong>priority rather than insertion order</strong>, and you need efficient
    access to the <strong>highest or lowest priority element</strong>.
</blockquote>

<h2>ğŸ”¹ What is PriorityQueue?</h2>

<pre>
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
</pre>

<ul>
    <li>Implements a <strong>min-heap</strong> by default</li>
    <li>The head element is the <strong>smallest (highest priority)</strong></li>
    <li class="bad">Not fully sorted â€” only the head is guaranteed</li>
</ul>

<h2>ğŸ”¹ Internal Data Structure</h2>

<pre>
Binary Heap (array-based)

        1
      /   \
     3     5
    / \   /
   7  9  8
</pre>

<ul>
    <li>Backed by an array</li>
    <li>Heap property maintained on insert/remove</li>
</ul>

<h2>ğŸ”¹ Time Complexity (Interview Favorite)</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>Time Complexity</th>
    </tr>
    <tr>
        <td>add() / offer()</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td>poll() / remove()</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td><strong>O(1)</strong></td>
    </tr>
    <tr>
        <td>Iteration</td>
        <td class="bad">Not sorted</td>
    </tr>
</table>

<h2>ğŸ”¹ Ordering Rules</h2>

<h3>Default (Natural Order)</h3>

<pre>
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
</pre>

<h3>Custom Priority (Comparator)</h3>

<pre>
PriorityQueue&lt;Task&gt; pq =
    new PriorityQueue&lt;&gt;(
        Comparator.comparing(Task::getPriority).reversed()
    );
</pre>

<h2>ğŸ”¹ Real-World Use Cases (VERY IMPORTANT)</h2>

<ul>
    <li><strong>Task scheduling</strong> (job priority)</li>
    <li><strong>Job processing systems</strong> (print queues, batch jobs)</li>
    <li><strong>Algorithms</strong> (Dijkstra, A*)</li>
    <li><strong>Top-K problems</strong> (top 10 scores, trending items)</li>
</ul>

<h2>ğŸ”¹ Example: Task Scheduler</h2>

<pre>
class Task {
    int priority;
    String name;
}

PriorityQueue&lt;Task&gt; pq =
    new PriorityQueue&lt;&gt;(Comparator.comparingInt(t -&gt; t.priority));

pq.add(new Task(1, "Low"));
pq.add(new Task(10, "High"));

System.out.println(pq.poll().name); // High processed first
</pre>

<h2>ğŸ”¹ Important Interview Traps</h2>

<ul>
    <li><strong>Is PriorityQueue sorted?</strong> âŒ No â€” only the head is guaranteed</li>
    <li><strong>Does iteration return sorted order?</strong> âŒ No</li>
    <li><strong>Is PriorityQueue thread-safe?</strong> âŒ No â†’ use <code>PriorityBlockingQueue</code></li>
</ul>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3 class="ok">âœ… Doâ€™s</h3>
<ul>
    <li>Use for priority-based processing</li>
    <li>Use <code>peek()</code> to inspect next element</li>
    <li>Provide Comparator for custom priority</li>
</ul>

<h3 class="bad">âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t assume sorted iteration</li>
    <li>Donâ€™t use for random access</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œPriorityQueue should be used when elements must be processed based on priority.
    It is implemented as a binary heap, providing O(log n) insertion and removal,
    and O(1) access to the highest or lowest priority element.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Priority matters â†’ PriorityQueue</strong><br>
    âŒ <strong>Order matters â†’ ArrayDeque / LinkedList</strong>
</blockquote>
<div class="divider"></div>


<h2 id="28-section">2ï¸âƒ£8ï¸âƒ£ Queue vs Deque?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    A <strong>Queue</strong> supports insertion at the tail and removal from the head (FIFO),
    whereas a <strong>Deque (Double-Ended Queue)</strong> supports insertion and removal
    <strong>at both ends</strong>.
</blockquote>

<h2>ğŸ”¹ 1ï¸âƒ£ Queue</h2>

<h3>What it represents</h3>
<ul>
    <li><strong>FIFO</strong> (First-In-First-Out)</li>
    <li>Insert at one end, remove from the other</li>
</ul>

<pre>
Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
q.offer(10);
q.offer(20);
q.poll(); // 10
</pre>

<h3>Core Operations</h3>

<table>
    <tr>
        <th>Operation</th>
        <th>Meaning</th>
    </tr>
    <tr>
        <td>offer()</td>
        <td>Insert at tail</td>
    </tr>
    <tr>
        <td>poll()</td>
        <td>Remove from head</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>View head</td>
    </tr>
</table>

<h3>Typical Use Cases</h3>
<ul>
    <li>Task queues</li>
    <li>Message processing</li>
    <li>Producerâ€“consumer patterns</li>
</ul>

<h2>ğŸ”¹ 2ï¸âƒ£ Deque (Double-Ended Queue)</h2>

<h3>What it represents</h3>
<ul>
    <li>Insert and remove from <strong>both front and back</strong></li>
    <li>Can behave as Queue, Stack, or Deque</li>
</ul>

<pre>
Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();
dq.addFirst(10);
dq.addLast(20);
dq.removeFirst(); // 10
dq.removeLast();  // 20
</pre>

<h3>Stack using Deque (Recommended)</h3>

<pre>
Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
stack.push(1);
stack.push(2);
stack.pop(); // 2
</pre>

<p class="ok">âœ” Replaces legacy <code>Stack</code></p>

<h2>ğŸ”¹ Operation Comparison</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>Queue</th>
        <th>Deque</th>
    </tr>
    <tr>
        <td>Insert front</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Insert back</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Remove front</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Remove back</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>FIFO support</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>LIFO support</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ Performance (ArrayDeque)</h2>

<ul>
    <li>Backed by a <strong>resizable array</strong></li>
    <li>End operations are <strong>O(1) amortized</strong></li>
    <li>Faster and more memory-efficient than <code>LinkedList</code></li>
</ul>

<div class="note">
    ğŸ“Œ <strong>ArrayDeque</strong> is preferred over <code>LinkedList</code>
    for both Queue and Deque use cases.
</div>

<h2>ğŸ”¹ Real-World Examples (Interview Gold)</h2>

<h3>Queue</h3>

<pre>
Queue&lt;Job&gt; jobs = new ArrayDeque&lt;&gt;();
</pre>

<ul>
    <li>Job scheduling</li>
    <li>Event pipelines</li>
</ul>

<h3>Deque</h3>

<pre>
Deque&lt;Page&gt; history = new ArrayDeque&lt;&gt;();
</pre>

<ul>
    <li>Undo / redo</li>
    <li>Sliding window problems</li>
    <li>Palindrome checks</li>
    <li>BFS / DFS algorithms</li>
</ul>

<h2>ğŸ”¹ Important Interview Traps</h2>

<ul>
    <li><strong>Is Deque always better than Queue?</strong> âœ” Functionally yes, âŒ conceptually no</li>
    <li><strong>Is Deque thread-safe?</strong> âŒ No â†’ use <code>ConcurrentLinkedDeque</code></li>
    <li><strong>Why not LinkedList?</strong> Higher memory overhead, slower traversal</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œA Queue supports FIFO operations with insertion at one end and removal at the other.
    A Deque extends this by allowing insertion and removal at both ends, enabling both queue
    and stack behavior. Deque is more flexible and commonly implemented using ArrayDeque.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>FIFO only â†’ Queue</strong><br>
    âœ” <strong>FIFO + LIFO / both ends â†’ Deque</strong><br>
    âœ” <strong>Stack replacement â†’ Deque (ArrayDeque)</strong>
</blockquote>

<div class="divider"></div>


<h2 id="29-section">2ï¸âƒ£9ï¸âƒ£ Why HashMap resize is expensive?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    HashMap resize is expensive because during resizing,
    <strong>all existing entries must be traversed, rehashed, and redistributed</strong>
    into a larger bucket array.
</blockquote>

<h2>ğŸ”¹ What triggers a resize?</h2>

<pre>
if (size &gt; capacity Ã— loadFactor) {
    resize();
}
</pre>

<ul>
    <li>Default initial capacity: <strong>16</strong></li>
    <li>Default load factor: <strong>0.75</strong></li>
</ul>

<p>Resize happens when:</p>

<pre>
entries &gt; 16 Ã— 0.75 = 12
</pre>

<h2>ğŸ”¹ What happens during resize (Java 8+)</h2>

<ol>
    <li>Capacity <strong>doubles</strong></li>
    <li>A new bucket array is created</li>
    <li><strong>Every existing entry is visited</strong></li>
    <li>Each entry is moved to:
        <ul>
            <li>the same index, or</li>
            <li><code>index + oldCapacity</code></li>
        </ul>
    </li>
</ol>

<pre>
Old bucket  â†’  New bucket
</pre>

<p><strong>â± Time Complexity = O(n)</strong></p>

<h2>ğŸ”¹ Why rehashing is unavoidable</h2>

<ul>
    <li>Bucket index depends on array size</li>
    <li>When capacity changes, index calculation changes</li>
    <li>Old bucket positions become invalid</li>
</ul>

<pre>
index = (n - 1) & hash;
</pre>

<h2>ğŸ”¹ Java 8 Optimization (Interview Bonus â­)</h2>

<ul>
    <li>Java 8 avoids recomputing full hash</li>
    <li>Uses a <strong>bit-level check</strong></li>
</ul>

<pre>
(hash & oldCapacity) == 0
</pre>

<ul>
    <li class="ok">âœ” Still O(n)</li>
    <li class="ok">âœ” Fewer operations per entry</li>
</ul>

<h2>ğŸ”¹ Performance Impact</h2>

<ul>
    <li>CPU spike during resize</li>
    <li>Memory allocation overhead</li>
    <li>Latency spikes in production systems</li>
</ul>

<h2>ğŸ”¹ Real-World Scenario (Production Issue)</h2>

<h3 class="bad">âŒ Bad practice</h3>

<pre>
Map&lt;String, User&gt; map = new HashMap&lt;&gt;();
</pre>

<ul>
    <li>Frequent resizing under load</li>
    <li>Unpredictable latency</li>
</ul>

<h3 class="ok">âœ… Best practice</h3>

<pre>
Map&lt;String, User&gt; map =
    new HashMap&lt;&gt;(expectedSize / 0.75f + 1);
</pre>

<p>âœ” Pre-sizing avoids resize cost</p>

<h2>ğŸ”¹ Interview Traps</h2>

<ul>
    <li><strong>Is resize thread-safe?</strong> âŒ No (<code>HashMap</code> is not thread-safe)</li>
    <li><strong>Does resize block operations?</strong> âœ” Yes (for that map instance)</li>
</ul>

<h2>ğŸ”¹ How ConcurrentHashMap handles resize</h2>

<ul>
    <li>Resizes <strong>incrementally</strong></li>
    <li>Multiple threads help move buckets</li>
    <li>No global pause</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œHashMap resize is expensive because it requires allocating a larger bucket array
    and redistributing all existing entries based on the new capacity. This process
    touches every entry, making resize an O(n) operation.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Pre-size HashMap to avoid resize cost</strong>
</blockquote>

<div class="divider"></div>


<h2 id="30-section">3ï¸âƒ£0ï¸âƒ£ What is load factor?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Load factor controls when a <code>HashMap</code> resizes.
    It represents how full the map is allowed to get before resizing occurs.
    The default load factor is <strong>0.75</strong>, which balances performance and memory usage.
</blockquote>

<h2>ğŸ”¹ Definition (Simple)</h2>

<pre>
load factor = threshold / capacity
</pre>

<p>Resize happens when:</p>

<pre>
size &gt; capacity Ã— loadFactor
</pre>

<h2>ğŸ”¹ Default Values</h2>

<table>
    <tr>
        <th>Property</th>
        <th>Value</th>
    </tr>
    <tr>
        <td>Initial capacity</td>
        <td>16</td>
    </tr>
    <tr>
        <td>Load factor</td>
        <td><strong>0.75</strong></td>
    </tr>
    <tr>
        <td>Resize threshold</td>
        <td>12</td>
    </tr>
</table>

<pre>
16 Ã— 0.75 = 12
</pre>

<p>â¡ï¸ On inserting the <strong>13th element</strong>, resize occurs.</p>

<h2>ğŸ”¹ Why 0.75 is the default (IMPORTANT)</h2>

<p>It is a <strong>sweet spot</strong> between memory usage and performance:</p>

<table>
    <tr>
        <th>Load Factor</th>
        <th>Effect</th>
    </tr>
    <tr>
        <td>0.5</td>
        <td>More memory, fewer collisions</td>
    </tr>
    <tr>
        <td>0.9</td>
        <td>Less memory, more collisions</td>
    </tr>
    <tr>
        <td><strong>0.75</strong></td>
        <td class="good">Balanced (default)</td>
    </tr>
</table>

<div class="note">
    ğŸ“Œ The default value was chosen based on extensive performance benchmarks.
</div>

<h2>ğŸ”¹ Impact of Load Factor</h2>

<h3>ğŸ”» Lower load factor (e.g., 0.5)</h3>
<ul>
    <li class="good">âœ” Fewer collisions</li>
    <li class="good">âœ” Faster lookups</li>
    <li class="bad">âŒ Higher memory usage</li>
</ul>

<h3>ğŸ”º Higher load factor (e.g., 0.9)</h3>
<ul>
    <li class="good">âœ” Lower memory usage</li>
    <li class="bad">âŒ More collisions</li>
    <li class="bad">âŒ Slower <code>get()</code></li>
</ul>

<h2>ğŸ”¹ Real-World Examples</h2>

<h3>High-performance cache</h3>
<pre>
new HashMap&lt;&gt;(1024, 0.5f);
</pre>

<h3>Memory-optimized storage</h3>
<pre>
new HashMap&lt;&gt;(1024, 0.9f);
</pre>

<h2>ğŸ”¹ Important Interview Trap</h2>

<p><strong>â“ Does load factor affect time complexity?</strong></p>

<ul>
    <li class="good">âœ” Indirectly</li>
    <li>Higher load factor â†’ more collisions</li>
    <li>More collisions â†’ slower access</li>
</ul>

<div class="note">
    Java 8+ uses treeification, so worst-case access becomes <strong>O(log n)</strong> instead of O(n).
</div>

<h2>ğŸ”¹ Best Practices (Interview Gold)</h2>

<ul>
    <li class="good">âœ” Pre-size your <code>HashMap</code></li>
    <li class="good">âœ” Use default 0.75 unless you have a reason</li>
    <li class="good">âœ” Tune load factor only for performance-critical systems</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œThe load factor in a HashMap controls how full the map can get before it resizes.
    The default value of 0.75 provides a good balance between memory usage and performance
    by limiting collisions while avoiding frequent resizing.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Load factor = resize trigger</strong><br>
    âœ” <strong>0.75 = best general-purpose choice</strong>
</blockquote>

<div class="divider"></div>


<h2 id="31-section">3ï¸âƒ£1ï¸âƒ£ Why initial capacity matters?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Initial capacity matters because it prevents frequent resizing and rehashing,
    which are expensive <strong>O(n)</strong> operations that can significantly impact performance.
</blockquote>

<h2>ğŸ”¹ What is initial capacity?</h2>

<pre>
Map&lt;String, User&gt; map = new HashMap&lt;&gt;(16);
</pre>

<ul>
    <li>Initial capacity = number of buckets</li>
    <li>Default capacity = <strong>16</strong></li>
    <li>Capacity always grows in <strong>powers of 2</strong></li>
</ul>

<h2>ğŸ”¹ How resizing is triggered</h2>

<pre>
resize when: size &gt; capacity Ã— loadFactor
</pre>

<p>With default values:</p>

<pre>
16 Ã— 0.75 = 12
</pre>

<p>â¡ï¸ On inserting the <strong>13th element</strong>, resize occurs and capacity becomes <strong>32</strong>.</p>

<h2>ğŸ”¹ Why resizing is expensive (Recap)</h2>

<p>When resizing happens:</p>

<ol>
    <li>A new bucket array is created</li>
    <li>All existing entries are traversed</li>
    <li>Entries are rehashed and redistributed</li>
</ol>

<p class="bad">â± Time complexity = O(n)</p>

<h2>ğŸ”¹ The Cost of Frequent Resizing</h2>

<h3>âŒ Without proper initial capacity</h3>

<pre>
Map&lt;String, User&gt; map = new HashMap&lt;&gt;();
</pre>

<ul>
    <li>Grows: 16 â†’ 32 â†’ 64 â†’ 128 â†’ â€¦</li>
    <li class="bad">Multiple rehashes</li>
    <li class="bad">CPU spikes</li>
    <li class="bad">Latency issues</li>
</ul>

<h3>âœ… With proper initial capacity</h3>

<pre>
int expectedSize = 10_000;
Map&lt;String, User&gt; map =
    new HashMap&lt;&gt;(expectedSize / 0.75f + 1);
</pre>

<ul>
    <li class="good">âœ” No resizing</li>
    <li class="good">âœ” Stable performance</li>
    <li class="good">âœ” Lower GC pressure</li>
</ul>

<h2>ğŸ”¹ Real-World Scenario (Interview Gold)</h2>

<h3>Cache initialization</h3>

<pre>
Map&lt;String, Session&gt; cache =
    new HashMap&lt;&gt;(5000);
</pre>

<p class="note">
    Without sizing, caches can stall under load due to repeated resizing and rehashing.
</p>

<h2>ğŸ”¹ Initial Capacity vs Load Factor</h2>

<table>
    <tr>
        <th>Factor</th>
        <th>Purpose</th>
    </tr>
    <tr>
        <td>Initial capacity</td>
        <td>Avoid resizing</td>
    </tr>
    <tr>
        <td>Load factor</td>
        <td>Control collision vs memory usage</td>
    </tr>
</table>

<p>ğŸ“Œ Both work together to balance performance and memory.</p>

<h2>ğŸ”¹ Interview Traps</h2>

<p><strong>â“ Does larger initial capacity always help?</strong></p>
<ul>
    <li class="bad">âŒ No â€” too large wastes memory</li>
</ul>

<p><strong>â“ Is this only for HashMap?</strong></p>
<ul>
    <li class="good">âœ” No â€” applies to HashSet, ConcurrentHashMap, etc.</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œInitial capacity matters because it determines how many entries a HashMap can hold
    before resizing occurs. Choosing an appropriate initial capacity avoids frequent
    resizing and rehashing, which are expensive O(n) operations and can significantly
    degrade performance.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Known size â†’ pre-size your map</strong><br>
    âŒ <strong>Unknown size â†’ default is fine</strong>
</blockquote>

<div class="divider"></div>


<h2 id="32-section">3ï¸âƒ£2ï¸âƒ£ Why Collections.sort() is stable?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Collections.sort()</code> is stable because it uses <strong>TimSort</strong>,
    a stable sorting algorithm that preserves the relative order of equal elements.
</blockquote>

<h2>ğŸ”¹ What does <em>stable sorting</em> mean?</h2>

<p>A <strong>stable sort</strong> guarantees:</p>

<blockquote>
    If two elements are equal according to comparison, their
    <strong>original order is preserved</strong>.
</blockquote>

<h3>Example</h3>

<pre>
User(id=1, age=30)
User(id=2, age=30)
</pre>

<p>After sorting by <code>age</code>:</p>

<pre>
User(id=1, age=30)
User(id=2, age=30)   // order preserved
</pre>

<h2>ğŸ”¹ What algorithm does <code>Collections.sort()</code> use?</h2>

<h3>Java 7+</h3>

<pre>
Collections.sort() â†’ TimSort
</pre>

<ul>
    <li class="good">âœ” Stable</li>
    <li>Hybrid of <strong>Merge Sort + Insertion Sort</strong></li>
    <li>Optimized for <strong>real-world, partially sorted data</strong></li>
</ul>

<h2>ğŸ”¹ Why TimSort is stable (Core Reason)</h2>

<ul>
    <li>TimSort merges <strong>already sorted runs</strong></li>
    <li>When two elements compare equal:</li>
    <ul>
        <li>The <strong>left element is chosen first</strong></li>
    </ul>
</ul>

<p class="good">ğŸ“Œ Equal elements are never reordered.</p>

<h2>ğŸ”¹ Code Example (Very Important)</h2>

<pre>
class User {
    int id;
    int age;
}
</pre>

<pre>
List&lt;User&gt; users = List.of(
    new User(1, 30),
    new User(2, 25),
    new User(3, 30)
);

users.sort(Comparator.comparing(u -&gt; u.age));
</pre>

<h3>Result</h3>

<pre>
User(2, 25)
User(1, 30)
User(3, 30)   // relative order preserved
</pre>

<p class="good">âœ” Stable behavior</p>

<h2>ğŸ”¹ Why stability matters in real systems</h2>

<h3>ğŸ”¥ Multi-level sorting</h3>

<pre>
users.sort(Comparator.comparing(User::getName));
users.sort(Comparator.comparing(User::getAge));
</pre>

<ul>
    <li>Final list is <strong>age-sorted</strong></li>
    <li>Users with the same age remain <strong>name-sorted</strong></li>
</ul>

<p class="note">
    Stability allows multi-criteria sorting without complex comparator chaining.
</p>

<h2>ğŸ”¹ What would happen if sorting were NOT stable?</h2>

<ul>
    <li class="bad">âŒ Earlier ordering would be lost</li>
    <li class="bad">âŒ Multi-level sorting would break</li>
    <li class="bad">âŒ UI lists could reorder unpredictably</li>
</ul>

<h2>ğŸ”¹ Time & Space Complexity</h2>

<table>
    <tr>
        <th>Property</th>
        <th>Value</th>
    </tr>
    <tr>
        <td>Time (avg / worst)</td>
        <td>O(n log n)</td>
    </tr>
    <tr>
        <td>Best case</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td>Stable</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Extra memory</td>
        <td>O(n)</td>
    </tr>
</table>

<h2>ğŸ”¹ Interview Traps</h2>

<p><strong>â“ Is <code>Arrays.sort()</code> also stable?</strong></p>

<ul>
    <li class="good">âœ” Objects â†’ Yes (TimSort)</li>
    <li class="bad">âŒ Primitives â†’ No (Dual-Pivot QuickSort)</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œ<code>Collections.sort()</code> is stable because it uses TimSort, a stable sorting
    algorithm that preserves the relative order of elements that compare equal. This
    is especially important for multi-level sorting scenarios.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Collections.sort(List)</strong> â†’ Stable<br>
    âœ” <strong>Arrays.sort(Object[])</strong> â†’ Stable<br>
    âŒ <strong>Arrays.sort(primitive[])</strong> â†’ Not stable
</blockquote>

<div class="divider"></div>


<h2 id="33-section">3ï¸âƒ£3ï¸âƒ£ Why Stream <code>.collect()</code> may be slower?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Stream.collect()</code> can be slower because it introduces
    <strong>extra abstraction overhead</strong>, <strong>lambda execution</strong>,
    and <strong>creation of intermediate objects</strong> compared to a plain loop.
</blockquote>

<h2>ğŸ”¹ What happens internally in <code>stream().collect()</code></h2>

<pre>
list.stream().collect(Collectors.toList());
</pre>

<p>Internally, this involves:</p>

<ul>
    <li>Creating a <strong>Stream pipeline</strong></li>
    <li>Creating <strong>lambda objects / method references</strong></li>
    <li>Repeated <strong>function calls</strong> (<code>accept</code>, <code>apply</code>, <code>combine</code>)</li>
    <li>Creating <strong>intermediate containers</strong></li>
    <li>Merging results (especially in <strong>parallel streams</strong>)</li>
</ul>

<p class="note">
    Each step adds overhead that a simple loop does not have.
</p>

<h2>ğŸ”¹ Key Reasons for Slower Performance</h2>

<h3>1ï¸âƒ£ Lambda & Function Call Overhead</h3>

<pre>
.filter(x -> x &gt; 10)
.map(x -> x * 2)
</pre>

<ul>
    <li>Each element passes through a <strong>Predicate</strong></li>
    <li>Then through a <strong>Function</strong></li>
    <li>Then through a <strong>Consumer</strong></li>
</ul>

<p class="bad">
    â¡ Multiple virtual calls per element â†’ slower than inline loop logic
</p>

<h3>2ï¸âƒ£ Intermediate Object Creation</h3>

<p>Collectors often create:</p>

<ul>
    <li>Temporary result containers</li>
    <li>Wrapper objects</li>
    <li>Accumulators</li>
</ul>

<pre>
Collectors.groupingBy(...)
</pre>

<p class="note">
    Creates Maps, Lists, and internal collectors â†’ more GC pressure
</p>

<h3>3ï¸âƒ£ Boxing / Unboxing (Big Performance Trap)</h3>

<pre>
IntStream.range(0, n)   // fast
Stream&lt;Integer&gt;        // boxing overhead
</pre>

<pre>
stream.map(x -> x * 2); // Integer â†’ int â†’ Integer
</pre>

<p class="bad">
    Loops avoid this overhead entirely.
</p>

<h3>4ï¸âƒ£ Parallel Stream Merge Cost</h3>

<pre>
list.parallelStream().collect(...)
</pre>

<ul>
    <li>Each thread builds a partial result</li>
    <li>Partial results must be <strong>merged</strong></li>
    <li>Extra synchronization and combine cost</li>
</ul>

<p class="bad">
    âŒ Often slower for small or medium-sized datasets
</p>

<h3>5ï¸âƒ£ CPU Cache & Branch Prediction</h3>

<ul>
    <li>Loops are <strong>CPU-friendly</strong></li>
    <li>Streams obscure control flow</li>
    <li>Harder for JIT to optimize predictably</li>
</ul>

<h2>ğŸ”¹ Loop vs Stream Example</h2>

<h3>âŒ Stream (more overhead)</h3>

<pre>
List&lt;Integer&gt; out =
    list.stream()
        .filter(x -> x &gt; 10)
        .map(x -> x * 2)
        .collect(Collectors.toList());
</pre>

<h3>âœ… Loop (fastest)</h3>

<pre>
List&lt;Integer&gt; out = new ArrayList<>();
for (int x : list) {
    if (x &gt; 10) {
        out.add(x * 2);
    }
}
</pre>

<ul>
    <li class="good">âœ” No lambdas</li>
    <li class="good">âœ” No pipeline</li>
    <li class="good">âœ” No extra objects</li>
</ul>

<h2>ğŸ”¹ When <code>collect()</code> is OK or Better</h2>

<ul>
    <li class="good">âœ” Code clarity and maintainability matter</li>
    <li class="good">âœ” Dataset is small or moderate</li>
    <li class="good">âœ” Parallelism is effective</li>
    <li class="good">âœ” I/O-bound or high-level logic</li>
</ul>

<h2>ğŸ”¹ When NOT to use <code>collect()</code></h2>

<ul>
    <li class="bad">âŒ Tight loops</li>
    <li class="bad">âŒ Low-latency code paths</li>
    <li class="bad">âŒ High-frequency processing</li>
    <li class="bad">âŒ Performance-critical sections</li>
</ul>

<h2>ğŸ”¹ Interview Trap</h2>

<p><strong>â“ Are streams always slower?</strong></p>

<ul>
    <li>âŒ No â€” JVM can optimize them</li>
    <li>âœ” Parallel streams may help for large CPU-heavy workloads</li>
</ul>

<blockquote>
    Streams trade <strong>raw speed</strong> for <strong>readability and safety</strong>.
</blockquote>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œ<code>Stream.collect()</code> can be slower because it introduces lambda execution,
    intermediate object creation, and pipeline overhead. While streams improve
    readability, a traditional loop is often faster in performance-critical code paths.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Readability â†’ Streams</strong><br>
    âœ” <strong>Performance-critical â†’ Loops</strong>
</blockquote>

<div class="divider"></div>


<h2 id="34-section">3ï¸âƒ£4ï¸âƒ£ Why <code>Map.keySet()</code> is backed by map?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Map.keySet()</code> returns a <strong>backed view</strong> of the map so that
    <strong>changes in the map are reflected in the key set and changes in the key set affect the map</strong>,
    ensuring consistency without copying data.
</blockquote>

<h2>ğŸ”¹ What does â€œbacked by the mapâ€ mean?</h2>

<pre>
Map&lt;String, Integer&gt; map = new HashMap<>();
map.put("A", 1);

Set&lt;String&gt; keys = map.keySet();
</pre>

<ul>
    <li><code>keys</code> is <strong>not a separate collection</strong></li>
    <li>It is a <strong>view</strong> over the mapâ€™s keys</li>
    <li>Both share the <strong>same underlying data</strong></li>
</ul>

<h2>ğŸ”¹ Proof with Examples (IMPORTANT)</h2>

<h3>1ï¸âƒ£ Change map â†’ keySet updates</h3>

<pre>
map.put("B", 2);
System.out.println(keys); // [A, B]
</pre>

<p class="good">âœ” Key set reflects map changes</p>

<h3>2ï¸âƒ£ Change keySet â†’ map updates</h3>

<pre>
keys.remove("A");
System.out.println(map); // {B=2}
</pre>

<p class="good">âœ” Removing from <code>keySet()</code> removes the entry from the map</p>

<h2>ğŸ”¹ Why Java designed it this way</h2>

<h3>1ï¸âƒ£ No data duplication (Memory Efficient)</h3>
<ul>
    <li>Copying keys would waste memory</li>
    <li>Backed view avoids extra storage</li>
</ul>

<h3>2ï¸âƒ£ Always consistent</h3>
<ul>
    <li>Map and keySet can <strong>never go out of sync</strong></li>
    <li>One source of truth</li>
</ul>

<h3>3ï¸âƒ£ Efficient iteration</h3>

<pre>
for (String key : map.keySet()) {
    // efficient traversal
}
</pre>

<p>No temporary collection creation.</p>

<h2>ğŸ”¹ What operations are allowed?</h2>

<h3 class="good">âœ… Allowed</h3>

<pre>
keys.remove(key);   // removes from map
keys.clear();       // clears map
keys.contains(key);
</pre>

<h3 class="bad">âŒ Not allowed</h3>

<pre>
keys.add("X"); // UnsupportedOperationException
</pre>

<p>
    <strong>Why?</strong><br>
    A key cannot exist in a map <strong>without a value</strong>.
</p>

<h2>ğŸ”¹ Same concept applies to other views</h2>

<table>
    <tr>
        <th>Method</th>
        <th>View Type</th>
    </tr>
    <tr>
        <td><code>keySet()</code></td>
        <td>Keys view</td>
    </tr>
    <tr>
        <td><code>values()</code></td>
        <td>Values view</td>
    </tr>
    <tr>
        <td><code>entrySet()</code></td>
        <td>Key-value view</td>
    </tr>
</table>

<p>All of these are <strong>backed by the map</strong>.</p>

<h2>ğŸ”¹ Interview Trap âš ï¸</h2>

<p><strong>â“ Is <code>keySet()</code> thread-safe?</strong></p>

<ul>
    <li class="bad">âŒ No â€” depends on the underlying map</li>
    <li class="good">âœ” For <code>ConcurrentHashMap</code>, the view is thread-safe</li>
</ul>

<pre>
Map&lt;K,V&gt; map = new ConcurrentHashMap<>();
map.keySet(); // thread-safe view
</pre>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œ<code>Map.keySet()</code> returns a backed view of the map, not a copy. This ensures
    memory efficiency and consistencyâ€”any change in the map is reflected in the key set
    and vice versa. Java uses this design to avoid duplication and keep collections synchronized.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Views reflect source changes</strong><br>
    âœ” <strong>No copying, only delegation</strong>
</blockquote>

<div class="divider"></div>


<h2 id="35-section">3ï¸âƒ£5ï¸âƒ£ entrySet() vs keySet()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <strong><code>entrySet()</code> is more efficient</strong> when you need both keys and values
    because it avoids an <strong>extra lookup</strong> that
    <code>keySet()</code> + <code>get()</code> performs.
</blockquote>

<h2>ğŸ”¹ What each one returns</h2>

<pre>
map.keySet();    // Set&lt;K&gt;
map.entrySet();  // Set&lt;Map.Entry&lt;K, V&gt;&gt;
</pre>

<ul>
    <li><strong><code>keySet()</code></strong> â†’ keys only</li>
    <li><strong><code>entrySet()</code></strong> â†’ key and value together</li>
</ul>

<p>Both return <strong>backed views</strong> of the map.</p>

<h2>ğŸ”¹ Why <code>entrySet()</code> is faster (IMPORTANT)</h2>

<h3 class="bad">âŒ Using <code>keySet()</code> (extra lookup)</h3>

<pre>
for (K key : map.keySet()) {
    V value = map.get(key);  // extra lookup
}
</pre>

<p><strong>What happens internally:</strong></p>
<ol>
    <li>Iterate over keys</li>
    <li>For each key â†’ hash + equals lookup again</li>
</ol>

<p>â± Cost: <strong>O(n) + n Ã— lookup</strong> â†’ unnecessary overhead</p>

<h3 class="good">âœ… Using <code>entrySet()</code> (single traversal)</h3>

<pre>
for (Map.Entry&lt;K, V&gt; e : map.entrySet()) {
    K key = e.getKey();
    V value = e.getValue();
}
</pre>

<ul>
    <li>Single traversal</li>
    <li>No additional lookup</li>
</ul>

<p>â± Cost: <strong>O(n)</strong> â€” optimal</p>

<h2>ğŸ”¹ Performance Comparison</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th>keySet()</th>
        <th>entrySet()</th>
    </tr>
    <tr>
        <td>Access key</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Access value</td>
        <td>âŒ requires get()</td>
        <td>âœ… direct</td>
    </tr>
    <tr>
        <td>Extra lookup</td>
        <td class="bad">Yes</td>
        <td class="good">No</td>
    </tr>
    <tr>
        <td>Best for iteration</td>
        <td>âŒ</td>
        <td class="good">âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Example (INTERVIEW GOLD)</h2>

<h3 class="bad">âŒ Inefficient logging</h3>

<pre>
for (String id : users.keySet()) {
    log(id + " â†’ " + users.get(id));
}
</pre>

<h3 class="good">âœ… Efficient & recommended</h3>

<pre>
for (Map.Entry&lt;String, User&gt; e : users.entrySet()) {
    log(e.getKey() + " â†’ " + e.getValue());
}
</pre>

<ul>
    <li>Faster</li>
    <li>Cleaner</li>
    <li>Less hashing</li>
</ul>

<h2>ğŸ”¹ When <code>keySet()</code> is still fine</h2>

<p>Use <code>keySet()</code> when:</p>

<ul>
    <li>You only need keys</li>
    <li>No value access required</li>
</ul>

<pre>
for (String key : map.keySet()) {
    validate(key);
}
</pre>

<h2>ğŸ”¹ Interview Traps</h2>

<p><strong>â“ Does this matter for small maps?</strong></p>
<ul>
    <li>Minor difference</li>
    <li>Still a <strong>best practice</strong></li>
</ul>

<p><strong>â“ HashMap vs TreeMap?</strong></p>
<ul>
    <li>Extra lookup is <strong>O(1)</strong> for HashMap</li>
    <li>Extra lookup is <strong>O(log n)</strong> for TreeMap</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>

<blockquote>
    â€œ<code>entrySet()</code> is preferred when iterating over both keys and values because it avoids
    an extra lookup. Using <code>keySet()</code> requires calling <code>get(key)</code> for each entry,
    which adds unnecessary overhead.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>

<blockquote>
    âœ” <strong>Keys + Values â†’ <code>entrySet()</code></strong><br>
    âœ” <strong>Keys only â†’ <code>keySet()</code></strong>
</blockquote>

<div class="divider"></div>


<h2 id="36-section">3ï¸âƒ£6ï¸âƒ£ Why entrySet() is faster?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <strong><code>entrySet()</code> is faster</strong> because it gives direct access to both the key
    and the value, whereas <code>keySet()</code> requires an extra <code>get(key)</code> lookup for
    every element.
</blockquote>

<h2>ğŸ”¹ What happens with <code>keySet()</code> âŒ</h2>

<pre>
for (K key : map.keySet()) {
    V value = map.get(key); // extra lookup
}
</pre>

<h3>Internally:</h3>
<ul>
    <li>Iterate over keys</li>
    <li>For each key â†’ compute <code>hashCode()</code></li>
    <li>Locate the bucket / tree node</li>
    <li>Compare keys using <code>equals()</code></li>
    <li>Fetch the value</li>
</ul>

<p class="bad">â¡ Extra hashing + equals checks for every entry</p>

<h2>ğŸ”¹ What happens with <code>entrySet()</code> âœ…</h2>

<pre>
for (Map.Entry&lt;K, V&gt; e : map.entrySet()) {
    K key = e.getKey();
    V value = e.getValue();
}
</pre>

<h3>Internally:</h3>
<ul>
    <li>Entry already contains both key and value</li>
    <li>No additional lookup</li>
    <li>Single traversal</li>
</ul>

<p class="good">â¡ Less work per element</p>

<h2>ğŸ”¹ Complexity Comparison</h2>

<table>
    <tr>
        <th>Approach</th>
        <th>Cost</th>
    </tr>
    <tr>
        <td><code>keySet()</code> + <code>get()</code></td>
        <td>O(n) + n Ã— lookup</td>
    </tr>
    <tr>
        <td><code>entrySet()</code></td>
        <td><strong>O(n)</strong></td>
    </tr>
</table>

<p>
    ğŸ“Œ For <strong>HashMap</strong> â†’ avoids extra O(1) hash lookup<br>
    ğŸ“Œ For <strong>TreeMap</strong> â†’ avoids extra O(log n) tree lookup (even more important)
</p>

<h2>ğŸ”¹ Real-World Example (Interview Gold)</h2>

<h3 class="bad">âŒ Inefficient</h3>
<pre>
for (String id : map.keySet()) {
    process(id, map.get(id));
}
</pre>

<h3 class="good">âœ… Efficient</h3>
<pre>
for (Map.Entry&lt;String, User&gt; e : map.entrySet()) {
    process(e.getKey(), e.getValue());
}
</pre>

<h2>ğŸ”¹ Important Interview Trap</h2>

<p><strong>â“ Does this matter for small maps?</strong></p>
<ul>
    <li>âœ” Performance difference may be small</li>
    <li>âœ” Still considered <strong>best practice</strong></li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    â€œ<code>entrySet()</code> is faster because it provides both the key and value directly.
    Using <code>keySet()</code> requires an additional <code>get(key)</code> lookup for every entry,
    adding unnecessary hashing and comparison overhead.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    âœ” <strong>Key + Value â†’ <code>entrySet()</code></strong><br>
    âœ” <strong>Key only â†’ <code>keySet()</code></strong>
</blockquote>

<div class="divider"></div>


<h2 id="37-section">3ï¸âƒ£7ï¸âƒ£ Why subList() can cause issues?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>subList()</code> returns a <strong>view backed by the original list</strong>, not a copy.
    Structural changes to either list can corrupt the other and lead to
    <strong>ConcurrentModificationException</strong> or unexpected behavior.
</blockquote>

<h2>ğŸ”¹ What <code>subList()</code> actually returns (IMPORTANT)</h2>

<pre>
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3, 4, 5));
List&lt;Integer&gt; sub = list.subList(1, 4); // [2, 3, 4]
</pre>

<ul>
    <li><code>sub</code> is <strong>not</strong> a new list</li>
    <li>It is a <strong>window (view)</strong> over the original list</li>
    <li>Both lists share the same underlying data and <code>modCount</code></li>
</ul>

<h2>ğŸ”¹ Changes ARE reflected both ways</h2>

<h3>Modify subList â†’ original list changes</h3>

<pre>
sub.remove(1);   // removes 3
System.out.println(list); // [1, 2, 4, 5]
</pre>

<p class="good">âœ” Expected behavior (view-based)</p>

<h3>Modify original list â†’ subList breaks</h3>

<pre>
list.remove(0); // removes 1
</pre>

<p class="bad">âš  subList is now invalid</p>

<h2>ğŸ”¹ The real problem: Structural modification âŒ</h2>

<pre>
list.add(99); // âŒ structural change
sub.get(0);   // ConcurrentModificationException
</pre>

<h3>Why this happens</h3>
<ul>
    <li><code>subList</code> assumes the original list structure remains unchanged</li>
    <li>Structural change updates <code>modCount</code></li>
    <li>Mismatch detected â†’ Java fails fast</li>
</ul>

<h2>ğŸ”¹ What counts as â€œstructural modificationâ€?</h2>

<h3 class="bad">âŒ Structural (unsafe)</h3>
<ul>
    <li><code>add()</code></li>
    <li><code>remove()</code></li>
    <li><code>clear()</code></li>
    <li>Resize operations</li>
</ul>

<h3 class="good">âœ… Non-structural (safe)</h3>

<pre>
list.set(2, 100); // safe
</pre>

<h2>ğŸ”¹ Common real-world bug (VERY IMPORTANT)</h2>

<pre>
List&lt;User&gt; page = users.subList(0, 10);

// somewhere else
users.removeIf(User::isInactive);

// later
page.forEach(System.out::println); // âŒ CME
</pre>

<p class="bad">â¡ Production crash waiting to happen</p>

<h2>ğŸ”¹ Why Java designed it this way</h2>

<h3>Benefits</h3>
<ul>
    <li>âœ” No copying (memory efficient)</li>
    <li>âœ” Very fast creation</li>
</ul>

<h3>Trade-off</h3>
<ul>
    <li>âŒ Fragile if list structure changes</li>
</ul>

<h2>ğŸ”¹ How to use <code>subList()</code> safely âœ…</h2>

<h3 class="good">Option 1: Defensive copy (BEST PRACTICE)</h3>

<pre>
List&lt;Integer&gt; safe =
    new ArrayList&lt;&gt;(list.subList(1, 4));
</pre>

<ul>
    <li>âœ” Independent list</li>
    <li>âœ” No side effects</li>
</ul>

<h3 class="good">Option 2: Avoid modifying original list</h3>
<ul>
    <li>Safe only if the original list is read-only</li>
    <li>No concurrent structural changes</li>
</ul>

<h2>ğŸ”¹ Interview Traps</h2>

<p><strong>â“ Is <code>subList()</code> thread-safe?</strong></p>
<ul>
    <li>âŒ No</li>
    <li>âœ” Same thread-safety as the original list</li>
</ul>

<p><strong>â“ Is <code>subList()</code> immutable?</strong></p>
<ul>
    <li>âŒ No</li>
    <li>âœ” Fully mutable view</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    â€œ<code>subList()</code> returns a view backed by the original list.
    Structural modifications to either the original list or the subList can
    invalidate the other and cause <code>ConcurrentModificationException</code>.
    To avoid issues, create a defensive copy when isolation is required.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    âœ” <strong>subList = view, not copy</strong><br>
    âœ” <strong>Structural change = danger</strong><br>
    âœ” <strong>Need safety â†’ new ArrayList(subList)</strong>
</blockquote>

<div class="divider"></div>


<h2 id="38-section">3ï¸âƒ£8ï¸âƒ£ How to safely remove elements while iterating?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Use <strong><code>Iterator.remove()</code></strong>, which removes the current element
    <strong>through the iterator itself</strong>, keeping the iteratorâ€™s internal state
    consistent and avoiding <code>ConcurrentModificationException</code>.
</blockquote>

<h2>ğŸ”¹ Why normal removal fails âŒ</h2>

<pre>
for (Integer x : list) {
    if (x &lt; 0) {
        list.remove(x); // âŒ ConcurrentModificationException
    }
}
</pre>

<h3>What goes wrong?</h3>
<ul>
    <li>Enhanced for-loop internally uses an <strong>Iterator</strong></li>
    <li><code>list.remove()</code> modifies the collection <strong>outside</strong> the iterator</li>
    <li>Iterator detects modification â†’ <strong>CME</strong></li>
</ul>

<h2>ğŸ”¹ Correct way: <code>Iterator.remove()</code> âœ…</h2>

<pre>
Iterator&lt;Integer&gt; it = list.iterator();
while (it.hasNext()) {
    if (it.next() &lt; 0) {
        it.remove(); // âœ… safe
    }
}
</pre>

<h3>Why this works</h3>
<ul>
    <li>Iterator updates the collection</li>
    <li>Iterator also updates its own <code>expectedModCount</code></li>
    <li>No mismatch â†’ no exception</li>
</ul>

<h2>ğŸ”¹ Java 8+ Cleaner Alternative</h2>

<h3 class="good"><code>removeIf()</code> (Recommended)</h3>

<pre>
list.removeIf(x -&gt; x &lt; 0);
</pre>

<ul>
    <li>âœ” Internally uses iterator safely</li>
    <li>âœ” Clean and readable</li>
</ul>

<h2>ğŸ”¹ Concurrent Collections Case</h2>

<h3>Using <code>CopyOnWriteArrayList</code></h3>

<pre>
CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList<>();
for (Integer x : list) {
    list.remove(x); // âœ… NO CME
}
</pre>

<p class="bad">âš  Note:</p>
<ul>
    <li>Writes are expensive (entire array is copied)</li>
    <li>Best for <strong>read-heavy</strong> scenarios</li>
</ul>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3 class="good">âœ… Doâ€™s</h3>
<ul>
    <li>Use <code>Iterator.remove()</code></li>
    <li>Prefer <code>removeIf()</code> when possible</li>
</ul>

<h3 class="bad">âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t call <code>collection.remove()</code> inside for-each</li>
    <li>Donâ€™t modify structure outside the iterator</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    â€œTo safely remove elements during iteration, use <code>Iterator.remove()</code>.
    This keeps the iterator consistent with the collection and prevents
    <code>ConcurrentModificationException</code>.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    âœ” <strong>Iteration + removal â†’ Iterator.remove()</strong><br>
    âœ” <strong>Functional style â†’ removeIf()</strong>
</blockquote>

<div class="divider"></div>


<h2 id="39-section">3ï¸âƒ£9ï¸âƒ£ Why HashMap is not thread-safe?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>HashMap</code> is not thread-safe because it uses <strong>no synchronization</strong>.
    Concurrent updates can corrupt its internal structure, leading to
    <strong>data loss, inconsistent reads, or infinite loops</strong>.
</blockquote>

<h2>ğŸ”¹ What â€œnot thread-safeâ€ really means</h2>
<ul>
    <li>Multiple threads can modify the map <strong>simultaneously</strong></li>
    <li>No locks, no atomic guarantees</li>
    <li>Internal state can become <strong>inconsistent</strong></li>
</ul>

<p><strong>Thread-safe â‰  logically correct under concurrency</strong></p>

<h2>ğŸ”¹ Internal Structure of HashMap (Quick Recap)</h2>

<pre>
Bucket Array
 â”œâ”€ Bucket 0 â†’ Node â†’ Node
 â”œâ”€ Bucket 1 â†’ null
 â”œâ”€ Bucket 2 â†’ Node
</pre>

<ul>
    <li>Each bucket may contain a linked list</li>
    <li>Or a Red-Black Tree (Java 8+)</li>
</ul>

<h2>ğŸ”¹ What goes wrong under concurrent access</h2>

<h3 class="bad">âŒ Scenario 1: Lost updates</h3>

<pre>
map.put("A", 1); // Thread 1
map.put("A", 2); // Thread 2
</pre>

<ul>
    <li>Both threads race</li>
    <li>Final value is unpredictable</li>
</ul>

<h3 class="bad">âŒ Scenario 2: Structural corruption during resize</h3>

<p>When <code>HashMap</code> resizes:</p>
<ul>
    <li>Capacity doubles</li>
    <li>Entries are redistributed</li>
</ul>

<pre>
Thread A â†’ resizing
Thread B â†’ resizing
</pre>

<p>Possible outcomes:</p>
<ul>
    <li>Broken pointers</li>
    <li>Cyclic linked lists</li>
</ul>

<p class="bad"><strong>ğŸ‘‰ Can cause infinite loops during get()</strong></p>

<h2>ğŸ”¹ Infamous Java 7 Bug</h2>

<pre>
while (true) {
    map.get(key); // may loop forever
}
</pre>

<p>Root cause:</p>
<ul>
    <li>Corrupted bucket chain</li>
    <li>Cyclic linked list created during concurrent resize</li>
</ul>

<h2>ğŸ”¹ Why reads are also unsafe</h2>

<ul>
    <li>No <code>volatile</code> visibility guarantees</li>
    <li>May read partially updated state</li>
    <li>Can see stale or corrupted data</li>
</ul>

<p><strong>Even <code>get()</code> is unsafe under concurrency</strong></p>

<h2>ğŸ”¹ Why Java didnâ€™t make HashMap synchronized</h2>

<h3>Design reasons</h3>
<ul>
    <li>âœ” Maximum single-thread performance</li>
    <li>âœ” Let developers choose concurrency model</li>
    <li>âœ” Avoid global lock overhead</li>
</ul>

<h2>ğŸ”¹ Correct Alternatives</h2>

<h3 class="good">âœ… ConcurrentHashMap (Recommended)</h3>

<pre>
Map&lt;K, V&gt; map = new ConcurrentHashMap<>();
</pre>

<ul>
    <li>CAS operations</li>
    <li>volatile memory visibility</li>
    <li>Bucket-level locking</li>
</ul>

<h3 class="bad">âš ï¸ Synchronized Map (Less scalable)</h3>

<pre>
Map&lt;K, V&gt; map = Collections.synchronizedMap(new HashMap<>());
</pre>

<ul>
    <li>Global lock</li>
    <li>Poor scalability under load</li>
</ul>

<h2>ğŸ”¹ Doâ€™s & Donâ€™ts</h2>

<h3 class="good">âœ… Doâ€™s</h3>
<ul>
    <li>Use <code>ConcurrentHashMap</code> in concurrent code</li>
    <li>Use atomic methods like <code>computeIfAbsent()</code></li>
</ul>

<h3 class="bad">âŒ Donâ€™ts</h3>
<ul>
    <li>Donâ€™t share <code>HashMap</code> across threads</li>
    <li>Donâ€™t assume reads are safe</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer (Say This)</h2>
<blockquote>
    â€œ<code>HashMap</code> is not thread-safe because it does not use synchronization.
    Concurrent modificationsâ€”especially during resizingâ€”can corrupt its internal
    structure, leading to lost updates, inconsistent reads, or infinite loops.â€
</blockquote>

<h2>ğŸ§  Golden Rule (Remember This)</h2>
<blockquote>
    âœ” <strong>HashMap â†’ single-threaded</strong><br>
    âœ” <strong>ConcurrentHashMap â†’ multi-threaded</strong>
</blockquote>

<div class="divider"></div>


<h2 id="40-section">4ï¸âƒ£0ï¸âƒ£ Why <code>Collections.emptyList()</code> is immutable?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Collections.emptyList()</code> is immutable because it returns a
    <strong>shared singleton instance</strong>. Immutability guarantees
    <strong>safety, thread-safety, and memory efficiency</strong>.
</blockquote>

<h2>ğŸ”¹ What <code>Collections.emptyList()</code> actually returns</h2>

<pre>
List&lt;String&gt; list = Collections.emptyList();
</pre>

<ul>
    <li>Returns a <strong>single shared instance</strong></li>
    <li>Same object reused everywhere</li>
    <li><strong>No new list is created</strong></li>
</ul>

<pre>
Collections.emptyList() == Collections.emptyList(); // true
</pre>

<h2>ğŸ”¹ Why immutability is required (Core Reason)</h2>

<h3>1ï¸âƒ£ Shared Singleton â†’ Must be Immutable</h3>

<pre>
List&lt;String&gt; a = Collections.emptyList();
List&lt;String&gt; b = Collections.emptyList();

a.add("X"); // imagine this was allowed âŒ
</pre>

<ul>
    <li><code>b</code> would also contain <code>"X"</code></li>
    <li>Global corruption across the JVM</li>
</ul>

<p class="bad"><strong>â¡ï¸ Immutability prevents shared-state bugs</strong></p>

<h3>2ï¸âƒ£ Memory Optimization</h3>

<ul>
    <li>No allocation per call</li>
    <li>No internal array</li>
    <li>No object duplication</li>
</ul>

<p class="good">âœ” Perfect for empty return values and defaults</p>

<h3>3ï¸âƒ£ Thread Safety (Bonus)</h3>

<ul>
    <li>Immutable objects are inherently thread-safe</li>
    <li>No synchronization required</li>
    <li>Safe to share across threads</li>
</ul>

<h2>ğŸ”¹ What happens if you try to modify it?</h2>

<pre>
List&lt;String&gt; list = Collections.emptyList();
list.add("A"); // âŒ UnsupportedOperationException
</pre>

<ul>
    <li>Fails fast</li>
    <li>Prevents misuse</li>
</ul>

<h2>ğŸ”¹ Internal Implementation (Simplified)</h2>

<pre>
static final List&lt;?&gt; EMPTY_LIST = new EmptyList&lt;&gt;();

class EmptyList&lt;E&gt; extends AbstractList&lt;E&gt; {
    public int size() { return 0; }
    public E get(int index) {
        throw new IndexOutOfBoundsException();
    }
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
}
</pre>

<h2>ğŸ”¹ emptyList() vs unmodifiableList()</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>emptyList()</th>
        <th>unmodifiableList()</th>
    </tr>
    <tr>
        <td>Backed by original list</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Truly immutable</td>
        <td>âœ… Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Shared singleton</td>
        <td>âœ… Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Memory efficient</td>
        <td>âœ… Best</td>
        <td>âŒ Depends</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3 class="good">âœ… Safe API return</h3>

<pre>
public List&lt;User&gt; getUsers() {
    return Collections.emptyList();
}
</pre>

<ul>
    <li>No null checks</li>
    <li>No accidental modification</li>
</ul>

<h3 class="bad">âŒ Bad practice</h3>

<pre>
return null; // causes NullPointerExceptions
</pre>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œ<code>Collections.emptyList()</code> is immutable because it returns a shared
    singleton instance. Immutability prevents global side effects, ensures thread
    safety, and saves memory by avoiding repeated object creation.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Shared instance â†’ must be immutable</strong><br>
    âœ” <strong>Empty collection â†’ use Collections.emptyList()</strong>
</blockquote>

<div class="divider"></div>


<h2 id="41-section">4ï¸âƒ£1ï¸âƒ£ When to use WeakHashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Use <strong>WeakHashMap</strong> when keys should be
    <strong>automatically removed once they are no longer strongly referenced</strong>
    elsewhere, allowing the <strong>Garbage Collector</strong> to reclaim memory.
</blockquote>

<h2>ğŸ”¹ What is <code>WeakHashMap</code>?</h2>

<pre>
Map&lt;Key, Value&gt; map = new WeakHashMap&lt;&gt;();
</pre>

<ul>
    <li>Keys are stored as <strong>weak references</strong></li>
    <li>Values are strongly referenced</li>
    <li>Entries are removed automatically when keys become unreachable</li>
</ul>

<h2>ğŸ”¹ How it works internally (IMPORTANT)</h2>

<ul>
    <li>Keys are wrapped in <code>WeakReference</code></li>
    <li>If a key has <strong>no strong references</strong> outside the map:</li>
</ul>

<ul>
    <li>Garbage Collector clears the weak reference</li>
    <li>Entry is removed using a reference queue</li>
</ul>

<pre>
Strong ref â†’ âŒ
Weak ref   â†’ âœ” GC eligible
</pre>

<h2>ğŸ”¹ What triggers removal?</h2>

<pre>
Key k = new Key();
map.put(k, "value");

k = null;     // remove strong reference
System.gc();  // entry becomes eligible for removal
</pre>

<p class="good">
â¡ï¸ Entry may disappear <strong>without calling remove()</strong>
</p>

<h2>ğŸ”¹ Why this is useful (Core Reason)</h2>

<h3>Prevents memory leaks</h3>

<ul>
    <li>Cache-like data structures</li>
    <li>Short-lived keys</li>
    <li>When you donâ€™t control key lifecycle</li>
</ul>

<h2>ğŸ”¹ Real-World Use Cases (INTERVIEW GOLD)</h2>

<h3 class="good">âœ… Metadata / Auxiliary Data</h3>

<pre>
WeakHashMap&lt;Object, Metadata&gt; metadata;
</pre>

<p>Attach metadata without preventing object GC.</p>

<h3 class="good">âœ… Automatic cache cleanup</h3>

<pre>
WeakHashMap&lt;Class&lt;?&gt;, Info&gt; classCache;
</pre>

<p>When classes are unloaded, cache entries vanish automatically.</p>

<h3 class="good">âœ… Listener / Observer mappings</h3>

<p>Avoid memory leaks when owners are garbage collected.</p>

<h2>ğŸ”¹ What NOT to use WeakHashMap for âŒ</h2>

<ul>
    <li>Primary data storage</li>
    <li>Business-critical mappings</li>
    <li>Anything that must stay until explicitly removed</li>
</ul>

<p class="bad">
Entries may disappear at any time after GC
</p>

<h2>ğŸ”¹ Important Characteristics & Interview Traps</h2>

<h3>â— Non-deterministic removal</h3>
<ul>
    <li>GC timing is unpredictable</li>
    <li>Never rely on immediate cleanup</li>
</ul>

<h3>â— equals() / hashCode() still matter</h3>
<ul>
    <li>Weak reference affects reachability, not equality</li>
</ul>

<h3>â— Not thread-safe</h3>

<pre>
Map&lt;K,V&gt; map = new WeakHashMap&lt;&gt;(); // âŒ not concurrent
</pre>

<p>External synchronization is required for multi-threaded access.</p>

<h2>ğŸ”¹ Comparison with Other Maps</h2>

<table>
    <tr>
        <th>Map Type</th>
        <th>Key Reference</th>
        <th>GC Behavior</th>
    </tr>
    <tr>
        <td>HashMap</td>
        <td>Strong</td>
        <td>âŒ No auto cleanup</td>
    </tr>
    <tr>
        <td><strong>WeakHashMap</strong></td>
        <td><strong>Weak</strong></td>
        <td>âœ… Auto cleanup</td>
    </tr>
    <tr>
        <td>IdentityHashMap</td>
        <td>Strong (==)</td>
        <td>âŒ</td>
    </tr>
    <tr>
        <td>ConcurrentHashMap</td>
        <td>Strong</td>
        <td>âŒ</td>
    </tr>
</table>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œ<code>WeakHashMap</code> should be used when keys should not prevent garbage
    collection. It stores keys as weak references, so once a key is no longer
    strongly referenced elsewhere, the entry is automatically removed by the
    garbage collector. This is ideal for caches and metadata without memory leaks.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Keys control lifetime â†’ WeakHashMap</strong><br>
    âŒ <strong>Critical data â†’ Never WeakHashMap</strong>
</blockquote>

<div class="divider"></div>


<h2 id="42-section">4ï¸âƒ£2ï¸âƒ£ Why modifying key breaks HashMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Because <code>HashMap</code> uses the keyâ€™s <strong>hashCode()</strong> to decide
    the bucket. If the key is modified after insertion, its hashCode changes and
    the entry ends up in the <strong>wrong bucket</strong>, making it unreachable.
</blockquote>

<h2>ğŸ”¹ How HashMap lookup works (Quick Recap)</h2>

<h3>Insertion</h3>
<pre>
map.put(key, value);
</pre>

<ul>
    <li><code>hashCode()</code> of the key is calculated</li>
    <li>Bucket index is derived</li>
    <li>Entry is stored in that bucket</li>
</ul>

<h3>Lookup</h3>
<pre>
map.get(key);
</pre>

<ul>
    <li><code>hashCode()</code> is calculated again</li>
    <li>Correct bucket is selected</li>
    <li><code>equals()</code> is used inside the bucket</li>
</ul>

<h2>ğŸ”¹ The Breaking Scenario âŒ</h2>

<pre>
class User {
    int id;   // mutable field

    @Override
    public int hashCode() {
        return id;
    }

    @Override
    public boolean equals(Object o) {
        return ((User) o).id == this.id;
    }
}
</pre>

<pre>
User u = new User();
u.id = 1;

map.put(u, "A");

u.id = 2;   // âŒ key modified

map.get(u); // âŒ returns null
</pre>

<h2>ğŸ”¹ What exactly went wrong?</h2>

<ul>
    <li>Entry stored under <strong>hashCode = 1</strong></li>
    <li>After modification, <strong>hashCode = 2</strong></li>
    <li>Lookup goes to a different bucket</li>
    <li>Entry exists but cannot be found</li>
</ul>

<p class="bad">â¡ï¸ Data is logically lost</p>

<h2>ğŸ”¹ Even Worse: Map Corruption</h2>

<ul>
    <li><code>containsKey()</code> returns false</li>
    <li><code>remove()</code> fails</li>
    <li>Duplicate keys may appear</li>
    <li>Memory leaks (entry can never be removed)</li>
</ul>

<h2>ğŸ”¹ Why HashMap does NOT rehash keys</h2>

<ul>
    <li>Detecting mutation is impossible</li>
    <li>Rehashing on mutation would be extremely expensive</li>
    <li>HashMap assumes keys are <strong>immutable while stored</strong></li>
</ul>

<h2>ğŸ”¹ Real-World Production Bug (VERY COMMON)</h2>

<pre>
Map&lt;User, Session&gt; sessions = new HashMap&lt;&gt;();
</pre>

<p>
If <code>User</code> fields change:
</p>

<ul>
    <li>Sessions become unreachable</li>
    <li>Cache grows indefinitely</li>
    <li>Memory leak occurs</li>
</ul>

<h2>ğŸ”¹ Correct Practices âœ…</h2>

<h3 class="good">âœ” Use immutable keys</h3>
<pre>
final class User {
    private final int id;
}
</pre>

<h3 class="good">âœ” Use only immutable fields in hashCode()</h3>
<pre>
Objects.hash(id);
</pre>

<h3 class="bad">âŒ Donâ€™t do this</h3>
<ul>
    <li>Donâ€™t use setters on key fields</li>
    <li>Donâ€™t include mutable collections in hashCode()</li>
</ul>

<h2>ğŸ”¹ Interview Traps</h2>

<h3>â“ Does TreeMap have the same issue?</h3>
<p class="good">âœ” Yes â€” it relies on compareTo / Comparator</p>

<h3>â“ Does ConcurrentHashMap fix this?</h3>
<p class="bad">âŒ No â€” key immutability rule still applies</p>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œModifying a key after it is inserted into a HashMap breaks the map because the
    keyâ€™s hashCode changes. HashMap uses hashCode to locate the bucket, so after
    modification, lookups go to the wrong bucket and the entry becomes unreachable.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Keys must be immutable</strong><br>
    âŒ <strong>Mutable keys break hash-based collections</strong>
</blockquote>

<div class="divider"></div>


<h2 id="43-section">4ï¸âƒ£3ï¸âƒ£ peek() vs element()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <strong><code>peek()</code></strong> returns <code>null</code> if the queue is empty,
    while <strong><code>element()</code></strong> throws a
    <code>NoSuchElementException</code>.
</blockquote>

<h2>ğŸ”¹ What each method does</h2>

<h3><code>peek()</code></h3>
<pre>
Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
Integer x = q.peek();   // returns null if empty
</pre>

<ul>
    <li>Retrieves <strong>but does not remove</strong> the head</li>
    <li>No exception if empty</li>
    <li class="good">Safe for conditional checks</li>
</ul>

<h3><code>element()</code></h3>
<pre>
Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
Integer x = q.element(); // throws exception if empty
</pre>

<ul>
    <li>Retrieves <strong>but does not remove</strong> the head</li>
    <li>Throws <code>NoSuchElementException</code> if empty</li>
    <li class="bad">Strict contract</li>
</ul>

<h2>ğŸ”¹ Behavior Comparison</h2>

<table>
    <tr>
        <th>Aspect</th>
        <th><code>peek()</code></th>
        <th><code>element()</code></th>
    </tr>
    <tr>
        <td>Empty queue</td>
        <td>Returns <code>null</code></td>
        <td>Throws exception</td>
    </tr>
    <tr>
        <td>Exception</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Removes element</td>
        <td>âŒ No</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Typical use</td>
        <td>Safe / optional</td>
        <td>Guaranteed presence</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Usage</h2>

<h3 class="good">âœ… Use <code>peek()</code> when empty is expected</h3>
<pre>
while (queue.peek() != null) {
    process(queue.poll());
}
</pre>

<ul>
    <li>Background workers</li>
    <li>Non-blocking logic</li>
</ul>

<h3 class="good">âœ… Use <code>element()</code> when empty is an error</h3>
<pre>
Order order = queue.element(); // must exist
</pre>

<ul>
    <li>Business rules</li>
    <li>Validation logic</li>
</ul>

<h2>ğŸ”¹ Important Interview Traps</h2>

<h3>â“ Can <code>peek()</code> return <code>null</code> for a real element?</h3>
<ul>
    <li>Most queues (<code>ArrayDeque</code>, <code>PriorityQueue</code>) do <strong>not</strong> allow nulls</li>
    <li class="good">So <code>null</code> safely means empty</li>
</ul>

<h3>â“ Related method pairs</h3>

<table>
    <tr>
        <th>Non-throwing</th>
        <th>Throwing</th>
    </tr>
    <tr>
        <td><code>peek()</code></td>
        <td><code>element()</code></td>
    </tr>
    <tr>
        <td><code>poll()</code></td>
        <td><code>remove()</code></td>
    </tr>
</table>

<h2>ğŸ¯ Perfect Interview Answer</h2>
<blockquote>
    â€œ<code>peek()</code> safely returns null when the queue is empty, while
    <code>element()</code> throws a <code>NoSuchElementException</code>.
    <code>peek()</code> is preferred when emptiness is expected, and
    <code>element()</code> is used when the presence of an element is guaranteed.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>
<blockquote>
    âœ” <strong>Uncertain empty â†’ <code>peek()</code></strong><br>
    âœ” <strong>Guaranteed element â†’ <code>element()</code></strong>
</blockquote>

<div class="divider"></div>


<h2 id="44-section">4ï¸âƒ£4ï¸âƒ£ Why ConcurrentHashMap iterators donâ€™t throw CME?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>ConcurrentHashMap</code> iterators do not throw
    <code>ConcurrentModificationException</code> because they are
    <strong>weakly consistent</strong> and allow concurrent modifications
    during iteration.
</blockquote>

<h2>ğŸ”¹ What â€œweakly consistentâ€ means</h2>

<ul>
    <li class="good">Never throws CME</li>
    <li class="warn">May reflect some concurrent updates</li>
    <li class="warn">May not reflect all updates</li>
    <li class="good">Always returns valid, non-corrupted data</li>
</ul>

<blockquote>
    Weakly consistent iterators prioritize <strong>availability and scalability</strong>,
    not a perfect snapshot.
</blockquote>

<h2>ğŸ”¹ How this differs from fail-fast iterators</h2>

<h3>Fail-fast (ArrayList, HashMap)</h3>
<ul>
    <li>Iterator stores <code>expectedModCount</code></li>
    <li>Structural modification â†’ mismatch</li>
    <li><strong>Throws CME immediately</strong></li>
</ul>

<h3>Weakly consistent (ConcurrentHashMap)</h3>
<ul>
    <li>No <code>modCount</code> checking</li>
    <li>Iteration continues safely during updates</li>
    <li><strong>No CME by design</strong></li>
</ul>

<h2>ğŸ”¹ Internal reason (Why CME is avoided)</h2>

<ul>
    <li>Uses <strong>CAS</strong>, <strong>volatile</strong>, and <strong>bucket-level locking</strong></li>
    <li>Allows reads and writes concurrently</li>
    <li>Does <strong>not</strong> lock the entire map during iteration</li>
</ul>

<blockquote>
    Throwing CME would require global locking and would destroy scalability,
    so Java intentionally disables fail-fast behavior here.
</blockquote>

<h2>ğŸ”¹ Example</h2>

<pre>
ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
map.put("A", 1);
map.put("B", 2);

for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {
    map.put("C", 3);   // âœ… No CME
    System.out.println(e);
}
</pre>

<ul>
    <li>"C" may appear in iteration</li>
    <li>Or may not appear</li>
    <li class="good">Iteration never crashes</li>
</ul>

<h2>ğŸ”¹ Guarantees</h2>

<h3 class="good">What you DO get</h3>
<ul>
    <li>No CME</li>
    <li>No corrupted entries</li>
    <li>Thread-safe traversal</li>
</ul>

<h3 class="warn">What you do NOT get</h3>
<ul>
    <li>No perfect snapshot</li>
    <li>No deterministic visibility of all updates</li>
</ul>

<h2>ğŸ”¹ Iterator comparison</h2>

<table>
    <tr>
        <th>Iterator Type</th>
        <th>CME</th>
        <th>Sees Updates</th>
        <th>Use Case</th>
    </tr>
    <tr>
        <td>Fail-fast</td>
        <td>âŒ Throws</td>
        <td>âŒ No</td>
        <td>Bug detection</td>
    </tr>
    <tr>
        <td>Weakly consistent</td>
        <td>âœ… No</td>
        <td>âš ï¸ Maybe</td>
        <td>High concurrency</td>
    </tr>
    <tr>
        <td>Snapshot (CopyOnWriteArrayList)</td>
        <td>âœ… No</td>
        <td>âŒ Never</td>
        <td>Read-heavy systems</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Importance</h2>

<ul>
    <li>Caches</li>
    <li>Session stores</li>
    <li>Rate limiters</li>
    <li>Metrics</li>
    <li>Microservices shared maps</li>
</ul>

<blockquote>
    In concurrent systems, <strong>availability matters more than a perfect snapshot</strong>.
</blockquote>

<h2>ğŸ¯ Perfect Interview Answer</h2>
<blockquote>
    â€œConcurrentHashMap iterators donâ€™t throw ConcurrentModificationException
    because they are weakly consistent. They allow concurrent modifications
    during iteration, may reflect some updates, but always maintain a safe and
    consistent view without locking the entire map.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>
<blockquote>
    âœ” <strong>Fail-fast â†’ bug detection</strong><br>
    âœ” <strong>Weakly consistent â†’ concurrency & scalability</strong>
</blockquote>

<div class="divider"></div>


<h2 id="45-section">4ï¸âƒ£5ï¸âƒ£ When to use Spliterator?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Use a <strong>Spliterator</strong> when you need <strong>efficient parallel traversal
    and splitting</strong> of a data sourceâ€”especially for
    <strong>parallel stream processing</strong> or <strong>custom data structures</strong>.
</blockquote>

<h2>ğŸ”¹ What is a Spliterator?</h2>

<pre>
Spliterator&lt;T&gt;
</pre>

<ul>
    <li>Introduced in <strong>Java 8</strong></li>
    <li>Combines <strong>Splitting + Iterator</strong></li>
    <li>Designed to divide work for <strong>parallel execution</strong></li>
</ul>

<p>Streams internally rely on <code>Spliterator</code>.</p>

<h2>ğŸ”¹ Why Spliterator exists (Core Reason)</h2>

<h3>Iterator</h3>
<ul>
    <li>Sequential traversal</li>
    <li>Cannot split work</li>
</ul>

<h3>Spliterator</h3>
<ul>
    <li>Can <strong>split data into chunks</strong></li>
    <li>Enables parallelism without global locking</li>
</ul>

<h2>ğŸ”¹ Key Methods (IMPORTANT)</h2>

<pre>
tryAdvance(Consumer&lt;? super T&gt; action)
trySplit()
estimateSize()
characteristics()
</pre>

<h3>1ï¸âƒ£ <code>trySplit()</code> â€” the game changer</h3>

<ul>
    <li>Splits data into two parts</li>
    <li>Allows different threads to process different chunks</li>
</ul>

<pre>
Spliterator&lt;T&gt; part = spliterator.trySplit();
</pre>

<h2>ğŸ”¹ Characteristics (Interview Gold)</h2>

<table>
    <tr>
        <th>Characteristic</th>
        <th>Meaning</th>
    </tr>
    <tr>
        <td>SIZED</td>
        <td>Size known</td>
    </tr>
    <tr>
        <td>ORDERED</td>
        <td>Encounter order preserved</td>
    </tr>
    <tr>
        <td>SORTED</td>
        <td>Sorted source</td>
    </tr>
    <tr>
        <td>DISTINCT</td>
        <td>No duplicates</td>
    </tr>
    <tr>
        <td>IMMUTABLE</td>
        <td>Cannot change</td>
    </tr>
    <tr>
        <td>CONCURRENT</td>
        <td>Can change concurrently</td>
    </tr>
</table>

<p>These hints allow the JVM to <strong>optimize parallel execution</strong>.</p>

<h2>ğŸ”¹ How Streams use Spliterator internally</h2>

<pre>
list.parallelStream().forEach(...)
</pre>

<ol>
    <li>Obtain Spliterator from source</li>
    <li>Repeatedly call <code>trySplit()</code></li>
    <li>Distribute chunks to threads</li>
    <li>Process in parallel</li>
    <li>Merge results</li>
</ol>

<h2>ğŸ”¹ When YOU should use Spliterator directly</h2>

<ul>
    <li class="good"><strong>Custom collections</strong></li>
    <li class="good"><strong>Optimized parallel traversal</strong></li>
    <li class="good"><strong>Creating custom streams</strong></li>
    <li class="good"><strong>Controlling split strategy</strong></li>
</ul>

<pre>
StreamSupport.stream(mySpliterator, true);
</pre>

<h2>ğŸ”¹ Example</h2>

<pre>
List&lt;Integer&gt; list = List.of(1,2,3,4,5,6);

Spliterator&lt;Integer&gt; sp = list.spliterator();
Spliterator&lt;Integer&gt; sp2 = sp.trySplit();

sp.forEachRemaining(System.out::println);
sp2.forEachRemaining(System.out::println);
</pre>

<ul>
    <li>Data processed in two parts</li>
    <li>Ready for parallel execution</li>
</ul>

<h2>ğŸ”¹ Spliterator vs Iterator</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Iterator</th>
        <th>Spliterator</th>
    </tr>
    <tr>
        <td>Sequential traversal</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Parallel processing</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Splitting</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Characteristics</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Used by streams</td>
        <td>âŒ</td>
        <td>âœ…</td>
    </tr>
</table>

<h2>ğŸ”¹ When NOT to use Spliterator</h2>

<ul class="warn">
    <li>Simple loops</li>
    <li>Small collections</li>
    <li>I/O-bound tasks</li>
    <li>When streams already suffice</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>
<blockquote>
    â€œSpliterator is used to efficiently split a data source for parallel processing.
    It enables streams to divide work across threads using <code>trySplit()</code>
    and provides characteristics that help the JVM optimize execution.
    It is especially useful for parallel streams and custom collections.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>
<blockquote>
    âœ” <strong>Parallel traversal â†’ Spliterator</strong><br>
    âœ” <strong>Simple iteration â†’ Iterator / for-loop</strong>
</blockquote>

<div class="divider"></div>


<h2 id="46-section">4ï¸âƒ£6ï¸âƒ£ Why streams donâ€™t modify source collection?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Java Streams <strong>do not modify the source collection</strong> because they follow
    <strong>functional immutability</strong>. Stream operations are
    <strong>side-effect free</strong>, making them <strong>safe, predictable, and parallel-friendly</strong>.
</blockquote>

<h2>ğŸ”¹ What â€œfunctional immutabilityâ€ means</h2>

<ul>
    <li>Data is <strong>read</strong>, not changed</li>
    <li>Operations produce <strong>new results</strong></li>
    <li>The source collection remains untouched</li>
</ul>

<pre>
List&lt;Integer&gt; list = List.of(1, 2, 3);

list.stream()
    .map(x -&gt; x * 2)
    .toList();

System.out.println(list); // [1, 2, 3]
</pre>

<h2>ğŸ”¹ Core reasons streams donâ€™t modify the source</h2>

<h3>1ï¸âƒ£ Side-effect-free operations (MOST IMPORTANT)</h3>

<ul>
    <li>Stateless</li>
    <li>Non-interfering</li>
</ul>

<pre>
.map()
.filter()
.collect()
</pre>

<p>They <strong>transform data</strong> rather than mutating it, following
functional-programming principles.</p>

<h3>2ï¸âƒ£ Safe parallel execution</h3>

<pre>
list.parallelStream()
    .map(x -&gt; x * 2)
    .toList();
</pre>

<ul>
    <li>No race conditions</li>
    <li>No locks required</li>
    <li>Thread-safe by design</li>
</ul>

<p><strong>Immutability enables parallelism.</strong></p>

<h3>3ï¸âƒ£ Predictable behavior</h3>

<ul>
    <li>No hidden side effects</li>
    <li>No order-dependent bugs</li>
    <li>Easier debugging</li>
</ul>

<blockquote>
    Same input â†’ Same output
</blockquote>

<h3>4ï¸âƒ£ Separation of concerns</h3>

<table>
    <tr>
        <th>Collection</th>
        <th>Stream</th>
    </tr>
    <tr>
        <td>Stores data</td>
        <td>Processes data</td>
    </tr>
    <tr>
        <td>Mutable</td>
        <td>Immutable view</td>
    </tr>
    <tr>
        <td>State-based</td>
        <td>Computation-based</td>
    </tr>
</table>

<h2>ğŸ”¹ What happens if you modify the source inside a stream?</h2>

<pre>
list.stream().forEach(x -&gt; list.add(x)); // âŒ
</pre>

<ul class="bad">
    <li>ConcurrentModificationException</li>
    <li>Undefined behavior</li>
</ul>

<p>Streams assume the source is <strong>not structurally modified</strong> during traversal.</p>

<h2>ğŸ”¹ Correct way to â€œmodifyâ€ data with streams</h2>

<h3 class="bad">âŒ Wrong (mutation)</h3>

<pre>
list.stream().forEach(x -&gt; x++);
</pre>

<h3 class="good">âœ… Right (transformation)</h3>

<pre>
List&lt;Integer&gt; newList =
    list.stream()
        .map(x -&gt; x + 1)
        .toList();
</pre>

<ul>
    <li>Original list unchanged</li>
    <li>New transformed list created</li>
</ul>

<h2>ğŸ”¹ Real-World Example</h2>

<pre>
List&lt;Order&gt; discounted =
    orders.stream()
          .map(Order::applyDiscount)
          .toList();
</pre>

<ul>
    <li>Original data intact</li>
    <li>Predictable business logic</li>
    <li>Safe in concurrent systems</li>
</ul>

<h2>ğŸ”¹ Interview Trap</h2>

<h3>â“ Can <code>forEach()</code> modify objects?</h3>

<ul>
    <li class="good">âœ” Object state can change</li>
    <li class="bad">âŒ Collection structure must not change</li>
</ul>

<pre>
stream.forEach(user -&gt; user.setActive(true)); // allowed
</pre>

<p>The collection reference itself remains unchanged.</p>

<h2>ğŸ¯ Perfect Interview Answer</h2>
<blockquote>
    â€œJava Streams donâ€™t modify the source collection because they follow functional
    immutability. Stream operations are designed to be side-effect free, which makes
    them safe, predictable, and suitable for parallel execution.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>
<blockquote>
    âœ” <strong>Streams transform data</strong><br>
    âŒ <strong>Streams donâ€™t mutate collections</strong>
</blockquote>

<div class="divider"></div>


<h2 id="47-section">4ï¸âƒ£7ï¸âƒ£ toList() vs collect()?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>Stream.toList()</code> (Java 16+) returns an <strong>immutable list</strong>,
    while <code>collect(Collectors.toList())</code> returns a
    <strong>mutable list</strong> (usually an <code>ArrayList</code>).
</blockquote>

<h2>ğŸ”¹ <code>Stream.toList()</code> (Java 16+)</h2>

<pre>
List&lt;Integer&gt; list =
    stream.toList();
</pre>

<h3>Characteristics</h3>
<ul>
    <li class="good">âœ” Immutable</li>
    <li class="good">âœ” Cleaner &amp; expressive</li>
    <li class="good">âœ” Prevents accidental modification</li>
    <li>âœ” May use optimized internal implementation</li>
</ul>

<pre>
list.add(10); // âŒ UnsupportedOperationException
</pre>

<p>ğŸ“Œ Conceptually similar to <code>List.of(...)</code></p>

<h2>ğŸ”¹ <code>collect(Collectors.toList())</code></h2>

<pre>
List&lt;Integer&gt; list =
    stream.collect(Collectors.toList());
</pre>

<h3>Characteristics</h3>
<ul>
    <li class="good">âœ” Mutable</li>
    <li>âœ” Usually returns <code>ArrayList</code></li>
    <li>âœ” Java 8+ compatible</li>
    <li>âœ” Safe for modifications</li>
</ul>

<pre>
list.add(10); // âœ… works
</pre>

<h2>ğŸ”¹ Behavior Comparison</h2>

<table>
    <tr>
        <th>Feature</th>
        <th><code>toList()</code></th>
        <th><code>Collectors.toList()</code></th>
    </tr>
    <tr>
        <td>Java version</td>
        <td>16+</td>
        <td>8+</td>
    </tr>
    <tr>
        <td>Mutability</td>
        <td>âŒ Immutable</td>
        <td>âœ… Mutable</td>
    </tr>
    <tr>
        <td>Implementation guarantee</td>
        <td>âŒ Unspecified</td>
        <td>âŒ Unspecified</td>
    </tr>
    <tr>
        <td>Readability</td>
        <td>âœ… Cleaner</td>
        <td>âš  More verbose</td>
    </tr>
    <tr>
        <td>Modification allowed</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
</table>

<h2>ğŸ”¹ Why Java introduced <code>toList()</code></h2>

<p>Before Java 16:</p>

<pre>
collect(Collectors.toList())
</pre>

<ul>
    <li>Mutability was unclear</li>
    <li>Verbose syntax</li>
    <li>Encouraged accidental modification</li>
</ul>

<p>
    <code>toList()</code> makes the intent explicit:
</p>

<blockquote>
    â€œI want a <strong>result</strong>, not a modifiable container.â€
</blockquote>

<h2>ğŸ”¹ Real-World Usage Guidelines</h2>

<h3 class="good">âœ… Use <code>toList()</code> when:</h3>
<ul>
    <li>Read-only result is required</li>
    <li>Returning data from APIs</li>
    <li>Functional-style pipelines</li>
</ul>

<pre>
return users.stream()
            .filter(User::isActive)
            .toList();
</pre>

<h3 class="good">âœ… Use <code>collect(Collectors.toList())</code> when:</h3>
<ul>
    <li>You need to modify the list later</li>
    <li>Working with Java 8â€“15</li>
    <li>Performance-critical mutation is required</li>
</ul>

<pre>
List&lt;User&gt; users =
    stream.collect(Collectors.toList());
users.add(extraUser);
</pre>

<h2>ğŸ”¹ Interview Traps âš ï¸</h2>

<h3>â“ Is <code>toList()</code> always faster?</h3>
<ul>
    <li>âŒ Not guaranteed</li>
    <li>âœ” Often optimized internally</li>
</ul>

<h3>â“ Is <code>Collectors.toList()</code> guaranteed to return <code>ArrayList</code>?</h3>
<ul>
    <li>âŒ No (but usually does)</li>
</ul>

<h3>â“ Can you force mutability with <code>toList()</code>?</h3>

<pre>
new ArrayList&lt;&gt;(stream.toList());
</pre>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œ<code>Stream.toList()</code> (Java 16+) returns an immutable list, while
    <code>collect(Collectors.toList())</code> returns a mutable list.
    <code>toList()</code> is preferred for read-only results, and
    <code>collect()</code> is used when modification or backward compatibility is required.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Read-only result â†’ <code>toList()</code></strong><br>
    âœ” <strong>Need mutation â†’ <code>Collectors.toList()</code></strong>
</blockquote>

<div class="divider"></div>


<h2 id="48-section">4ï¸âƒ£8ï¸âƒ£ Why TreeSet rejects null?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    <code>TreeSet</code> rejects <code>null</code> because it must
    <strong>compare elements</strong> to maintain sorted order, and
    <strong>null cannot be compared</strong> using <code>compareTo()</code>
    or a <code>Comparator</code>.
</blockquote>

<h2>ğŸ”¹ How <code>TreeSet</code> works internally</h2>
<ul>
    <li>Backed by a <strong>Red-Black Tree</strong></li>
    <li>Maintains elements in <strong>sorted order</strong></li>
    <li>Uses:
        <ul>
            <li>Natural ordering (<code>Comparable</code>)</li>
            <li>or a custom <code>Comparator</code></li>
        </ul>
    </li>
</ul>

<p>
Every insertion requires a <strong>comparison</strong> to determine where the
element fits in the tree.
</p>

<h2>ğŸ”¹ What goes wrong with <code>null</code> âŒ</h2>

<h3>Natural ordering case</h3>

<pre>
TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
set.add(null); // âŒ NullPointerException
</pre>

<p>Internally:</p>

<pre>
null.compareTo(existingElement); // âŒ
</pre>

<p>
<code>null</code> has <strong>no <code>compareTo()</code> method</strong>.
</p>

<h3>Comparator case (still unsafe)</h3>

<pre>
TreeSet&lt;String&gt; set =
    new TreeSet&lt;&gt;(Comparator.naturalOrder());
set.add(null); // âŒ NullPointerException
</pre>

<p>
Even comparators usually delegate to:
</p>

<pre>
a.compareTo(b); // null causes NPE
</pre>

<p>
Unless null handling is explicitly implemented (which <code>TreeSet</code>
intentionally disallows).
</p>

<h2>ğŸ”¹ Why Java disallows <code>null</code> instead of special-casing it</h2>

<ul>
    <li class="bad">âŒ Avoids ambiguous ordering</li>
    <li class="bad">âŒ Prevents fragile tree-balancing logic</li>
    <li class="good">âœ” Keeps ordering rules simple and consistent</li>
    <li class="good">âœ” Fails fast instead of hiding bugs</li>
</ul>

<p>
ğŸ“Œ Orderingâ€”not hashingâ€”is the core responsibility of <code>TreeSet</code>.
</p>

<h2>ğŸ”¹ Comparison with other Set implementations</h2>

<table>
    <tr>
        <th>Collection</th>
        <th>Allows null?</th>
        <th>Reason</th>
    </tr>
    <tr>
        <td>HashSet</td>
        <td>âœ… Yes (one)</td>
        <td>Uses hashing, not comparison</td>
    </tr>
    <tr>
        <td>LinkedHashSet</td>
        <td>âœ… Yes</td>
        <td>Same as HashSet + order</td>
    </tr>
    <tr>
        <td>TreeSet</td>
        <td>âŒ No</td>
        <td>Requires comparison for sorting</td>
    </tr>
</table>

<h2>ğŸ”¹ Interview Trap âš ï¸</h2>

<h3>â“ Can we allow <code>null</code> using a custom comparator?</h3>
<ul>
    <li>âœ” A comparator <em>could</em> theoretically handle nulls</li>
    <li class="bad">âŒ <code>TreeSet</code> still throws <code>NullPointerException</code></li>
    <li class="good">âœ” Java intentionally forbids null for safety</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œ<code>TreeSet</code> rejects null because it maintains elements in sorted
    order using comparison. Since null cannot be compared using
    <code>compareTo()</code> or a Comparator, allowing it would break ordering
    and tree invariants.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Sorted collections need comparability</strong><br>
    âŒ <strong><code>null</code> has no natural order</strong>
</blockquote>

<div class="divider"></div>


<h2 id="49-section">4ï¸âƒ£9ï¸âƒ£ When to use ConcurrentSkipListMap?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<blockquote>
    Use <strong>ConcurrentSkipListMap</strong> when you need a <strong>thread-safe, sorted map</strong> with
    <strong>non-blocking reads</strong>, <strong>scalable concurrency</strong>, and <strong>O(log n)</strong> operations.
</blockquote>

<h2>ğŸ”¹ What is <code>ConcurrentSkipListMap</code>?</h2>

<pre>
ConcurrentSkipListMap&lt;Integer, String&gt; map =
        new ConcurrentSkipListMap&lt;&gt;();
</pre>

<ul>
    <li>Thread-safe</li>
    <li><strong>Sorted</strong> (natural order or Comparator)</li>
    <li>Implements <code>ConcurrentNavigableMap</code></li>
    <li>Backed by a <strong>Skip List</strong>, not a tree</li>
</ul>

<h2>ğŸ”¹ Why Skip List (not Red-Black Tree)?</h2>

<h3>Skip List properties</h3>

<ul>
    <li>Multi-level linked structure</li>
    <li>Probabilistic balancing</li>
    <li>No global locks</li>
    <li>Easier to make concurrent than trees</li>
</ul>

<pre>
Level 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
Level 2 â”€â”€â”€â”€â”€â–¶        â–¶
Level 1 â–¶   â–¶   â–¶   â–¶
Base   â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶â–¶
</pre>

<ul>
    <li class="good">âœ” Efficient search</li>
    <li class="good">âœ” Concurrent updates</li>
    <li class="good">âœ” No complex rotations</li>
</ul>

<h2>ğŸ”¹ Time Complexity (IMPORTANT)</h2>

<table>
    <tr>
        <th>Operation</th>
        <th>Complexity</th>
    </tr>
    <tr>
        <td><code>get()</code></td>
        <td><strong>O(log n)</strong></td>
    </tr>
    <tr>
        <td><code>put()</code></td>
        <td><strong>O(log n)</strong></td>
    </tr>
    <tr>
        <td><code>remove()</code></td>
        <td><strong>O(log n)</strong></td>
    </tr>
    <tr>
        <td><code>firstKey()</code> / <code>lastKey()</code></td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td>Range queries</td>
        <td><strong>Efficient</strong></td>
    </tr>
</table>

<h2>ğŸ”¹ Why not <code>TreeMap</code>?</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>TreeMap</th>
        <th>ConcurrentSkipListMap</th>
    </tr>
    <tr>
        <td>Thread-safe</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Sorted</td>
        <td>âœ…</td>
        <td>âœ…</td>
    </tr>
    <tr>
        <td>Concurrency</td>
        <td>âŒ Needs sync</td>
        <td>âœ… Lock-free reads</td>
    </tr>
    <tr>
        <td>CME</td>
        <td>âŒ Yes</td>
        <td>âŒ No</td>
    </tr>
    <tr>
        <td>Iterator</td>
        <td>Fail-fast</td>
        <td><strong>Weakly consistent</strong></td>
    </tr>
</table>

<h2>ğŸ”¹ Why not <code>ConcurrentHashMap</code>?</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>ConcurrentHashMap</th>
        <th>ConcurrentSkipListMap</th>
    </tr>
    <tr>
        <td>Sorted</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Lookup</td>
        <td>O(1)</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td>Range queries</td>
        <td>âŒ No</td>
        <td>âœ… Yes</td>
    </tr>
    <tr>
        <td>Use case</td>
        <td>Fast access</td>
        <td>Ordered access</td>
    </tr>
</table>

<h2>ğŸ”¹ Real-World Use Cases (INTERVIEW GOLD)</h2>

<ul>
    <li><strong>Leaderboards</strong> (<code>tailMap()</code>, <code>headMap()</code>)</li>
    <li><strong>Time-based indexing</strong> (timestamps â†’ events)</li>
    <li><strong>Rate limiting windows</strong></li>
    <li><strong>Ordered caches</strong> in concurrent systems</li>
</ul>

<h2>ğŸ”¹ Iteration Behavior</h2>

<pre>
for (var e : map.entrySet()) {
    // no CME
}
</pre>

<ul>
    <li class="good">âœ” Weakly consistent</li>
    <li class="good">âœ” Safe during concurrent updates</li>
    <li class="bad">âŒ Not a strict snapshot</li>
</ul>

<h2>ğŸ”¹ When NOT to use it âŒ</h2>

<ul>
    <li>âŒ Ordering not required</li>
    <li>âŒ Constant-time lookup needed</li>
    <li>âŒ Small datasets (overhead unnecessary)</li>
</ul>

<h2>ğŸ¯ Perfect Interview Answer</h2>

<blockquote>
    â€œ<code>ConcurrentSkipListMap</code> should be used when you need a
    thread-safe sorted map with scalable concurrency. It is implemented
    using a skip list, providing O(log n) operations, weakly consistent
    iterators, and efficient range queries.â€
</blockquote>

<h2>ğŸ§  Golden Rule</h2>

<blockquote>
    âœ” <strong>Concurrent + Sorted â†’ ConcurrentSkipListMap</strong><br>
    âœ” <strong>Concurrent + Fast lookup â†’ ConcurrentHashMap</strong>
</blockquote>

<div class="divider"></div>


<h2 id="50-section">5ï¸âƒ£0ï¸âƒ£ Biggest Collections Interview Rule</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
<div class="note">
<b>Choose collection based on access pattern, not habit.</b>
</div>

<div class="footer">
<h2>ğŸ§  FINAL INTERVIEW CLOSER</h2>
<div class="success">
â€œJava Collections are optimized data structures.  
The real skill lies in choosing the right collection based on lookup frequency, ordering, mutability, concurrency, and memory constraints.â€
</div>
</div>
<div class="divider"></div>
    <h2 id="51-section">â“ What is <code>Set</code>?</h2>
	<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <h3>Basic</h3>
    <p>
        <code>Set</code> is a collection that <strong>does not allow duplicate elements</strong>.
    </p>

    <pre>
Set&lt;String&gt; set = new HashSet&lt;&gt;();
set.add("A");
set.add("A"); // ignored
    </pre>

    <h3>Advanced</h3>
    <p>
        <code>Set</code> enforces uniqueness using
        <strong>equality contracts</strong>
        (<code>equals()</code> + <code>hashCode()</code>).
    </p>

    <div class="divider"></div>

    <h2>âš™ Real-Time Justification</h2>

    <ul>
        <li>Email IDs</li>
        <li>User roles</li>
        <li>Cache keys</li>
        <li>Unique tokens</li>
    </ul>

    <div class="divider"></div>

    <h2>âœ… Doâ€™s</h2>

    <div class="success">
        âœ” Override <code>equals()</code> &amp; <code>hashCode()</code><br>
        âœ” Use <code>Set</code> when uniqueness matters
    </div>

    <h2>âŒ Donâ€™ts</h2>

    <div class="danger">
        âŒ Donâ€™t rely on insertion order unless specified<br>
        âŒ Donâ€™t modify elements affecting <code>hashCode()</code>
    </div>
	<div class="divider"></div>
    <h2 id="52-section">â“ What is <code>HashSet</code>?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <h3>Basic</h3>
    <p>
        <code>HashSet</code> stores unique elements with
        <strong>no guaranteed order</strong>.
    </p>

    <pre>
Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
set.add(10);
set.add(20);
    </pre>

    <h3>Advanced</h3>
    <p>
        Internally backed by a <strong>HashMap</strong>,
        elements are keys and values are dummy objects.
    </p>

    <pre>
HashSet&lt;E&gt; â†’ HashMap&lt;E, Object&gt;
    </pre>

    <div class="divider"></div>

    <h2>âš™ Real-Time Justification</h2>

    <ul>
        <li>Fast lookups</li>
        <li>Duplicate elimination</li>
        <li>Permission sets</li>
    </ul>

    <div class="divider"></div>

    <h2>â± Performance</h2>

    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
        </tr>
        <tr>
            <td>add</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>remove</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>contains</td>
            <td>O(1)</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>â— Critical Advanced Rule</h2>

    <div class="note">
        <pre>
If equals() is true â†’ hashCode() MUST be same
        </pre>
        Violation of this rule leads to <strong>duplicate data bugs</strong>.
    </div>

    <h2>âœ… Doâ€™s</h2>

    <div class="success">
        âœ” Best choice for performance<br>
        âœ” Use immutable keys
    </div>

    <h2>âŒ Donâ€™ts</h2>

    <div class="danger">
        âŒ Donâ€™t expect ordering<br>
        âŒ Donâ€™t use mutable objects as keys
    </div>	
	<div class="divider"></div>
    <h2 id="53-section">â“ What is <code>LinkedHashSet</code>?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <h3>Basic</h3>
    <p>
        <code>LinkedHashSet</code> maintains
        <strong>insertion order</strong>
        while preventing duplicate elements.
    </p>

    <pre>
Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();
set.add("B");
set.add("A");
set.add("C");
    </pre>

    <p><strong>Output:</strong></p>

    <pre>
B A C
    </pre>

    <h3>Advanced</h3>
    <p>
        Internally backed by a <strong>LinkedHashMap</strong>,
        which maintains a doubly-linked list of entries.
    </p>

    <div class="divider"></div>

    <h2>âš™ Real-Time Justification</h2>

    <ul>
        <li>Recently used items</li>
        <li>Ordered logs</li>
        <li>UI selections</li>
    </ul>

    <div class="divider"></div>

    <h2>â± Performance</h2>

    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
        </tr>
        <tr>
            <td>add</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>remove</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>contains</td>
            <td>O(1)</td>
        </tr>
    </table>

    <p>
        <em>(Slightly slower than <code>HashSet</code> due to order maintenance)</em>
    </p>

    <h2>âœ… Doâ€™s</h2>

    <div class="success">
        âœ” Use when order matters<br>
        âœ” Good balance between speed and predictable ordering
    </div>

    <h2>âŒ Donâ€™ts</h2>

    <div class="danger">
        âŒ Donâ€™t use if ordering is irrelevant (use <code>HashSet</code>)
    </div>
	<div class="divider"></div>
    <h2 id="54-section">â“ What is <code>SortedSet</code>?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <h3>Basic</h3>
    <p>
        <code>SortedSet</code> maintains elements in
        <strong>sorted order</strong>.
    </p>

    <pre>
		SortedSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
		set.add(30);
		set.add(10);
		set.add(20);
    </pre>

    <p><strong>Output:</strong></p>

    <pre>
		10 20 30
    </pre>

    <h3>Advanced</h3>
    <p>
        Sorting is performed using:
    </p>

    <ul>
        <li><code>Comparable</code></li>
        <li><code>Comparator</code></li>
    </ul>

    <div class="divider"></div>

    <h2>âš™ Real-Time Justification</h2>

    <ul>
        <li>Ranking systems</li>
        <li>Sorted IDs</li>
        <li>Leaderboards</li>
    </ul>

    <div class="divider"></div>

    <h2>â— Important Rule</h2>

    <div class="danger">
        âŒ <strong><code>null</code> is NOT allowed</strong><br><br>
        Sorting requires comparison, and
        <code>null</code> cannot be compared.
    </div>

    <div class="divider"></div>

    <h2>â± Performance</h2>

    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
        </tr>
        <tr>
            <td>add</td>
            <td>O(log n)</td>
        </tr>
        <tr>
            <td>remove</td>
            <td>O(log n)</td>
        </tr>
        <tr>
            <td>search</td>
            <td>O(log n)</td>
        </tr>
    </table>

    <h2>âœ… Doâ€™s</h2>

    <div class="success">
        âœ” Use when natural sorting is required<br>
        âœ” Use <code>Comparator</code> for custom sorting
    </div>

    <h2>âŒ Donâ€™ts</h2>

    <div class="danger">
        âŒ Donâ€™t expect insertion order<br>
        âŒ Donâ€™t insert <code>null</code>
    </div>
<div class="divider"></div>
    <h2 id="55-section">â“ What is <code>NavigableSet</code>?</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <h3>Basic</h3>
    <p>
        <code>NavigableSet</code> extends <code>SortedSet</code> and adds
        <strong>navigation methods</strong>.
    </p>

    <pre>
		NavigableSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
		set.add(10);
		set.add(20);
		set.add(30);
    </pre>

    <h3>Advanced Navigation Methods</h3>

    <pre>
		set.lower(20);    // 10
		set.floor(20);    // 20
		set.higher(20);   // 30
		set.ceiling(20);  // 20
    </pre>

    <div class="divider"></div>

    <h2>âš™ Real-Time Justification</h2>

    <ul>
        <li>Time-based systems</li>
        <li>Nearest value lookup</li>
        <li>Range queries</li>
    </ul>

    <div class="divider"></div>

    <h2>Advanced Operations</h2>

    <pre>
		set.pollFirst(); // removes lowest
		set.pollLast();  // removes highest
    </pre>

    <h2>âœ… Doâ€™s</h2>

    <div class="success">
        âœ” Use when range queries are needed<br>
        âœ” Powerful for analytics
    </div>

    <h2>âŒ Donâ€™ts</h2>

    <div class="danger">
        âŒ Avoid if sorting is unnecessary (use <code>HashSet</code>)
    </div>

    <div class="divider"></div>

    <h2 id="56-section">ğŸ”¥ Overview (VERY IMPORTANT)</h2>
<a href="#features-overview" class="back-to-top-btn">â†‘ Back to Features</a>	
    <table>
        <tr>
            <th>Feature</th>
            <th>HashSet</th>
            <th>LinkedHashSet</th>
            <th>TreeSet</th>
        </tr>
        <tr>
            <td>Order</td>
            <td>âŒ No</td>
            <td>âœ… Insertion</td>
            <td>âœ… Sorted</td>
        </tr>
        <tr>
            <td>Null</td>
            <td>âœ… One</td>
            <td>âœ… One</td>
            <td>âŒ No</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>â­â­â­â­â­</td>
            <td>â­â­â­â­</td>
            <td>â­â­â­</td>
        </tr>
        <tr>
            <td>Internal</td>
            <td>HashMap</td>
            <td>LinkedHashMap</td>
            <td>Red-Black Tree</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Fast lookup</td>
            <td>Ordered unique</td>
            <td>Sorted unique</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>ğŸ¯ MOST ASKED INTERVIEW TRAPS</h2>

    <h3>â“ How does <code>TreeSet</code> detect duplicates?</h3>

    <div class="note">
        <pre>
			compareTo() == 0 â†’ duplicate
        </pre>
        (not <code>equals()</code>)
    </div>

    <h3>â“ Why modifying objects inside Set is dangerous?</h3>

    <div class="note">
        It changes <code>hashCode()</code> â†’
        the element becomes unreachable.
    </div>

    <h3>â“ Can HashSet store two objects with same <code>hashCode()</code>?</h3>

    <div class="success">
        âœ” Yes, if <code>equals()</code> returns false.
    </div>

    <div class="divider"></div>

    <h2>ğŸ§  INTERVIEW ONE-LINER SUMMARY</h2>

    <div class="note">
        Use <code>HashSet</code> for speed,
        <code>LinkedHashSet</code> for order, and
        <code>TreeSet</code> (via <code>SortedSet</code>/<code>NavigableSet</code>)
        for sorted and range-based operations.
    </div>	
	<div class="divider"></div>
    <h2 id="57-section">â“ What is <code>ConcurrentModificationException</code>?</h2>

    <p>
        <code>ConcurrentModificationException</code> is a
        <strong>runtime exception</strong> thrown when:
    </p>

    <div class="note">
        A collection is <strong>structurally modified</strong> while it is being
        iterated <strong>in an unsafe way</strong>.
    </div>

    <p><strong>Very important:</strong></p>
    <ul>
        <li>It is <strong>not about multithreading only</strong></li>
        <li>It can happen <strong>in a single thread</strong></li>
    </ul>

    <div class="divider"></div>

    <h2>ğŸ”¹ The Classic Failing Example</h2>

    <pre>
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));

for (Integer i : list) {
    if (i == 2) {
        list.remove(i);  // âŒ CME
    }
}
    </pre>

    <h3>â“ Why this fails</h3>
    <ul>
        <li>Enhanced <code>for</code> loop uses an <strong>Iterator</strong></li>
        <li>You modify the list <strong>directly</strong></li>
        <li>Iterator detects illegal modification â†’ throws CME</li>
    </ul>

    <div class="divider"></div>

    <h2>ğŸ”¹ Internal Working (VERY IMPORTANT)</h2>

    <h3>ğŸ”¹ <code>modCount</code> (The Key Concept)</h3>

    <p>
        Most Java collections maintain an internal counter:
    </p>

    <pre>
int modCount;
    </pre>

    <p>
        This counter increments when the collection is
        <strong>structurally modified</strong>:
    </p>

    <ul>
        <li><code>add()</code></li>
        <li><code>remove()</code></li>
        <li><code>clear()</code></li>
    </ul>

    <h3>ğŸ”¹ Iterator Stores Snapshot Value</h3>

    <pre>
expectedModCount = modCount;
    </pre>

    <p>On every call to:</p>

    <pre>
iterator.next()
    </pre>

    <p>Java checks:</p>

    <pre>
if (modCount != expectedModCount)
    throw new ConcurrentModificationException();
    </pre>

    <div class="note">
        ğŸ”¥ This is called <strong>Fail-Fast behavior</strong><br>
        Fail-fast means detecting bugs <strong>early</strong>, not allowing corrupted state.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ What is a â€œStructural Modificationâ€?</h2>

    <h3>âœ… Structural</h3>
    <ul>
        <li><code>add()</code></li>
        <li><code>remove()</code></li>
        <li><code>clear()</code></li>
        <li><code>addAll()</code></li>
    </ul>

    <h3>âŒ NOT Structural</h3>
    <ul>
        <li><code>set(index, value)</code></li>
        <li>Modifying object fields</li>
    </ul>

    <pre>
list.set(0, 100); // âœ… NO CME
    </pre>

    <div class="divider"></div>

    <h2>ğŸ”¹ Correct Ways to Avoid CME</h2>

    <h3>âœ… Option 1: Use <code>Iterator.remove()</code> (BEST PRACTICE)</h3>

    <pre>
Iterator&lt;Integer&gt; it = list.iterator();

while (it.hasNext()) {
    if (it.next() == 2) {
        it.remove();   // âœ… SAFE
    }
}
    </pre>

    <div class="success">
        Why safe?<br>
        Iterator updates <code>expectedModCount</code>.
    </div>

    <h3>âœ… Option 2: Use <code>ListIterator</code></h3>

    <pre>
ListIterator&lt;Integer&gt; it = list.listIterator();

while (it.hasNext()) {
    if (it.next() == 2) {
        it.remove();
        it.add(20);
    }
}
    </pre>

    <h3>âœ… Option 3: Remove After Iteration</h3>

    <pre>
list.removeIf(i -> i == 2);  // Java 8+
    </pre>

    <div class="success">
        âœ” Clean &nbsp; âœ” Safe &nbsp; âœ” Preferred in modern Java
    </div>

    <h3>âœ… Option 4: Iterate Over a Copy</h3>

    <pre>
for (Integer i : new ArrayList<>(list)) {
    if (i == 2) {
        list.remove(i);
    }
}
    </pre>

    <div class="note">
        âœ” Works<br>
        âŒ Extra memory usage
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ CME in Multi-Threading</h2>

    <pre>
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

Thread t1 = new Thread(() -> {
    for (Integer i : list) {
        System.out.println(i);
    }
});

Thread t2 = new Thread(() -> {
    list.add(10);
});
    </pre>

    <div class="note">
        CME can occur, but it is <strong>NOT a thread-safety guarantee</strong>.<br>
        It only detects modification, not race conditions.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Fail-Fast vs Fail-Safe</h2>

    <table>
        <tr>
            <th>Feature</th>
            <th>Fail-Fast</th>
            <th>Fail-Safe</th>
        </tr>
        <tr>
            <td>Throws CME</td>
            <td>âœ… Yes</td>
            <td>âŒ No</td>
        </tr>
        <tr>
            <td>Works on copy</td>
            <td>âŒ No</td>
            <td>âœ… Yes</td>
        </tr>
        <tr>
            <td>Thread-safe</td>
            <td>âŒ No</td>
            <td>âœ… Yes</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>Faster</td>
            <td>Slower</td>
        </tr>
    </table>

    <p><strong>Examples:</strong></p>
    <ul>
        <li><strong>Fail-Fast</strong> â†’ ArrayList, HashMap</li>
        <li><strong>Fail-Safe</strong> â†’ CopyOnWriteArrayList, ConcurrentHashMap</li>
    </ul>

    <div class="divider"></div>

    <h2>ğŸ”¹ Fail-Safe Example (No CME)</h2>

    <pre>
CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();

for (Integer i : list) {
    list.add(10);  // âœ… NO CME
}
    </pre>

    <div class="note">
        Iterator works on a <strong>snapshot copy</strong>.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Common Interview Traps</h2>

    <h3>â“ CME vs Multi-threading bug?</h3>
    <div class="danger">
        âŒ CME â‰  thread-safety<br>
        âœ” CME = best-effort detection
    </div>

    <h3>â“ Does CME always happen?</h3>
    <div class="note">
        âŒ No â€” it is <strong>best-effort</strong><br>
        âœ” JVM may or may not detect in all cases
    </div>

    <h3>â“ Why no CME with <code>set()</code>?</h3>
    <div class="note">
        Because it doesnâ€™t change collection size
        and is not a structural modification.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Perfect Interview Answer</h2>

    <div class="success">
        â€œConcurrentModificationException is thrown when a collection is
        structurally modified while being iterated in an unsafe way.
        Java collections are fail-fast and use an internal <code>modCount</code>
        to detect concurrent modifications. The correct way to modify during
        iteration is using <code>Iterator.remove()</code> or using concurrent
        collections like <code>CopyOnWriteArrayList</code>.â€
    </div>

    <div class="divider"></div>

    <h2>ğŸ§  Golden Rules</h2>

    <ul>
        <li>âœ” Never modify a collection directly inside a for-each loop</li>
        <li>âœ” Use <code>Iterator.remove()</code></li>
        <li>âœ” Prefer <code>removeIf()</code> in Java 8+</li>
        <li>âœ” CME â‰  thread-safety</li>
        <li>âœ” Fail-fast is for bug detection, not synchronization</li>
    </ul>	
	<div class="divider"></div>
	
    <h2>â“ What is <code>ConcurrentHashMap</code>?</h2>

    <p>
        <code>ConcurrentHashMap</code> is a
        <strong>thread-safe, highly concurrent Map</strong>
        designed for <strong>high-performance multi-threaded environments</strong>.
    </p>

    <ul>
        <li>âœ” Allows concurrent reads and writes</li>
        <li>âœ” Does <strong>NOT</strong> throw <code>ConcurrentModificationException</code></li>
        <li>âœ” Much faster than <code>Collections.synchronizedMap()</code></li>
    </ul>

    <div class="divider"></div>

    <h2>ğŸ”¹ Why NOT <code>HashMap</code> in Multi-threading?</h2>

    <div class="danger">
        <strong>Problems with HashMap:</strong>
        <ul>
            <li>Not thread-safe</li>
            <li>Data corruption</li>
            <li>Infinite loops (pre-Java 8)</li>
            <li><code>ConcurrentModificationException</code></li>
        </ul>
    </div>

    <pre>
Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
// âŒ Unsafe in multithreaded environment
    </pre>

    <div class="divider"></div>

    <h2>ğŸ”¹ Why NOT <code>synchronizedMap()</code>?</h2>

    <pre>
Map&lt;String, String&gt; map =
    Collections.synchronizedMap(new HashMap&lt;&gt;());
    </pre>

    <div class="danger">
        âŒ Single global lock<br>
        âŒ Only one thread at a time<br>
        âŒ Poor scalability
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Why <code>ConcurrentHashMap</code> is SPECIAL</h2>

    <pre>
ConcurrentHashMap&lt;String, User&gt; map = new ConcurrentHashMap&lt;&gt;();
    </pre>

    <ul>
        <li>âœ” Fine-grained locking</li>
        <li>âœ” Lock-free reads</li>
        <li>âœ” High throughput</li>
        <li>âœ” Scales well with CPU cores</li>
    </ul>

    <div class="divider"></div>

    <h2>ğŸ”¹ Internal Working</h2>

    <h3>Java 7 and Earlier (Segmented Locking)</h3>

    <ul>
        <li>Map divided into segments</li>
        <li>Each segment had its own lock</li>
        <li>Parallel writes to different segments</li>
    </ul>

    <pre>
Map
 â”œâ”€ Segment 1 (Lock)
 â”œâ”€ Segment 2 (Lock)
 â”œâ”€ Segment 3 (Lock)
    </pre>

    <div class="note">
        âš ï¸ Segments are removed in Java 8
    </div>

    <h3>Java 8+ Internal Design (INTERVIEW FAVORITE)</h3>

    <ul>
        <li>CAS (Compare-And-Swap)</li>
        <li>Volatile variables</li>
        <li>Synchronized blocks on bins</li>
        <li>No global lock</li>
    </ul>

    <pre>
Bucket (Bin)
 â”œâ”€ Linked List
 â””â”€ Red-Black Tree
    </pre>

    <div class="divider"></div>

    <h2>ğŸ”¹ Reads (VERY FAST)</h2>

    <ul>
        <li>Lock-free</li>
        <li>Uses volatile reads</li>
        <li>Multiple threads read simultaneously</li>
    </ul>

    <pre>
map.get(key); // non-blocking
    </pre>

    <h2>ğŸ”¹ Writes (Controlled Locking)</h2>

    <pre>
map.put(key, value);
    </pre>

    <ul>
        <li>Uses CAS first</li>
        <li>Locks only the bucket (bin) if needed</li>
        <li>No full map lock</li>
    </ul>

    <div class="success">
        âœ” High concurrency without global locking
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Time Complexity</h2>

    <table>
        <tr>
            <th>Operation</th>
            <th>Complexity</th>
        </tr>
        <tr>
            <td>get()</td>
            <td>O(1) average</td>
        </tr>
        <tr>
            <td>put()</td>
            <td>O(1) average</td>
        </tr>
        <tr>
            <td>worst case</td>
            <td>O(log n)</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>ğŸ”¹ Null Handling</h2>

    <div class="danger">
        <pre>
map.put(null, "value");  // âŒ NPE
map.put("key", null);    // âŒ NPE
        </pre>
    </div>

    <div class="note">
        Nulls are not allowed to avoid ambiguity in concurrent reads.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Iteration Behavior</h2>

    <pre>
for (Map.Entry&lt;String, User&gt; e : map.entrySet()) {
    map.put("newKey", user);  // âœ… NO CME
}
    </pre>

    <ul>
        <li>âœ” No <code>ConcurrentModificationException</code></li>
        <li>âœ” Iterators are <strong>weakly consistent</strong></li>
    </ul>

    <div class="note">
        Weakly consistent = may reflect some updates,
        never throws CME, never sees corrupted data.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Atomic Operations (ğŸ”¥ HUGE FEATURE)</h2>

    <h3>âŒ NOT Safe</h3>

    <pre>
if (!map.containsKey(key)) {
    map.put(key, value);
}
    </pre>

    <h3>âœ… Thread-Safe Atomic Methods</h3>

    <pre>
map.putIfAbsent(key, value);
map.computeIfAbsent(key, k -> new User(k));
map.computeIfPresent(key, (k, v) -> update(v));
    </pre>

    <div class="divider"></div>

    <h2>ğŸ”¹ Real-World Usage</h2>

    <ul>
        <li>In-memory caches</li>
        <li>Session stores</li>
        <li>Rate limiters</li>
        <li>Feature flags</li>
        <li>Token validation</li>
        <li>Metrics aggregation</li>
    </ul>

    <pre>
ConcurrentHashMap&lt;String, Session&gt; sessions = new ConcurrentHashMap&lt;&gt;();
sessions.putIfAbsent(userId, new Session());
    </pre>

    <div class="divider"></div>

    <h2>ğŸ”¹ ConcurrentHashMap vs Others</h2>

    <table>
        <tr>
            <th>Feature</th>
            <th>HashMap</th>
            <th>SynchronizedMap</th>
            <th>ConcurrentHashMap</th>
        </tr>
        <tr>
            <td>Thread-safe</td>
            <td>âŒ</td>
            <td>âœ…</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>Fast</td>
            <td>Slow</td>
            <td>Fast</td>
        </tr>
        <tr>
            <td>CME</td>
            <td>âŒ</td>
            <td>âŒ</td>
            <td>âŒ</td>
        </tr>
        <tr>
            <td>Nulls</td>
            <td>âœ…</td>
            <td>âœ…</td>
            <td>âŒ</td>
        </tr>
        <tr>
            <td>Locking</td>
            <td>None</td>
            <td>Global</td>
            <td>Bucket-level</td>
        </tr>
    </table>

    <div class="divider"></div>

    <h2>ğŸ”¹ Interview Traps</h2>

    <div class="note">
        â“ Is <code>ConcurrentHashMap</code> fully synchronized?<br>
        âŒ No â€” it uses fine-grained synchronization.
    </div>

    <div class="note">
        â“ Does it block reads?<br>
        âŒ Reads are lock-free.
    </div>

    <div class="note">
        â“ Is it fail-safe?<br>
        âŒ Not exactly â€” it is weakly consistent.
    </div>

    <div class="divider"></div>

    <h2>ğŸ”¹ Perfect Interview Answer</h2>

    <div class="success">
        â€œConcurrentHashMap is a thread-safe map designed for high concurrency.
        It allows concurrent reads without locking and uses fine-grained locking
        or CAS for writes. Unlike synchronizedMap, it does not lock the entire map,
        and unlike HashMap, it avoids data corruption in multithreaded environments.â€
    </div>

    <div class="divider"></div>

    <h2>ğŸ§  Golden Rules</h2>

    <ul>
        <li>âœ” Use <code>ConcurrentHashMap</code> in multi-threaded systems</li>
        <li>âœ” Prefer <code>computeIfAbsent()</code></li>
        <li>âœ” Avoid <code>synchronizedMap()</code> under load</li>
        <li>âœ” Never expect ordering</li>
        <li>âœ” No null keys or values</li>
    </ul>	
	<div class="divider"></div>
</div>
<a href="#" class="back-to-top">â†‘</a>
</body>
</html>
