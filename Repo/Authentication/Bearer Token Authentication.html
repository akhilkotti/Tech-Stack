<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bearer Token Login & Secure Flow</title>

<style>
    body {
      margin: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      background: #f4f6f8;
      color: #1f2933;
      line-height: 1.6;
    }

    .container {
      max-width: 1150px;
      margin: 24px auto;
      background: #ffffff;
      padding: 28px 34px;
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
    }

    h1 {
      font-size: 28px;
      border-bottom: 3px solid #2563eb;
      padding-bottom: 8px;
    }

    h2 {
      margin-top: 40px;
      font-size: 22px;
      color: #2563eb;
    }

    h3 {
      margin-top: 26px;
      font-size: 18px;
      color: #111827;
    }

    .note {
      background: #eef2ff;
      border-left: 6px solid #2563eb;
      padding: 16px 18px;
      margin: 20px 0;
      border-radius: 6px;
      font-weight: 500;
    }

    .warning {
      background: #fff7ed;
      border-left: 6px solid #f97316;
      padding: 16px 18px;
      margin: 20px 0;
      border-radius: 6px;
      font-weight: 600;
    }

    .success {
      background: #ecfdf5;
      border-left: 6px solid #10b981;
      padding: 16px 18px;
      margin: 20px 0;
      border-radius: 6px;
      font-weight: 600;
    }

    pre {
      background: #0f172a;
      color: #e5e7eb;
      padding: 14px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 14px;
      margin-top: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 24px;
    }

    th, td {
      border: 1px solid #e5e7eb;
      padding: 10px 12px;
      text-align: left;
    }

    th {
      background: #f1f5f9;
      font-weight: 600;
    }

    code.inline {
      background: #e5e7eb;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: Consolas, monospace;
      font-size: 14px;
    }

    .divider {
      height: 2px;
      background: linear-gradient(to right, #2563eb, transparent);
      margin: 40px 0;
    }
</style>

</head>
<body>

<div class="container">



<h1> Bearer Tokens ‚Äî Explained Clearly</h1>

<div class="note">
  <strong>Interview-Ready One-Liner:</strong><br />
  Bearer token authentication works by issuing a time-limited token after login,
  which the client sends in the <code class="inline">Authorization: Bearer</code> header
  for subsequent requests‚Äîavoiding repeated credential exposure and enabling
  stateless, scalable security.
</div>

<div class="divider"></div>

<h2> What Is a Bearer Token?</h2>

<p>
A <strong>Bearer Token</strong> is a <strong>temporary credential</strong> issued by the server
<strong>after successful authentication</strong>.
</p>

<div class="warning">
  Whoever <strong>bears the token</strong> can access protected resources ‚Äî
  <strong>no password required</strong> on subsequent requests.
</div>

<div class="divider"></div>
<h1>Bearer Token Login & Secure API Flow</h1>	
<p><strong>complete, step-by-step flow</strong> of BOTH:</p>

<p> <strong>LOGIN FLOW (/login)</strong><br>
and<br>
 <strong>SECURE FLOW (/secure)</strong></p>

<p>Shows every step, every method, every class involved ‚Äî in the exact order executed by Spring Boot, Spring Security, and the custom code.</p>

<hr class="divider">

<h2> PART 1 ‚Äî LOGIN FLOW ( `/login` )</h2>

<h3> <strong>Step 1: Postman Sends Login Request</strong></h3>

<pre>
POST http://localhost:8081/login
Content-Type: application/json

{
  "username": "john",
  "password": "12345"
}
</pre>

<hr>

<h3> <strong>Step 2: Request Enters Spring Security Filter Chain</strong></h3>

<p>Spring Security filters run first.</p>

<p><strong>BUT</strong> your filter (<code class="inline">BearerTokenFilter</code>) defines:</p>

<pre>
shouldNotFilter("/login") ‚Üí true
</pre>

<p>So the filter is <strong>skipped</strong>.</p>

<hr>

<h3> <strong>Step 3: Request Reaches DispatcherServlet</strong></h3>

<p>DispatcherServlet decides which controller to call.</p>

<pre>
/login ‚Üí AuthController.login()
</pre>

<hr>

<h3> <strong>Step 4: Controller Method Starts</strong></h3>

<pre>
@PostMapping("/login")
public Map<String, String> login(@RequestBody Map<String, String> req) {
    String token = service.login(req.get("username"), req.get("password"));
    return Map.of("token", token);
}
</pre>

<p>Steps inside this:</p>
<ol>
    <li>Extract <code class="inline">username</code> from request body</li>
    <li>Extract <code class="inline">password</code></li>
    <li>Call <code class="inline">AuthService.login(username, password)</code></li>
</ol>

<hr>

<h3> <strong>Step 5: AuthService.login() is executed</strong></h3>

<pre>
User user = repository.findByUsername(username)
</pre>

<p>This triggers:</p>
<ul>
    <li>JPA ‚Üí Hibernate ‚Üí PostgreSQL</li>
</ul>

<pre>
SELECT * FROM users WHERE username="john";
</pre>

<p>User returned ‚Üí OR exception thrown if missing.</p>

<hr>

<h3> <strong>Step 6: Validate Password</strong></h3>

<pre>
encoder.matches(password, user.getPassword())
</pre>

<p>If wrong:</p>

<pre>
throw new RuntimeException("Invalid credentials")
</pre>

<hr>

<h3> <strong>Step 7: Generate a Token</strong></h3>

<pre>
String token = UUID.randomUUID().toString();
</pre>

<p>Example token:</p>

<pre>
0c96e09b-7ed8-43ab-a90e-1aabf0cbfdd8
</pre>

<hr>

<h3> <strong>Step 8: Store Token in memory tokenStore</strong></h3>

<pre>
tokenStore.put(token, username);
</pre>

<p>Example:</p>

<pre>
tokenStore["0c96e09b"] = "john"
</pre>

<hr>

<h3> <strong>Step 9: AuthController Returns Token to Client</strong></h3>

<pre>
{
  "token": "0c96e09b-7ed8-43ab-a90e-1aabf0cbfdd8"
}
</pre>

<hr>

<h3> <strong>LOGIN FLOW SUMMARY</strong></h3>

<pre>
Postman
  ‚Üì
SecurityFilter (skipped)
  ‚Üì
AuthController.login()
  ‚Üì
AuthService.login()
  ‚Üì
UserRepository.findByUsername()
  ‚Üì
Password check
  ‚Üì
Generate token
  ‚Üì
Store in map
  ‚Üì
Return token
</pre>

<hr class="divider">

<h2>üöÄ PART 2 ‚Äî SECURE FLOW ( `/secure` )</h2>

<p>Now user sends:</p>

<pre>
GET /secure
Authorization: Bearer &lt;TOKEN&gt;
</pre>

<hr>

<h3> <strong>Step 1: Postman Sends Secure API Request</strong></h3>

<pre>
GET http://localhost:8081/secure
Authorization: Bearer 0c96e09b-7ed8-43ab-a90e-1aabf0cbfdd8
</pre>

<hr>

<h3> <strong>Step 2: Request Enters Spring Security Filter Chain</strong></h3>

<p>This time <code class="inline">/secure</code> is NOT excluded.</p>

<p>So Security calls:</p>

<h3>FIRST ‚Äî <code class="inline">shouldNotFilter()</code></h3>

<pre>
shouldNotFilter("/secure") = false
</pre>

<p>So filter <strong>will execute</strong>.</p>

<hr>

<h3> <strong>Step 3: BearerTokenFilter.doFilterInternal() is invoked</strong></h3>

<pre>
doFilterInternal(request, response, chain)
</pre>

<hr>

<h3> <strong>Step 4: Get Authorization Header</strong></h3>

<pre>
String header = request.getHeader("Authorization");
</pre>

<p>Header must be:</p>

<pre>
Bearer &lt;token&gt;
</pre>

<p>If missing ‚Üí respond 401.</p>

<hr>

<h3> <strong>Step 5: Extract Token</strong></h3>

<pre>
String token = header.substring(7);
</pre>

<p>Example:</p>

<pre>
"Bearer 0c96e09b..." ‚Üí "0c96e09b..."
</pre>

<hr>

<h3> <strong>Step 6: Validate Token</strong></h3>

<pre>
String username = authService.validateToken(token);
</pre>

<p>Inside:</p>

<pre>
return tokenStore.get(token);
</pre>

<p>If token exists ‚Üí username returned<br>
If not ‚Üí 401 Unauthorized</p>

<hr>

<h3> <strong>Step 7: Create Authentication Object</strong></h3>

<pre>
Authentication auth =
 new UsernamePasswordAuthenticationToken(
    username,
    null,
    List.of(new SimpleGrantedAuthority("ROLE_USER"))
 );
</pre>

<hr>

<h3> <strong>Step 8: Store in Spring Security Context</strong></h3>

<pre>
SecurityContextHolder.getContext().setAuthentication(auth);
</pre>

<p>This marks request as <strong>authenticated</strong>.</p>

<hr>

<h3> <strong>Step 9: Continue Filter Chain</strong></h3>

<pre>
chain.doFilter(request, response);
</pre>

<p>Now <strong>filtering is done</strong>, user is authenticated, control goes to DispatcherServlet.</p>

<hr>

<h3> <strong>Step 10: DispatcherServlet Finds Matching Controller</strong></h3>

<pre>
/secure ‚Üí SecureController.secure()
</pre>

<hr>

<h3> <strong>Step 11: Controller Method Executes</strong></h3>

<pre>
@GetMapping("/secure")
public String secure(Authentication authentication)
</pre>

<p><code class="inline">authentication.getName()</code> returns <strong>"john"</strong>.</p>

<hr>

<h3> <strong>Step 12: Response Returned to Client</strong></h3>

<pre>
Hello john ‚Äî Bearer Auth Success!
</pre>

<hr>

<h3> <strong>SECURE FLOW SUMMARY</strong></h3>

<pre>
Postman
  ‚Üì
SecurityFilterChain
  ‚Üì
shouldNotFilter("/secure") = false
  ‚Üì
BearerTokenFilter.doFilterInternal()
  ‚Üì
Extract header
  ‚Üì
Validate token (AuthService)
  ‚Üì
Create Authentication
  ‚Üì
Set SecurityContext
  ‚Üì
chain.doFilter()
  ‚Üì
DispatcherServlet
  ‚Üì
SecureController.secure()
  ‚Üì
Return "Hello &lt;username&gt;"
</pre>
<hr class="divider">
<h2> FINAL SUPER SUMMARY (Both Flows)</h2>

<pre>
LOGIN FLOW:  
Postman ‚Üí /login ‚Üí AuthController ‚Üí AuthService ‚Üí tokenStore.put() ‚Üí return token

SECURE FLOW:
Postman ‚Üí /secure ‚Üí BearerTokenFilter ‚Üí validate token ‚Üí SecurityContext ‚Üí Controller ‚Üí return success
</pre>
<hr class="divider">
<h2>‚úî BEARER TOKEN PROS</h2>

<table>
<tr><th>Benefit</th><th>Explanation</th></tr>
<tr><td>Username/password NOT sent per request</td><td>More secure</td></tr>
<tr><td>Authentication expensive only once</td><td>Faster subsequent requests</td></tr>
<tr><td>Token can expire</td><td>Better security</td></tr>
<tr><td>Token can be revoked</td><td>Logout possible</td></tr>
<tr><td>Works well with mobile apps</td><td>Store token in app memory */</td></tr>
</table>

<div class="divider"></div>

<h2>‚ùå BEARER TOKEN CONS</h2>

<table>
<tr><th>Problem</th><th>Explanation</th></tr>
<tr><td>Requires login endpoint</td><td>Needs extra API</td></tr>
<tr><td>Tokens must be stored somewhere</td><td>Memory / DB / Redis</td></tr>
<tr><td>Must implement expiration manually</td><td>More logic needed</td></tr>
<tr><td>Tokens can be stolen</td><td>If intercepted, attacker has access</td></tr>
</table>

<div class="divider"></div>

<h1> BASIC AUTH VS BEARER TOKEN ‚Äî SIDE BY SIDE</h1>

<table>
<tr><th>Concept</th><th>Basic Auth</th><th>Bearer Token</th></tr>
<tr><td>Credentials sent every request</td><td>Yes</td><td>No</td></tr>
<tr><td>Token sent every request</td><td>No</td><td>Yes</td></tr>
<tr><td>Login endpoint</td><td>Not required</td><td>Required</td></tr>
<tr><td>Performance</td><td>Slow (DB hit every time)</td><td>Fast (DB hit once)</td></tr>
<tr><td>Token expiration</td><td>Not supported</td><td>Yes, can be added</td></tr>
<tr><td>Token revocation</td><td>Hard</td><td>Easy</td></tr>
<tr><td>Security level</td><td>Low</td><td>Medium/High</td></tr>
<tr><td>Supported by browsers</td><td>Yes</td><td>No</td></tr>
<tr><td>Session management</td><td>None</td><td>Token based</td></tr>
</table>

<div class="divider"></div>

<h1> SECURITY DIFFERENCE</h1>


<h2> BASIC AUTH SECURITY WEAKNESS</h2>

<p>Every request exposes:</p>

<pre>username:password</pre>

<p>Even though it's Base64 encoded, it is very easy to decode.</p>

<div class="divider"></div>

<h2> BEARER TOKEN SECURITY WEAKNESS</h2>

<p>If token leaks, attacker has full access until:</p>

<ul>
  <li>token expires</li>
  <li>or token is revoked</li>
</ul>

<div class="divider"></div>

<h1> WHEN TO USE BASIC AUTH?</h1>

<p>Use Basic Auth when:</p>

<ul>
  <li>Internal service talking to another internal service</li>
  <li>Low-security environments</li>
  <li>Temporary admin tools</li>
  <li>Quick prototypes</li>
  <li>No sessions or tokens needed</li>
</ul>

<div class="divider"></div>

<h1> WHEN TO USE BEARER TOKEN?</h1>

<p>Use Bearer Token when:</p>

<ul>
  <li>Secure APIs</li>
  <li>Mobile apps</li>
  <li>Microservices</li>
  <li>Login-based web apps</li>
  <li>Stateless REST services</li>
  <li>Need token expiry + logout</li>
</ul>

<div class="divider"></div>

<h1> BEARER TOKEN IS BETTER THAN BASIC AUTH</h1>

<p>Why?</p>

<ul>
  <li>Username/password is NOT exposed every time</li>
  <li>Faster (no DB queries each request)</li>
  <li>Token can expire</li>
  <li>Token can be revoked</li>
  <li>Scalable for distributed apps</li>
</ul>

<div class="divider"></div>

<h1> IMPORTANT: YOUR IMPLEMENTATION IS <strong>PURE BEARER TOKEN</strong>, NOT JWT</h1>

<p>Your token is a:</p>

<pre>UUID stored in memory</pre>

<p>NOT a self-contained signed JWT.</p>

<div class="divider"></div>

<h1> FINAL SUMMARY</h1>

<h2>Basic Auth</h2>

<pre>Authorization: Basic Base64(username:password)</pre>

<ul>
  <li>Password sent each request</li>
  <li>DB lookup every time</li>
  <li>Weak security</li>
</ul>

<h2>Bearer Token</h2>

<pre>Authorization: Bearer &lt;token&gt;</pre>

<ul>
  <li>Password used only once</li>
  <li>Token used after login</li>
  <li>More secure and faster</li>
</ul>

<div class="divider"></div>

</div>

</body>
</html>
